

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Usage &mdash; copepodTCR 0.5.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=b9afe91b"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Shiny App" href="ShinyApp.html" />
    <link rel="prev" title="Installation" href="Installation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html">
            
              <img src="_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">CopepodTCR</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">COmbinatorial PEptide POoling Design for TCR specificity</a></li>
<li class="toctree-l1"><a class="reference internal" href="Installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#quickstart">Quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="#more-detailed-quickstart">More detailed quickstart</a></li>
<li class="toctree-l2"><a class="reference internal" href="#play-with-the-approach-using-simulated-data-optional">Play with the approach using simulated data (Optional)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#function-reference">Function reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#peptide-occurrence-search">Peptide occurrence search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cpp.factorial"><code class="docutils literal notranslate"><span class="pre">cpp.factorial()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.combination"><code class="docutils literal notranslate"><span class="pre">cpp.combination()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.find_possible_k_values"><code class="docutils literal notranslate"><span class="pre">cpp.find_possible_k_values()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#peptides-generation-and-assessment">Peptides generation and assessment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cpp.peptide_generation"><code class="docutils literal notranslate"><span class="pre">cpp.peptide_generation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.string_overlap"><code class="docutils literal notranslate"><span class="pre">cpp.string_overlap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.find_pair_with_overlap"><code class="docutils literal notranslate"><span class="pre">cpp.find_pair_with_overlap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.how_many_peptides"><code class="docutils literal notranslate"><span class="pre">cpp.how_many_peptides()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pooling">Pooling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cpp.bad_address_predictor"><code class="docutils literal notranslate"><span class="pre">cpp.bad_address_predictor()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.pooling"><code class="docutils literal notranslate"><span class="pre">cpp.pooling()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.pools_activation"><code class="docutils literal notranslate"><span class="pre">cpp.pools_activation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.epitope_pools_activation"><code class="docutils literal notranslate"><span class="pre">cpp.epitope_pools_activation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.peptide_search"><code class="docutils literal notranslate"><span class="pre">cpp.peptide_search()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.run_experiment"><code class="docutils literal notranslate"><span class="pre">cpp.run_experiment()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#d-models">3D models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cpp.pick_engine"><code class="docutils literal notranslate"><span class="pre">cpp.pick_engine()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.stl_generator"><code class="docutils literal notranslate"><span class="pre">cpp.stl_generator()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.pools_stl"><code class="docutils literal notranslate"><span class="pre">cpp.pools_stl()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.zip_meshes_export"><code class="docutils literal notranslate"><span class="pre">cpp.zip_meshes_export()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.zip_meshes"><code class="docutils literal notranslate"><span class="pre">cpp.zip_meshes()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#results-interpretation-with-a-bayesian-mixture-model">Results interpretation with a Bayesian mixture model</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cpp.activation_model"><code class="docutils literal notranslate"><span class="pre">cpp.activation_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.peptide_probabilities"><code class="docutils literal notranslate"><span class="pre">cpp.peptide_probabilities()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.results_analysis"><code class="docutils literal notranslate"><span class="pre">cpp.results_analysis()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#in-silico-data-generation">In silico data generation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cpp.random_amino_acid_sequence"><code class="docutils literal notranslate"><span class="pre">cpp.random_amino_acid_sequence()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.simulation"><code class="docutils literal notranslate"><span class="pre">cpp.simulation()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#plotting-results">Plotting results</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cpp.poolplot"><code class="docutils literal notranslate"><span class="pre">cpp.poolplot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.bubbleplot"><code class="docutils literal notranslate"><span class="pre">cpp.bubbleplot()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cpp.hover_bubbleplot"><code class="docutils literal notranslate"><span class="pre">cpp.hover_bubbleplot()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ShinyApp.html">Shiny App</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">copepodTCR</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Usage</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Usage.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="usage">
<h1>Usage<a class="headerlink" href="#usage" title="Link to this heading"></a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">copepodTCR</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cpp</span>
</pre></div>
</div>
<p>To use the package for basic tasks, the <strong>Quickstart</strong> section is
enough. To read more about used functions, check other sections.</p>
<section id="quickstart">
<span id="quickstart-section"></span><h2>Quickstart<a class="headerlink" href="#quickstart" title="Link to this heading"></a></h2>
<p>To generate CPP scheme and print masks:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">copepodTCR</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cpp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">codepub</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cdp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

<span class="c1"># [Optional] set random seed</span>
<span class="n">cdp</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="n">cpp</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>

<span class="c1"># number of pools</span>
<span class="n">n_pools</span> <span class="o">=</span> <span class="mi">12</span>
<span class="c1"># peptide occurrence</span>
<span class="n">iters</span> <span class="o">=</span> <span class="mi">4</span>
<span class="c1"># number of peptides</span>
<span class="n">len_lst</span> <span class="o">=</span> <span class="mi">253</span>

<span class="c1"># address arrangemement</span>
<span class="n">b</span><span class="p">,</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">cdp</span><span class="o">.</span><span class="n">bba</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">n_pools</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">iters</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">len_lst</span><span class="p">)</span>

<span class="c1"># if you have a lot of peptide, for faster address arrangement we recommend using:</span>
<span class="c1">## b, lines = cdp.rcbba(m=n_pools, r=iters, n=len_lst)</span>

<span class="c1"># add your peptides to lst</span>
<span class="n">lst</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;peptides.csv&#39;</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">))</span>

<span class="c1"># pooling scheme generation</span>
<span class="n">pools</span><span class="p">,</span> <span class="n">peptide_address</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">pooling</span><span class="p">(</span><span class="n">lst</span><span class="o">=</span><span class="n">lst</span><span class="p">,</span> <span class="n">addresses</span><span class="o">=</span><span class="n">lines</span><span class="p">,</span> <span class="n">n_pools</span><span class="o">=</span><span class="n">n_pools</span><span class="p">)</span>
<span class="c1"># save these files</span>
<span class="n">pools</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;path\pools.tsv&#39;</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
<span class="n">peptide_address</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;path\peptide_addresses.tsv&#39;</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># simulation</span>
<span class="n">check_results</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">run_experiment</span><span class="p">(</span><span class="n">lst</span><span class="o">=</span><span class="n">lst</span><span class="p">,</span> <span class="n">peptide_address</span><span class="o">=</span><span class="n">peptide_address</span><span class="p">,</span> <span class="n">ep_length</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">pools</span><span class="o">=</span><span class="n">pools</span><span class="p">,</span> <span class="n">iters</span><span class="o">=</span><span class="n">iters</span><span class="p">,</span> <span class="n">n_pools</span><span class="o">=</span><span class="n">n_pools</span><span class="p">,</span> <span class="n">regime</span><span class="o">=</span><span class="s1">&#39;without dropouts&#39;</span><span class="p">)</span>
<span class="c1"># save this file</span>
<span class="n">check_results</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;path\check_results.tsv&#39;</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># STL files generation</span>
<span class="c1"># add peptide scheme to peptides_table_stl, with header and index as column and row numbers</span>
<span class="n">peptides_table_stl</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;peptides_scheme.tsv&#39;</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">index_col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">pools_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;Peptides&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">pools</span><span class="o">.</span><span class="n">values</span><span class="p">()]},</span> <span class="n">index</span><span class="o">=</span><span class="n">pools</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<span class="c1"># now you need to select the engine, pick_engine function should help with that</span>
<span class="c1"># default engine is manifold3d</span>
<span class="n">ENGINE</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">pick_engine</span><span class="p">()</span>

<span class="n">meshes_list</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">pools_stl</span><span class="p">(</span><span class="n">peptides_table</span> <span class="o">=</span> <span class="n">peptides_table_stl</span><span class="p">,</span> <span class="n">pools</span> <span class="o">=</span> <span class="n">pools_df</span><span class="p">,</span> <span class="n">rows</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="mf">122.10</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="mf">79.97</span><span class="p">,</span>
           <span class="n">thickness</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">hole_radius</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x_offset</span> <span class="o">=</span> <span class="mf">9.05</span><span class="p">,</span> <span class="n">y_offset</span> <span class="o">=</span> <span class="mf">6.20</span><span class="p">,</span> <span class="n">well_spacing</span> <span class="o">=</span> <span class="mf">4.5</span><span class="p">,</span> <span class="n">engine</span> <span class="o">=</span> <span class="n">ENGINE</span><span class="p">)</span>
<span class="n">cpp</span><span class="o">.</span><span class="n">zip_meshes_export</span><span class="p">(</span><span class="n">meshes_list</span><span class="p">)</span>
</pre></div>
</div>
<p>To analyze results:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># import your CPP scheme</span>
<span class="n">check_results</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;path\check_results.tsv&#39;</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># results of the experiment as a table with two columns, Pool and Percentage. Activation signal is expressed in percentaged of activated T cells.</span>
<span class="n">exp_results</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;path/to/your/file&#39;</span><span class="p">)</span>
<span class="n">cells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exp_results</span><span class="p">[</span><span class="s1">&#39;Percentage&#39;</span><span class="p">])</span>
<span class="n">inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exp_results</span><span class="p">[</span><span class="s1">&#39;Pool&#39;</span><span class="p">])</span>

<span class="c1"># also here you can enter your negative control values:</span>
<span class="n">neg_control</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;path/to/your/neg_control&#39;</span><span class="p">))</span>

<span class="c1"># to calculate expected number of negative pools based on the scheme parameters:</span>
<span class="c1"># neg_share = (n_pools - iters - e + 1)/n_pools, where e is number of peptides sharing the same epitope</span>
<span class="n">t</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">how_many_peptides</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">ep_length</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
<span class="n">neg_share</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_pools</span> <span class="o">-</span> <span class="n">iters</span> <span class="o">-</span> <span class="n">e</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">n_pools</span>

<span class="c1"># Model</span>
<span class="n">model</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">probs</span><span class="p">,</span> <span class="n">n_c</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">pn</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">activation_model</span><span class="p">(</span><span class="n">cells</span><span class="p">,</span> <span class="n">n_pools</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">neg_control</span><span class="p">,</span> <span class="n">neg_share</span> <span class="o">=</span> <span class="n">neg_share</span><span class="p">)</span>
<span class="n">peptide_probs</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">peptide_probabilities</span><span class="p">(</span><span class="n">check_results</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span>
<span class="n">n_act_pools</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">most</span><span class="p">,</span> <span class="n">possible</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">results_analysis</span><span class="p">(</span><span class="n">peptide_probs</span><span class="p">,</span> <span class="n">probs</span><span class="p">,</span> <span class="n">check_results</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">most</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">possible</span><span class="p">)</span>

<span class="c1"># Plotting results</span>

<span class="c1"># log10 of percentage of activated T cells per pool</span>
<span class="n">poolplot</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">most</span><span class="p">)</span>

<span class="c1"># interactive version of the bubbleplot, with each peptide = 1 bubble, its size represents</span>
<span class="c1"># difference between number of activated and non-activated pools in its address,</span>
<span class="c1"># X-axis: position of peptide in the protein,</span>
<span class="c1"># Y-axis: peptide probability</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">plotly.io</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pio</span>
<span class="n">pio</span><span class="o">.</span><span class="n">renderers</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="s2">&quot;notebook_connected&quot;</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">hover_bubbleplot</span><span class="p">(</span><span class="n">peptide_probs</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1">## if interactive version is not displayed, you can check usual bubbleplot:</span>
<span class="n">bubbleplot</span><span class="p">(</span><span class="n">peptide_probs</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="more-detailed-quickstart">
<span id="quickstartf-section"></span><h2>More detailed quickstart<a class="headerlink" href="#more-detailed-quickstart" title="Link to this heading"></a></h2>
<ol class="arabic">
<li><p>(Optional) <strong>To be able to reproduce your results later, you can set random seed.</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A random seed is an initialization value that determines the sequence of numbers generated by a pseudorandom number generator.</p>
<ul class="simple">
<li><p>Without setting a seed, each execution of a code will produce a different sequence of results, even if the code is identical, because the generator is seeded differently each time.</p></li>
<li><p>If a seed is set once in an earlier cell in Jupyter notebook and that cell is not rerun, then repeatedly executing a later cell will continue the sequence from where the generator last left off, producing different results each time.</p></li>
<li><p>However, if the same random seed is explicitly set at the start of every cell, the generator will restart from the same point, producing identical and reproducible results on every run.</p></li>
</ul>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cdp</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>(Optional) <strong>Generate your peptides from a protein of interest.</strong></p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">peptide_generation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protein</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peptide_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peptide_shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protein_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>protein</strong> (<em>str</em><em> or </em><em>list</em><em> of </em><em>str</em>) – a single protein sequence (string) or a list of protein sequences</p></li>
<li><p><strong>peptide_length</strong> (<em>int</em>) – length of each generated peptide</p></li>
<li><p><strong>peptide_shift</strong> (<em>int</em>) – number of positions to shift between consecutive peptides (i.e., peptide_length - overlap)</p></li>
<li><p><strong>protein_end</strong> (<em>bool</em><em>, </em><em>default is False</em>) – whether to include trailing peptide if protein ends with a short fragment</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of generated peptide sequences</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">peptides</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">peptide_generation</span><span class="p">(</span><span class="s2">&quot;MKWVTFISLLFLFSSAYSRGVFRRDTHKSEIAHRFKDLGE&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peptides</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[&#39;MKWVTFISL&#39;, &#39;TFISLLFLF&#39;, &#39;LLFLFSSAY&#39;]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>If the input is a list of proteins, the peptides will be generated for each individually and concatenated.</p></li>
<li><p>If protein_end is True, peptides near the C-terminus will be padded by upstream sequence if shorter than expected.</p></li>
</ul>
</div>
</dd></dl>

</li>
<li><p>(Optional) <strong>Check your peptide list for overlap consistency.</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Incosistent overlap length can lead to hindered results interpretation.</p>
</div>
<p>You can check all peptides for their overlap length with the next
peptide (list of peptides should be ordered):</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">all_overlaps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lst</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Counter</span> <span class="pre">object</span></span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>lst</strong> (<em>list</em>) – ordered list of peptides</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Counter object with the dictionary, where the key is the overlap length and the value is the number of pairs with such overlap.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Counter object</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">all_overlaps</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
<span class="go">Counter({12: 251, 16: 1})</span>
</pre></div>
</div>
</dd></dl>

<p>=&gt; 251 pairs of peptides with an overlap of length of 12 amino acids,
and 1 pair with an overlap of length 16 amino acids.</p>
<p>Also, you can check which peptides have such an overlap with the next
peptide:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">find_pair_with_overlap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_overlap</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lst</strong> (<em>list</em>) – ordered list of peptides</p></li>
<li><p><strong>target_overlap</strong> (<em>int</em>) – overlap length</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of lists with peptides with specified overlap length.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">find_pair_with_overlap</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="go">[[&#39;FDEDDSEPVLKGVKLHY&#39;, &#39;DEDDSEPVLKGVKLHYT&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<p>=&gt; Overlap of length 16 amino acids is in peptides <em>FDEDDSEPVLKGVKLHY</em> and <em>DEDDSEPVLKGVKLHYT</em>.</p>
<p>Also, you can check what number of peptides share the same epitope.
It might help to interpret the results later.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">how_many_peptides</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ep_length</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Counter</span> <span class="pre">object,</span> <span class="pre">dictionary</span></span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lst</strong> (<em>list</em>) – ordered list of peptides</p></li>
<li><p><strong>ep_length</strong> (<em>int</em>) – expected epitope length</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ol class="arabic simple">
<li><p>the Counter object with the number of epitopes shared across the number of peptides;</p></li>
<li><p>the dictionary with all possible epitopes of expected length as keys and the number of peptides where these epitopes are present as values.</p></li>
</ol>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Counter object, dictionary</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">how_many_peptides</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span>
<span class="go">Counter({1: 6, 2: 1256, 3: 4})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span>
<span class="go">{&#39;MFVFLVLL&#39;: 1,&#39;FVFLVLLP&#39;: 1,VFLVLLPL&#39;: 1,&#39;FLVLLPLV&#39;: 1,&#39;LVLLPLVS&#39;: 1,&#39;VLLPLVSS&#39;: 2, ...,}</span>
</pre></div>
</div>
</dd></dl>

<p>=&gt; There are 6 epitopes present in a single peptide, 1256 epitopes present shared by two peptides, and 4 epitopes shared by 4 peptides. For each epitope, number of peptides sharing it is in the dictionary.</p>
</li>
<li><p>(Optional) <strong>Then you need to determine peptide occurrence across
pools, i.e. to how many pools one peptide would be added.</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Peptide occurrence affects number of peptides in one pool, and therefore too high peptide occurrence may lead to higher dilution of a single peptide.</p>
</div>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">find_possible_k_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – number of pools</p></li>
<li><p><strong>l</strong> (<em>int</em>) – number of peptides</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list with possible peptide occurrences given number of pools and number of peptides.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Counter object, dictionary</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">find_possible_k_values</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
<span class="go">[4, 5, 6, 7, 8]</span>
</pre></div>
</div>
</dd></dl>

<p>=&gt; Given 12 pools and 250 peptides, you can use peptide occurrence equal to 4, 5, 6, 7, 8.</p>
<p>Choose one occurrence value appropriate for your task and proceed.</p>
</li>
<li><p><strong>Now, you need to find the address arrangement given your number of pools, number of peptides, and peptide occurrence.</strong></p>
<p>For that, we developed a separate package <strong>codepub</strong>.</p>
<p>We suggest you use the <strong>codepub.bba</strong> function. If you have a lot of peptides (1000+), we recommend using faster alternative: <strong>codepub.rcbba</strong>. Codepub documentation is available here: <a class="reference external" href="https://codepub.readthedocs.io/en/latest/Introduction.html">CodePUB readthedocs</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With large parameters, the algorithm needs some time to finish the arrangement. If the arrangement fails, try with other parameters.</p>
</div>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">bba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W_des</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span></span></span></dt>
<dd><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Search for arrangement may take some time, especially with large parameters. This function is <strong>slower</strong> than <code class="xref py py-func docutils literal notranslate"><span class="pre">cdp.rcbba()</span></code>, but is more reliable.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – number of pools</p></li>
<li><p><strong>r</strong> (<em>int</em>) – address weight, i.e. to how many pools one item is added</p></li>
<li><p><strong>n</strong> (<em>int</em>) – number of items</p></li>
<li><p><strong>start_a</strong> (<em>str</em>) – desired first address of the arrangement, optional</p></li>
<li><p><strong>W_des</strong> – desired balance for the resulting arrangement</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ol class="arabic simple">
<li><p>list with number of item in each pool, i.e. balance;</p></li>
<li><p>list with address arrangement</p></li>
</ol>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">balance</span><span class="p">,</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">cdp</span><span class="o">.</span><span class="n">bba</span><span class="p">(</span><span class="n">n_pools</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">iters</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">len_lst</span><span class="o">=</span><span class="mi">250</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">balance</span>
<span class="go">[81, 85, 85, 85, 81, 82, 87, 81, 85, 81, 84, 83]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span>
<span class="go">[[0, 1, 2, 3],[0, 1, 3, 6],[0, 1, 6, 8],[1, 6, 8, 9],[6, 8, 9, 11], ... ]</span>
</pre></div>
</div>
</dd></dl>

<p>=&gt; You will get the expected number of peptides in each pool and address arrangement, which will be used in following steps.</p>
</li>
<li><p><strong>Now, you can distribute peptides across pools using the produced address arrangement. One peptide will be added to one produced address.</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Keep in mind that peptides should be ordered as they overlap.</p>
</div>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">pooling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">addresses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_pools</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dictionary</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dictionary</span></span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lst</strong> (<em>list</em>) – ordered list with peptides</p></li>
<li><p><strong>addresses</strong> (<em>list</em>) – produced address arrangement</p></li>
<li><p><strong>n_pools</strong> (<em>int</em>) – number of pools</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ol class="arabic simple">
<li><p>pools – dictionary with keys as pools indices and values as peptides that should be added to this pools;</p></li>
<li><p>peptide address – dictionary with peptides as keys and corresponding addresses as values.</p></li>
</ol>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary, dictionary</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pools</span><span class="p">,</span> <span class="n">peptide_address</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">pooling</span><span class="p">(</span><span class="n">lst</span><span class="o">=</span><span class="n">lst</span><span class="p">,</span> <span class="n">addresses</span><span class="o">=</span><span class="n">lines</span><span class="p">,</span> <span class="n">n_pools</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pools</span>
<span class="go">{0: [&#39;MFVFLVLLPLVSSQCVN&#39;,&#39;VLLPLVSSQCVNLTTRT&#39;,VSSQCVNLTTRTQLPPA&#39;, ...], 1: [&#39;MFVFLVLLPLVSSQCVN&#39;,&#39;VLLPLVSSQCVNLTTRT&#39;,&#39;TQDLFLPFFSNVTWFHA&#39;, ...], ... }</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peptide_address</span>
<span class="go">{&#39;MFVFLVLLPLVSSQCVN&#39;: [0, 1, 2, 3], &#39;VLLPLVSSQCVNLTTRT&#39;: [0, 1, 2, 10], ... }</span>
</pre></div>
</div>
</dd></dl>

<p>=&gt; You will get the pooling scheme and peptide addresses. Don’t forget to save these files!</p>
</li>
<li><p><strong>Now, you can run the simulation using produced pools and peptide_address.</strong></p>
<p>The simulation produces a DataFrame with every possible epitope of the provided length and all pools where this epitope is present. This table is needed to interpret the results.</p>
<p>The function has two regimes: with and without drop-outs. Without
drop-outs, it returns a table as there were no mistakes, and all
pools that should be activated were activated. With drop-outs, it
returns a table with all possible mistakes (i.e. all possible
non-activated pools). This option will need time to be generated,
usually several minutes, although it depends on the number of
peptides and on occurrence.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>“With drop-outs” regime is needed only on very special cases, for example, for calculation of robustness of the scheme to experimental errors.</p>
</div>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">run_experiment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peptide_address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ep_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pools</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_pools</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regime</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pandas</span> <span class="pre">DataFrame</span></span></span></dt>
<dd><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Simulation may take several minutes, especially upon “with drop-outs” regime.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lst</strong> (<em>list</em>) – ordered list with peptides</p></li>
<li><p><strong>peptide_address</strong> (<em>dictionary</em>) – peptides addresses produced by pooling</p></li>
<li><p><strong>ep_length</strong> (<em>int</em>) – expected epitope length</p></li>
<li><p><strong>pools</strong> (<em>dictionary</em>) – pools produced by pooling</p></li>
<li><p><strong>iters</strong> (<em>int</em>) – peptide occurrence</p></li>
<li><p><strong>n_pools</strong> (<em>int</em>) – number of pools</p></li>
<li><p><strong>regime</strong> (<em>“with dropouts”</em><em> or </em><em>“without dropouts”</em>) – regime of simulation, with or without drop-outs</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pandas DataFrame with all possible epitopes of given length and the resulting activated pools</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas DataFrame</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">run_experiment</span><span class="p">(</span><span class="n">lst</span><span class="o">=</span><span class="n">lst</span><span class="p">,</span> <span class="n">peptide_address</span><span class="o">=</span><span class="n">peptide_address</span><span class="p">,</span> <span class="n">ep_length</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">pools</span><span class="o">=</span><span class="n">pools</span><span class="p">,</span> <span class="n">iters</span><span class="o">=</span><span class="n">iters</span><span class="p">,</span> <span class="n">n_pools</span><span class="o">=</span><span class="n">n_pools</span><span class="p">,</span> <span class="n">regime</span><span class="o">=</span><span class="s1">&#39;without dropouts&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Peptide</p></th>
<th class="head"><p>Address</p></th>
<th class="head"><p>Epitope</p></th>
<th class="head"><p>Act Pools</p></th>
<th class="head"><p># of pools</p></th>
<th class="head"><p># of epitopes</p></th>
<th class="head"><p># of peptides</p></th>
<th class="head"><p>Remained</p></th>
<th class="head"><p># of lost</p></th>
<th class="head"><p>Right peptide</p></th>
<th class="head"><p>Right epitope</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>MFVFLVLLPLVSSQCVN</p></td>
<td><p>[0, 1, 2, 3]</p></td>
<td><p>MFVFLVLL</p></td>
<td><p>[0, 1, 2, 3]</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
<td><p>1</p></td>
<td><p>–</p></td>
<td><p>0</p></td>
<td><p>True</p></td>
<td><p>True</p></td>
</tr>
<tr class="row-odd"><td><p>MFVFLVLLPLVSSQCVN</p></td>
<td><p>[0, 1, 2, 3]</p></td>
<td><p>MFVFLVLL</p></td>
<td><p>[0, 1, 2, 3]</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
<td><p>1</p></td>
<td><p>–</p></td>
<td><p>0</p></td>
<td><p>True</p></td>
<td><p>True</p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>MFVFLVLLPLVSSQCVN</p></td>
<td><p>[0, 1, 2, 3]</p></td>
<td><p>VLLPLVSS</p></td>
<td><p>[0, 1, 2, 3, 10]</p></td>
<td><p>5</p></td>
<td><p>5</p></td>
<td><p>2</p></td>
<td><p>–</p></td>
<td><p>0</p></td>
<td><p>True</p></td>
<td><p>True</p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>VLLPLVSSQCVNLTTRT</p></td>
<td><p>[0, 1, 2, 10]</p></td>
<td><p>VLLPLVSS</p></td>
<td><p>[0, 1, 2, 3, 10]</p></td>
<td><p>5</p></td>
<td><p>5</p></td>
<td><p>2</p></td>
<td><p>–</p></td>
<td><p>0</p></td>
<td><p>True</p></td>
<td><p>True</p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Peptide</strong> — peptide sequence</p>
<p><strong>Address</strong> — pool indices where this peptide should be added</p>
<p><strong>Epitope</strong> — checked epitope from this peptide</p>
<p><strong>Act pools</strong> — list with pool indices where this epitope is present</p>
<p><strong># of pools</strong> — number of pools where this epitope is present</p>
<p><strong># of epitopes</strong> — number of epitopes that are present in the same pools (= number of possible peptides upon activation of such pools)</p>
<p><strong># of peptides</strong> — number of peptides in which there are epitopes that are present in the same pools (= number of possible peptides upon activation of such pools)</p>
<p><strong>Remained</strong> — only upon regime=”with dropouts”, list of pools remained after mistake</p>
<p><strong># of lost</strong> — only upon regime=”with dropouts”, number of dropped pools due to mistake</p>
<p><strong>Right peptide</strong> — True or False, whether the peptide is present in the list of possible peptides</p>
<p><strong>Right epitope</strong> — True or False, whether the peptide is present in the list of possible peptides</p>
<p>Save resulting table, it will be required for results interpretation.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>This table can be used to intepret experiment results without applying Bayesian mixture model. Refer to description of <code class="xref py py-func docutils literal notranslate"><span class="pre">cdp.cpp.run_experiment()</span></code> for details.</p>
</div>
</li>
</ol>
<ol class="arabic" start="7">
<li><p>(Optional) <strong>To avoid mixing pools manually, you can print special
mask using files with their 3D models produced by this step.</strong></p>
<p>One mask is needed for each pool. Each mask is a thin
card with holes located at the spots where the needed peptides are
located in the plate. Therefore, each mask has the number of
holes equal to the number of peptides in a pool. Then, this card
should be placed on an empty tip box, and a tip should be inserted
into each hole. This way, if you are using a multichannel pipette,
all tips are already arranged to take only the required peptides.</p>
<p>[How it looks like: <a class="reference external" href="https://drive.google.com/file/d/1wtLNnKj8I7iYdlu1owY5Cl4SegYcouei/view?usp=sharing">here</a>.]</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The rendering of 3D models is a long process, so it could take time.</p>
</div>
<p>To generate the files with 3D models, you need two functions. But first, you need to check with engine is available for boolean operations. By default it is manifold3d, but also you can use blender if it is available.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ENGINE</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">pick_engine</span><span class="p">()</span>
</pre></div>
</div>
<p>Now ENGINE should be passed as argument to the next function:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">pools_stl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">peptides_table</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pools</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">engine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">24</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">122.10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">79.97</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thickness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hole_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.0</span> <span class="pre">/</span> <span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">9.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">well_spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.5</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dictionary</span></span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>peptides_table</strong> (<em>pandas DataFrame</em>) – table representing the arrangement of peptides in a plate, is not produced by any function in the package</p></li>
<li><p><strong>pools</strong> (<em>pandas DataFrame</em>) – table with a pooling scheme, where one row represents each pool, pool index is the index column, and a string with all peptides added to this pool separated by “;” is “Peptides” column.</p></li>
<li><p><strong>engine</strong> (<em>str</em>) – engine for trimesh.boolean.union() and trimesh.difference(), “manifold”</p></li>
<li><p><strong>rows</strong> (<em>int</em>) – int</p></li>
<li><p><strong>cols</strong> (<em>int</em>) – number of columns in your plate with peptides</p></li>
<li><p><strong>length</strong> (<em>float</em>) – length of the plate in mm</p></li>
<li><p><strong>width</strong> (<em>float</em>) – width of the plate in mm</p></li>
<li><p><strong>thickness</strong> (<em>float</em>) – desired thickness of the mask, in mm</p></li>
<li><p><strong>hole_radius</strong> (<em>float</em>) – the radius of the holes, in mm, should be adjusted to fit your tip</p></li>
<li><p><strong>x_offset</strong> (<em>float</em>) – the margin along the X axis for the A1 hole, in mm</p></li>
<li><p><strong>y_offset</strong> (<em>float</em>) – the margin along the Y axis for the A1 hole, in mm</p></li>
<li><p><strong>well_spacing</strong> (<em>float</em>) – the distance between wells, in mm</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>dictionary with Mesh objects, where key is pool index, and value is a Mesh object of a corresponding mask</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">meshes_list</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">pools_stl</span><span class="p">(</span><span class="n">peptides_table</span><span class="p">,</span> <span class="n">pools</span><span class="p">,</span> <span class="n">engine</span> <span class="o">=</span> <span class="n">ENGINE</span><span class="p">,</span> <span class="n">rows</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="mf">122.10</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="mf">79.97</span><span class="p">,</span> <span class="n">thickness</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">hole_radius</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">x_offset</span> <span class="o">=</span> <span class="mf">9.05</span><span class="p">,</span> <span class="n">y_offset</span> <span class="o">=</span> <span class="mf">6.20</span><span class="p">,</span> <span class="n">well_spacing</span> <span class="o">=</span> <span class="mf">4.5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<p>Now, you need to pass generated dictionary to the function exporting it as a .zip file.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">zip_meshes_export</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">meshes_list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>meshes_list</strong> (<em>dictionary</em>) – dictionary with Mesh objects, generated in previous step</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>export Mesh objects as STL files in .zip archive.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">zip_meshes_export</span><span class="p">(</span><span class="n">meshes_list</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<p>=&gt; You will get a .zip archive with generated STL files. Then, you can send these STL files directly to a 3D printer. Generated masks have small marks at the top representing the index of the pool. Also, you can check generated STL files using any program that can open STL files (for example, OpenSCAD).</p>
</li>
<li><p><strong>To interpret the results, you can use the Bayesian mixture model of activation signal.</strong></p>
<p>Plate notation for the model (for 12 pools and 3 replicas).</p>
<img alt="_images/model_scheme.png" src="_images/model_scheme.png" />
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">activation_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_pools</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg_control</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg_share</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cores</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">model,</span> <span class="pre">fig,</span> <span class="pre">pandas</span> <span class="pre">DataFrame,</span> <span class="pre">list,</span> <span class="pre">InferenceData,</span> <span class="pre">list</span></span></span></dt>
<dd><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fitting might take several minutes.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obs</strong> (<em>list</em>) – list with observed values</p></li>
<li><p><strong>n_pools</strong> (<em>int</em>) – number of pools</p></li>
<li><p><strong>inds</strong> (<em>list</em>) – list with indices for observed values</p></li>
<li><p><strong>neg_control</strong> (<em>list</em><em> or </em><em>None</em>) – optional list with negative control values; if not provided, it is estimated from obs</p></li>
<li><p><strong>neg_share</strong> (<em>float</em><em> or </em><em>None</em>) – expected share of negative pools (between 0 and 1); default is 0.5</p></li>
<li><p><strong>cores</strong> (<em>int</em>) – number of CPU cores to use for MCMC sampling</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ol class="arabic simple">
<li><p>model – PyMC model object used for fitting</p></li>
<li><p>fig – posterior predictive KDE and observed data KDE (ArviZ)</p></li>
<li><p>probs – probability for each pool of being drawn from a distribution of activated or non-activated pools</p></li>
<li><p>neg_control – normalized control values used in model</p></li>
<li><p>idata_alt – full posterior sampling trace (InferenceData object)</p></li>
<li><p>[p_mean, n_mean] – posterior mean of the offset and baseline (negative) component</p></li>
</ol>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>model, figure, pandas DataFrame, list, arviz.InferenceData, list</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">probs</span><span class="p">,</span> <span class="n">neg_control</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="p">[</span><span class="n">p_mean</span><span class="p">,</span> <span class="n">n_mean</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">activation_model</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">inds</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/model_fit.png" src="_images/model_fit.png" />
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">probs</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Pool</p></th>
<th class="head"><p>assign</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0.99900</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1.00000</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>0.00025</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>0.36475</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>0.00025</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>0.00000</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>1.00000</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>1.00000</p></td>
</tr>
<tr class="row-even"><td><p>8</p></td>
<td><p>0.99975</p></td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>0.99975</p></td>
</tr>
<tr class="row-even"><td><p>10</p></td>
<td><p>0.00000</p></td>
</tr>
<tr class="row-odd"><td><p>11</p></td>
<td><p>0.99975</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The <strong>Pool</strong> column contains pool index, and column <strong>assign</strong> the probability of the pools to be drawn from the distribution of non-activated pool. The pool is considered to be activated if assign &lt;= 0.5.</p>
<p>Using this table, you can assess which pools were activated and which were not, and then check the result in check_results table with simulation. However, also you can use the following functions:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">peptide_probabilities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pandas</span> <span class="pre">DataFrame</span></span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sim</strong> (<em>pandas DataFrame</em>) – check_results table with simulation with or without drop-outs</p></li>
<li><p><strong>probs</strong> (<em>pandas DataFrame</em>) – DataFrame with probabilities produced by <a class="reference internal" href="#cpp.activation_model" title="cpp.activation_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.activation_model()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>peptide_probs – probabilitity for each peptide to cause such a pattern of activation</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas DataFrame</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">peptide_probs</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">peptide_probabilities</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">peptide_probs</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 16.7%" />
<col style="width: 16.7%" />
<col style="width: 16.7%" />
<col style="width: 16.7%" />
<col style="width: 16.7%" />
<col style="width: 16.7%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Peptide</p></th>
<th class="head"><p>Address</p></th>
<th class="head"><p>Act Pools</p></th>
<th class="head"><p>Probability</p></th>
<th class="head"><p>Activated</p></th>
<th class="head"><p>Non-Activated</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>MFVFLVLLPLVSSQCVN</p></td>
<td><p>[0, 1, 2, 3]</p></td>
<td><p>[0, 1, 2, 3]</p></td>
<td><p>1.172135e-07</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>MFVFLVLLPLVSSQCVN</p></td>
<td><p>[0, 1, 2, 3]</p></td>
<td><p>[0, 1, 2, 3, 7]</p></td>
<td><p>8.262788e-10</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>VLLPLVSSQCVNLTTRT</p></td>
<td><p>[1, 2, 3, 7]</p></td>
<td><p>[0, 1, 2, 3, 7]</p></td>
<td><p>8.262788e-10</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>VLLPLVSSQCVNLTTRT</p></td>
<td><p>[1, 2, 3, 7]</p></td>
<td><p>[1, 2, 3, 7, 11]</p></td>
<td><p>2.119434e-05</p></td>
<td><p>3</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p>VSSQCVNLTTRTQLPPA</p></td>
<td><p>[2, 3, 7, 11]</p></td>
<td><p>[1, 2, 3, 7, 11]</p></td>
<td><p>2.119434e-05</p></td>
<td><p>3</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-even"><td><p>FDEDDSEPVLKGVKLHY</p></td>
<td><p>[0, 1, 3, 5]</p></td>
<td><p>[0, 1, 2, 3, 4, 5]</p></td>
<td><p>3.259596e-08</p></td>
<td><p>3</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p>FDEDDSEPVLKGVKLHY</p></td>
<td><p>[0, 1, 3, 5]</p></td>
<td><p>[0, 1, 2, 3, 5]</p></td>
<td><p>2.104844e-06</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>DEDDSEPVLKGVKLHYT</p></td>
<td><p>[0, 1, 2, 5]</p></td>
<td><p>[0, 1, 2, 3, 4, 5]</p></td>
<td><p>3.259596e-08</p></td>
<td><p>3</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p>DEDDSEPVLKGVKLHYT</p></td>
<td><p>[0, 1, 2, 5]</p></td>
<td><p>[0, 1, 2, 3, 5]</p></td>
<td><p>2.104844e-06</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>DEDDSEPVLKGVKLHYT</p></td>
<td><p>[0, 1, 2, 5]</p></td>
<td><p>[0, 1, 2, 5]</p></td>
<td><p>7.922877e-09</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<p>And then this table can be used to find cognate peptides:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">results_analysis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">peptide_probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span></span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>peptide_probs</strong> (<em>pandas DataFrame</em>) – DataFrame with probabilities for each peptide produced by <a class="reference internal" href="#cpp.peptide_probabilities" title="cpp.peptide_probabilities"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.peptide_probabilities()</span></code></a></p></li>
<li><p><strong>probs</strong> (<em>pandas DataFrame</em>) – DataFrame with probabilities produced by <a class="reference internal" href="#cpp.activation_model" title="cpp.activation_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.activation_model()</span></code></a></p></li>
<li><p><strong>sim</strong> (<em>pandas DataFrame</em>) – check_results table with simulation with or without drop-outs</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ol class="arabic simple">
<li><p>number of activated pools</p></li>
<li><p>note about detected drop-outs (erroneously non-activated pools);</p></li>
<li><p>list of the most possible peptides;</p></li>
<li><p>list of all possible peptides given this pattern of pools activation.</p></li>
</ol>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, list, list, list</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n_act_pools</span><span class="p">,</span> <span class="n">note</span><span class="p">,</span> <span class="n">most</span><span class="p">,</span> <span class="n">possible</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">peptide_probabilities</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_act_pools</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">note</span>
<span class="go">No drop-outs were detected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">most</span>
<span class="go">[&#39;SSANNCTFEYVSQPFLM&#39;, &#39;CTFEYVSQPFLMDLEGK&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">possible</span>
<span class="go">[&#39;SSANNCTFEYVSQPFLM&#39;, &#39;CTFEYVSQPFLMDLEGK&#39;]</span>
</pre></div>
</div>
</dd></dl>

</li>
<li><p><strong>Plotting results.</strong></p>
<p>Also you plot results using copepodTCR built-in functions.</p>
<p><strong>Bubbleplot</strong>
Each bubble represents one peptide. Its size represents the difference between activated and non-activated pools in the address of a peptide (it this difference is not positive, such a peptide is not shown). X-axis: position of a peptide in protein. Y-axis: its probability.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bubbleplot</span><span class="p">(</span><span class="n">peptide_probs</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/bubble_plot.png" src="_images/bubble_plot.png" />
<p>Or using interactive version of this bubbleplot (with plotly):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">plotly.io</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pio</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pio</span><span class="o">.</span><span class="n">renderers</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="s2">&quot;notebook_connected&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hover_bubbleplot</span><span class="p">(</span><span class="n">peptide_probs</span><span class="p">)</span>
</pre></div>
</div>
<p>Also you make a scatterplot with pools. Each dot is one replicate, with its pool index on X-axis and its log10 percentage of activated T cells on Y-axis. Pools identified by the activation model as activated are plotted green, others pools are gray.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">poolplot</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">most</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/pool_plot.png" src="_images/pool_plot.png" />
</li>
</ol>
</section>
<section id="play-with-the-approach-using-simulated-data-optional">
<span id="simulation-section"></span><h2>Play with the approach using simulated data (Optional)<a class="headerlink" href="#play-with-the-approach-using-simulated-data-optional" title="Link to this heading"></a></h2>
<p>If you want to play with the approach with the generated data, you can use the following pipeline.</p>
<img alt="_images/simulation_pipeline.png" src="_images/simulation_pipeline.png" />
<ol class="arabic">
<li><p><strong>First, you need to determine the parameters for pooling scheme.</strong></p>
<ul class="simple">
<li><p>how many peptides? (len_lst)</p></li>
<li><p>how many pools? (n_pools)</p></li>
<li><p>what is peptide occurrence, i.e. to how many pools one peptide would be added? (iters)</p></li>
<li><p>what would be the length of the peptide? (pep_length)</p></li>
<li><p>what is the length of the shift between two overlapping peptides? (shift)</p></li>
<li><p>what is the length of the expected epitope (ep_length, we recommend 8)</p></li>
</ul>
</li>
<li><p><strong>Then, you can use these parameters to generate peptides. First, you would need to generate a random sequence, and then you could generate peptides using a sliding window approach.</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">codepub</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cdp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copepodTCR</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cpp</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">len_lst</span> <span class="o">=</span> <span class="mi">100</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">n_pools</span> <span class="o">=</span> <span class="mi">12</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">iters</span> <span class="o">=</span> <span class="mi">4</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pep_length</span> <span class="o">=</span> <span class="mi">17</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">shift</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ep_length</span> <span class="o">=</span> <span class="mi">8</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">sequence</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">random_amino_acid_sequence</span><span class="p">(</span><span class="n">shift</span><span class="o">*</span><span class="n">len_lst</span> <span class="o">+</span> <span class="p">(</span><span class="mi">100</span><span class="o">-</span><span class="n">shift</span><span class="o">*</span><span class="n">len_lst</span><span class="o">%</span><span class="mi">100</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sequence</span>
   <span class="s1">&#39;EMKFLDQSQLGYVHPKWHHGTEMDEWSRSNSAYGKHQEATRLCSQWWVKTYMPTDPCWMLRYTNCCAMVPRYADFCMRDYRYAYIYFVNWNHECSDVIMETCCFALGKKLSTPTCTPGCVTVIYECKSEFEVGWPPHIIEGSAEFYAVACFVTRFMCPQTKANLLKIIISFHLHHYGQAEQICYKNEIPCCAMKFFDHREGLESNCLTCMQWPCNKSLFDPFPVMYRFSMAGNQGEPPCGYAVTMNARCTMGRWQKFRCEFKGCFYHNINVYTGCETMHECQIPVPMVHQTTLLYPCNVRSKDIDPCDWSYLEDDKERGWCGKFQMGSQIFRKFTPPPWTNRGWNHMDDTEARHRWCLTWKFTLDEPAEDTCILWIHSVYLWVVCMQGTAMSMRMVSFTLLCFMRAPPCEVMHYCDPQQTRDEELPMVGYITEELKSMFTSSSWPGSQSPGWGTWDLSIKRHSVKVPDMINPTHVVKPTKCICNQSLGWTFSEIDMYARHDIQKRWKCPIWNGQFRYEVIHSKQNPFQNSDEQPT&#39;</span>

<span class="c1">## Then with this sequence you can generate peptides</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lst_all</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">peptide_generation</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">pep_length</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lst</span> <span class="o">=</span> <span class="n">lst_all</span><span class="p">[:</span><span class="n">len_lst</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><strong>Then you can finally generate the pooling scheme.</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">,</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">cdp</span><span class="o">.</span><span class="n">bba</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">n_pools</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">iters</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">len_lst</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pools</span><span class="p">,</span> <span class="n">peptide_address</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">pooling</span><span class="p">(</span><span class="n">lst</span><span class="o">=</span><span class="n">lst</span><span class="p">,</span> <span class="n">addresses</span><span class="o">=</span><span class="n">lines</span><span class="p">,</span> <span class="n">n_pools</span><span class="o">=</span><span class="n">n_pools</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_results</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">run_experiment</span><span class="p">(</span><span class="n">lst</span><span class="o">=</span><span class="n">lst</span><span class="p">,</span> <span class="n">peptide_address</span><span class="o">=</span><span class="n">peptide_address</span><span class="p">,</span> <span class="n">ep_length</span><span class="o">=</span><span class="n">ep_length</span><span class="p">,</span> <span class="n">pools</span><span class="o">=</span><span class="n">pools</span><span class="p">,</span> <span class="n">iters</span><span class="o">=</span><span class="n">iters</span><span class="p">,</span> <span class="n">n_pools</span><span class="o">=</span><span class="n">n_pools</span><span class="p">,</span> <span class="n">regime</span><span class="o">=</span><span class="s1">&#39;without dropouts&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p><strong>Then you need to select a cognate epitope to later check whether the model can recover it. You can do it manually if you particularly like some of them. But also you can do that randomly.</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cognate</span> <span class="o">=</span> <span class="n">check_results</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="s1">&#39;Epitope&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_results</span><span class="p">[</span><span class="s1">&#39;Cognate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_results</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">check_results</span><span class="p">[</span><span class="s1">&#39;Epitope&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cognate</span><span class="p">,</span> <span class="s1">&#39;Cognate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">check_results</span><span class="p">[</span><span class="s1">&#39;Peptide&#39;</span><span class="p">][</span><span class="n">check_results</span><span class="p">[</span><span class="s1">&#39;Epitope&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cognate</span><span class="p">])))</span>
<span class="go">[&#39;YCNQNWDWDMCEVVCGR&#39;, &#39;WDWDMCEVVCGRDFCHC&#39;]</span>
</pre></div>
</div>
<p>Also, you would need to find the pools which would be activated given this epitope is cognate.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">inds_p_check</span> <span class="o">=</span> <span class="n">check_results</span><span class="p">[</span><span class="n">check_results</span><span class="p">[</span><span class="s1">&#39;Cognate&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">][</span><span class="s1">&#39;Act Pools&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">inds_p_check</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inds_p_check</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inds_n_check</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pools</span><span class="p">):</span>
<span class="go">      if item not in inds_p_check:</span>
<span class="go">         inds_n_check.append(item)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">inds_p_check</span><span class="p">)</span>
<span class="go">[5, 6, 9, 10, 11]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">inds_n_check</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4, 7, 8]</span>
</pre></div>
</div>
</li>
<li><p><strong>Then you can simulate activation signal. For that, you would need to determine paratemers of the model.</strong></p>
<p>Plate notation for the simulation model:</p>
<img alt="_images/model_simulation.png" src="_images/model_simulation.png" />
<ul class="simple">
<li><p>mu_n - mu of the negative distribution (distribution of signal of non-activated pools), ranges from 0 to 100.</p></li>
<li><p>sigma_n - sigma of the negative distribution, ranges from 0 to 100.</p></li>
<li><p>mu_off - mu of the offset which will be used to obtain positive distribution (distribution of signal of activated pools) from the negative distribution, ranges from 0 to 100.</p></li>
<li><p>sigma_off - sigma of the offset which will be used to obtain positive distribution, ranges from 0 to 100.</p></li>
<li><p>r - number of replicas in the experiment</p></li>
<li><p>sigma_p_r - variance between replicas from positive distribution, ranges between 0 to 100.</p></li>
<li><p>sigma_n_r - variance between replicas from negative distribution, ranges between 0 to 100.</p></li>
<li><p>n_pools - number of pools</p></li>
<li><p>p_shape - number of activated pools in simulation, you can make it equal to the number of pools where cognate epitope is present, or you can make more / fewer to see how the algorithm responds to mistakes.</p></li>
<li><p>pl_shape - number of slightly activated pools in simulation corresponding to context-dependent activation. For simplicity, we recommend setting it to 0.</p></li>
<li><p>low_offset - the degree to which activation is decreased in pools from pl_shape, ranges from 0 to 1. We recommend setting it to 1, then it will not be applied.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mu_off</span> <span class="o">=</span> <span class="mi">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma_off</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mu_n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma_n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma_p_r</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigma_n_r</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_pools</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_shape</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds_p_check</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pl_shape</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">low_offset</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p_results</span><span class="p">,</span> <span class="n">pl_results</span><span class="p">,</span> <span class="n">n_results</span><span class="p">,</span> <span class="n">n_control</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">simulation</span><span class="p">(</span><span class="n">mu_off</span><span class="p">,</span> <span class="n">sigma_off</span><span class="p">,</span> <span class="n">mu_n</span><span class="p">,</span> <span class="n">sigma_n</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">sigma_p_r</span><span class="p">,</span> <span class="n">sigma_n_r</span><span class="p">,</span> <span class="n">n_pools</span><span class="p">,</span> <span class="n">p_shape</span><span class="p">,</span> <span class="n">pl_shape</span><span class="p">,</span> <span class="n">low_offset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cells</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Pool&#39;</span><span class="p">,</span> <span class="s1">&#39;Percentage&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;Percentage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_results</span> <span class="o">+</span> <span class="n">n_results</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;Pool&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inds_p_check</span><span class="o">*</span><span class="n">r</span> <span class="o">+</span> <span class="n">inds_n_check</span><span class="o">*</span><span class="n">r</span>
</pre></div>
</div>
<p>Cells is a DataFrame with the simulated data:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cells</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Pool</p></th>
<th class="head"><p>Percentage</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>5</p></td>
<td><p>14.554757</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>14.818329</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>14.846125</p></td>
</tr>
<tr class="row-odd"><td><p>10</p></td>
<td><p>14.536968</p></td>
</tr>
<tr class="row-even"><td><p>11</p></td>
<td><p>15.311202</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>4.544784</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>4.422958</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>4.514103</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>4.458392</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>4.575509</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>5.791510</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>5.334201</p></td>
</tr>
</tbody>
</table>
</li>
<li><p><strong>Then you can use this table to check the algorithm.</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;Pool&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cells</span><span class="p">[</span><span class="s1">&#39;Percentage&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">probs</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">activation_model</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">n_pools</span><span class="p">,</span> <span class="n">inds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peptide_probs</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">peptide_probabilities</span><span class="p">(</span><span class="n">check_results</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_act_pools</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">most</span><span class="p">,</span> <span class="n">possible</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">results_analysis</span><span class="p">(</span><span class="n">peptide_probs</span><span class="p">,</span> <span class="n">probs</span><span class="p">,</span> <span class="n">check_results</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_act_pools</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">message</span>
<span class="go">&#39;No drop-outs were detected&#39;,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">most</span>
<span class="go">[&#39;YCNQNWDWDMCEVVCGR&#39;, &#39;WDWDMCEVVCGRDFCHC&#39;]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="go">[&#39;YCNQNWDWDMCEVVCGR&#39;, &#39;WDWDMCEVVCGRDFCHC&#39;]</span>
</pre></div>
</div>
<p>Now you can compare recovered cognate peptides with ones you chose:</p>
<ul class="simple">
<li><p>[‘YCNQNWDWDMCEVVCGR’, ‘WDWDMCEVVCGRDFCHC’] - you chose</p></li>
<li><p>[‘YCNQNWDWDMCEVVCGR’, ‘WDWDMCEVVCGRDFCHC’] - were recovered by the model from the simulated activation data</p></li>
</ul>
</li>
<li><p><strong>Also you can plot this data using built-in plotting functions.</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bubbleplot</span><span class="p">(</span><span class="n">peptide_probs</span><span class="p">)</span>
</pre></div>
</div>
<p>Or using plotly to make interactive bubbleplot:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">plotly.io</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pio</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pio</span><span class="o">.</span><span class="n">renderers</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="s2">&quot;notebook_connected&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hover_bubbleplot</span><span class="p">(</span><span class="n">peptide_probs</span><span class="p">)</span>
</pre></div>
</div>
<p>Also you make a scatterplot with pools:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">poolplot</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">most</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p><strong>You can play with different parameters to check how well the approach works.</strong></p>
<p>For example, you can decrease the offset for the positive distribution, to check how different should be activated and non-activated pools to yield correct results.</p>
</li>
</ol>
</section>
</section>
<section id="function-reference">
<h1>Function reference<a class="headerlink" href="#function-reference" title="Link to this heading"></a></h1>
<section id="peptide-occurrence-search">
<span id="occurrence-section"></span><h2>Peptide occurrence search<a class="headerlink" href="#peptide-occurrence-search" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="cpp.factorial">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">factorial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#cpp.factorial" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num</strong> – number</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>factorial of the num</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">3628800</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.combination">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">combination</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#cpp.combination" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – set length</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>how many items are selected from the set</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">combination</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">120</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.find_possible_k_values">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">find_possible_k_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#cpp.find_possible_k_values" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – number of pools</p></li>
<li><p><strong>l</strong> (<em>int</em>) – number of peptides</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list with possible peptide occurrences given number of pools and number of peptides.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Counter object, dictionary</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">find_possible_k_values</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">250</span><span class="p">)</span>
<span class="go">[4, 5, 6, 7, 8]</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="peptides-generation-and-assessment">
<span id="peptide-section"></span><h2>Peptides generation and assessment<a class="headerlink" href="#peptides-generation-and-assessment" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="cpp.peptide_generation">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">peptide_generation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protein</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peptide_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peptide_shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protein_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#cpp.peptide_generation" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>protein</strong> (<em>str</em><em> or </em><em>list</em><em> of </em><em>str</em>) – a single protein sequence (string) or a list of protein sequences</p></li>
<li><p><strong>peptide_length</strong> (<em>int</em>) – length of each generated peptide</p></li>
<li><p><strong>peptide_shift</strong> (<em>int</em>) – number of positions to shift between consecutive peptides (i.e., peptide_length - overlap)</p></li>
<li><p><strong>protein_end</strong> (<em>bool</em><em>, </em><em>default is False</em>) – whether to include trailing peptide if protein ends with a short fragment</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of generated peptide sequences</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of str</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">peptides</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">peptide_generation</span><span class="p">(</span><span class="s2">&quot;MKWVTFISLLFLFSSAYSRGVFRRDTHKSEIAHRFKDLGE&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peptides</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">[&#39;MKWVTFISL&#39;, &#39;TFISLLFLF&#39;, &#39;LLFLFSSAY&#39;]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>If the input is a list of proteins, the peptides will be generated for each individually and concatenated.</p></li>
<li><p>If protein_end is True, peptides near the C-terminus will be padded by upstream sequence if shorter than expected.</p></li>
</ul>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.string_overlap">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">string_overlap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">str1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">str2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#cpp.string_overlap" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>str1</strong> (<em>string</em>) – peptide</p></li>
<li><p><strong>str2</strong> (<em>string</em>) – peptide</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>overlap length between two peptides</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">string_overlap</span><span class="p">(</span><span class="s1">&#39;ASDFGHJKTYUIO&#39;</span><span class="p">,</span> <span class="s1">&#39;GHJKTYUIOTYUI&#39;</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.find_pair_with_overlap">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">find_pair_with_overlap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_overlap</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#cpp.find_pair_with_overlap" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lst</strong> (<em>list</em>) – ordered list of peptides</p></li>
<li><p><strong>target_overlap</strong> (<em>int</em>) – overlap length</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of lists with peptides with specified overlap length.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">find_pair_with_overlap</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="go">[[&#39;FDEDDSEPVLKGVKLHY&#39;, &#39;DEDDSEPVLKGVKLHYT&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.how_many_peptides">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">how_many_peptides</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ep_length</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Counter</span> <span class="pre">object,</span> <span class="pre">dictionary</span></span></span><a class="headerlink" href="#cpp.how_many_peptides" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lst</strong> (<em>list</em>) – ordered list of peptides</p></li>
<li><p><strong>ep_length</strong> (<em>int</em>) – expected epitope length</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ol class="arabic simple">
<li><p>the Counter object with the number of epitopes shared across the number of peptides;</p></li>
<li><p>the dictionary with all possible epitopes of expected length as keys and the number of peptides where these epitopes are present as values.</p></li>
</ol>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Counter object, dictionary</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">how_many_peptides</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span>
<span class="go">Counter({1: 6, 2: 1256, 3: 4})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span>
<span class="go">{&#39;MFVFLVLL&#39;: 1,&#39;FVFLVLLP&#39;: 1,VFLVLLPL&#39;: 1,&#39;FLVLLPLV&#39;: 1,&#39;LVLLPLVS&#39;: 1,&#39;VLLPLVSS&#39;: 2, ...,}</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="pooling">
<span id="pooling-section"></span><h2>Pooling<a class="headerlink" href="#pooling" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="cpp.bad_address_predictor">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">bad_address_predictor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">all_ns</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#cpp.bad_address_predictor" title="Link to this definition"></a></dt>
<dd><div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Keep in mind that produced arrangement might be imbalanced.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>all_ns</strong> (<em>list</em>) – address arrangement</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>address arrangement without addresses with the same unions. The function searches for three consecutive addresses with the same union and removes the middle one.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">bad_address_predictor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="go">[[0, 1, 2, 3], [0, 1, 2, 4], [0, 1, 2, 5], [0, 1, 2, 6], [0, 1, 3, 6], [0, 1, 3, 5], [0, 1, 3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.pooling">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">pooling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">addresses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_pools</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dictionary</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dictionary</span></span></span><a class="headerlink" href="#cpp.pooling" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lst</strong> (<em>list</em>) – ordered list with peptides</p></li>
<li><p><strong>addresses</strong> (<em>list</em>) – produced address arrangement</p></li>
<li><p><strong>n_pools</strong> (<em>int</em>) – number of pools</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ol class="arabic simple">
<li><p>pools – dictionary with keys as pools indices and values as peptides that should be added to this pools;</p></li>
<li><p>peptide address – dictionary with peptides as keys and corresponding addresses as values.</p></li>
</ol>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary, dictionary</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pools</span><span class="p">,</span> <span class="n">peptide_address</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">pooling</span><span class="p">(</span><span class="n">lst</span><span class="o">=</span><span class="n">lst</span><span class="p">,</span> <span class="n">addresses</span><span class="o">=</span><span class="n">lines</span><span class="p">,</span> <span class="n">n_pools</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pools</span>
<span class="go">{0: [&#39;MFVFLVLLPLVSSQCVN&#39;,&#39;VLLPLVSSQCVNLTTRT&#39;,VSSQCVNLTTRTQLPPA&#39;, ...], 1: [&#39;MFVFLVLLPLVSSQCVN&#39;,&#39;VLLPLVSSQCVNLTTRT&#39;,&#39;TQDLFLPFFSNVTWFHA&#39;, ...], ... }</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peptide_address</span>
<span class="go">{&#39;MFVFLVLLPLVSSQCVN&#39;: [0, 1, 2, 3], &#39;VLLPLVSSQCVNLTTRT&#39;: [0, 1, 2, 10], ... }</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.pools_activation">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">pools_activation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pools</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epitope</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#cpp.pools_activation" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pools</strong> (<em>dictionary</em>) – pools, produced by <a class="reference internal" href="#cpp.pooling" title="cpp.pooling"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.pooling()</span></code></a></p></li>
<li><p><strong>epitope</strong> (<em>string</em>) – epitope present in one or several tested peptides</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>pool indices where the epitope is present</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">pools_activation</span><span class="p">(</span><span class="n">pools</span><span class="p">,</span> <span class="s1">&#39;LGVYYHKN&#39;</span><span class="p">)</span>
<span class="go">[0, 3, 8, 9, 11]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.epitope_pools_activation">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">epitope_pools_activation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">peptide_address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ep_length</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dictionary</span></span></span><a class="headerlink" href="#cpp.epitope_pools_activation" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>peptide_address</strong> (<em>dictionary</em>) – peptide addresses, produced by <a class="reference internal" href="#cpp.pooling" title="cpp.pooling"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.pooling()</span></code></a></p></li>
<li><p><strong>lst</strong> (<em>list</em>) – ordered list of peptides</p></li>
<li><p><strong>ep_length</strong> (<em>ep</em>) – expected epitope length</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>activated pools for every possible epitope of expected length from entered peptides</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">epitope_pools_activation</span><span class="p">(</span><span class="n">peptide_address</span><span class="p">,</span> <span class="n">lst</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">{&#39;[0, 1, 2, 3]&#39;: [&#39;MFVFLVLL&#39;, &#39;FVFLVLLP&#39;, &#39;VFLVLLPL&#39;, &#39;FLVLLPLV&#39;, &#39;LVLLPLVS&#39;], &#39;[0, 1, 2, 3, 9]&#39;: [&#39;VLLPLVSS&#39;, &#39;LLPLVSSQ&#39;, &#39;LPLVSSQC&#39;, &#39;PLVSSQCV&#39;, &#39;LVSSQCVN&#39;], &#39;[0, 1, 3, 9, 11]&#39;: [&#39;VSSQCVNL&#39;, &#39;SSQCVNLT&#39;, ...], ... }</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.peptide_search">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">peptide_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">act_pools</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_pools</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regime</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span></span></span><a class="headerlink" href="#cpp.peptide_search" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lst</strong> (<em>list</em>) – ordered list of peptides</p></li>
<li><p><strong>act_profile</strong> (<em>dictionary</em>) – activated pools for every possible epitope of expected length from entered peptides, produced by <a class="reference internal" href="#cpp.epitope_pools_activation" title="cpp.epitope_pools_activation"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.epitope_pools_activation()</span></code></a></p></li>
<li><p><strong>act_pools</strong> (<em>list</em>) – activated pools</p></li>
<li><p><strong>iters</strong> (<em>int</em>) – peptide occurrence</p></li>
<li><p><strong>n_pools</strong> (<em>int</em>) – number of pools</p></li>
<li><p><strong>regime</strong> (<em>&quot;with dropouts&quot;</em><em> or </em><em>&quot;without dropouts&quot;</em>) – regime of simulation, with or without drop-outs</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>possible peptides and possible epitopes given such activated pools</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">peptide_search</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">act_profile</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="s1">&#39;without dropouts&#39;</span><span class="p">)</span>
<span class="go">([&#39;CNDPFLGVYYHKNNKSW&#39;, &#39;LGVYYHKNNKSWMESEF&#39;], [&#39;LGVYYHKN&#39;, &#39;GVYYHKNN&#39;, &#39;VYYHKNNK&#39;, &#39;YYHKNNKS&#39;, &#39;YHKNNKSW&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">peptide_search</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">act_profile</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span> <span class="n">iters</span><span class="p">,</span> <span class="n">n_pools</span><span class="p">,</span> <span class="s1">&#39;with dropouts&#39;</span><span class="p">)</span>
<span class="go">([&#39;CNDPFLGVYYHKNNKSW&#39;, &#39;LLKYNENGTITDAVDCA&#39;, &#39;LGVYYHKNNKSWMESEF&#39;, &#39;QPRTFLLKYNENGTITD&#39;], [&#39;YNENGTIT&#39;, &#39;LKYNENGT&#39;, &#39;YHKNNKSW&#39;, &#39;KYNENGTI&#39;, &#39;YYHKNNKS&#39;, &#39;LGVYYHKN&#39;, &#39;VYYHKNNK&#39;, &#39;NENGTITD&#39;, &#39;LLKYNENG&#39;, &#39;GVYYHKNN&#39;])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.run_experiment">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">run_experiment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">peptide_address</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ep_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pools</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_pools</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">regime</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pandas</span> <span class="pre">DataFrame</span></span></span><a class="headerlink" href="#cpp.run_experiment" title="Link to this definition"></a></dt>
<dd><blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Simulation may take several minutes, especially upon “with drop-outs” regime.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">param lst<span class="colon">:</span></dt>
<dd class="field-odd"><p>ordered list with peptides</p>
</dd>
<dt class="field-even">type lst<span class="colon">:</span></dt>
<dd class="field-even"><p>list</p>
</dd>
<dt class="field-odd">param peptide_address<span class="colon">:</span></dt>
<dd class="field-odd"><p>peptides addresses produced by pooling</p>
</dd>
<dt class="field-even">type peptide_address<span class="colon">:</span></dt>
<dd class="field-even"><p>dictionary</p>
</dd>
<dt class="field-odd">param ep_length<span class="colon">:</span></dt>
<dd class="field-odd"><p>expected epitope length</p>
</dd>
<dt class="field-even">type ep_length<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
<dt class="field-odd">param pools<span class="colon">:</span></dt>
<dd class="field-odd"><p>pools produced by pooling</p>
</dd>
<dt class="field-even">type pools<span class="colon">:</span></dt>
<dd class="field-even"><p>dictionary</p>
</dd>
<dt class="field-odd">param iters<span class="colon">:</span></dt>
<dd class="field-odd"><p>peptide occurrence</p>
</dd>
<dt class="field-even">type iters<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
<dt class="field-odd">param n_pools<span class="colon">:</span></dt>
<dd class="field-odd"><p>number of pools</p>
</dd>
<dt class="field-even">type n_pools<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
<dt class="field-odd">param regime<span class="colon">:</span></dt>
<dd class="field-odd"><p>regime of simulation, with or without drop-outs</p>
</dd>
<dt class="field-even">type regime<span class="colon">:</span></dt>
<dd class="field-even"><p>“with dropouts” or “without dropouts”</p>
</dd>
<dt class="field-odd">return<span class="colon">:</span></dt>
<dd class="field-odd"><ol class="arabic simple">
<li><p>pools – dictionary with keys as pools indices and values as peptides that should be added to this pools;</p></li>
<li><p>peptide address – dictionary with peptides as keys and corresponding addresses as values.</p></li>
</ol>
</dd>
<dt class="field-even">rtype<span class="colon">:</span></dt>
<dd class="field-even"><p>dictionary, dictionary</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">run_experiment</span><span class="p">(</span><span class="n">lst</span><span class="o">=</span><span class="n">lst</span><span class="p">,</span> <span class="n">peptide_address</span><span class="o">=</span><span class="n">peptide_address</span><span class="p">,</span> <span class="n">ep_length</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">pools</span><span class="o">=</span><span class="n">pools</span><span class="p">,</span> <span class="n">iters</span><span class="o">=</span><span class="n">iters</span><span class="p">,</span> <span class="n">n_pools</span><span class="o">=</span><span class="n">n_pools</span><span class="p">,</span> <span class="n">regime</span><span class="o">=</span><span class="s1">&#39;without dropouts&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>This table can be used to interpret results of the experiment without using Bayesian mixture model.</p>
<p>You need to find all rows where the “Act Pools” column contains your combination of activated pools. Then, you will know all possible peptides and epitopes that could lead to the activation of such a combination of pools.</p>
<p>If you can not find your combination of activated pools in the table, here is the sequence of actions.</p>
<p>After the experiment, you will know the number of activated pools. This number depends on the length of overlap and the length of the expected epitope. You can check the distribution of epitope presence in your peptides using <a class="reference internal" href="#cpp.how_many_peptides" title="cpp.how_many_peptides"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.how_many_peptides()</span></code></a> function. The number of activated pools would be equal to peptide occurrence plus one per additional peptide sharing this epitope.</p>
<p>This way, if the epitope is present only in 1 peptide (usually, it is the case for epitopes at the ends of the protein), then the number of activated pools is equal to peptide occurrence. If the epitope is present in two peptides, then the number of activated pools is equal to peptide occurrence +1.</p>
<p>If overlap length is consistent across all peptides, then the number of activated pools would be the same for almost all epitopes (except for the epitopes at the ends of the protein). Although even if the overlap is inconsistent, you can use the analysis, but it will hinder the interpretation of the results in some cases.</p>
<p>If a shift length between two peptides is equal to or less than the expected epitope length divided by two, then the number of activated pools should be equal to the peptide occurrence value + 1.</p>
<p>If the number of activated pools is less than according to the rule described above, then three options are possible:</p>
<ul class="simple">
<li><p>The target peptide is the peptide at the end of your peptide list, and the target epitope is located not in an overlap of this peptide with the next one. This could be checked easily: if your activated pools are not the same as the activated pools for any epitope from the first or last peptide, then you should check our second option.</p></li>
<li><p>For the target peptide, overlap with its neighbor is less than usual, and therefore target epitope is not shared by the usual number of peptides. You can check that using <code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.all_overlaps()</span></code> or <a class="reference internal" href="#cpp.how_many_peptides" title="cpp.how_many_peptides"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.how_many_peptides()</span></code></a>. Nevertheless, given the absence of drop-outs, you still should be able to find the target peptide in the table with simulation results by searching for all rows where the “Act Pools” column contains your combination of activated pools.</p></li>
<li><p>Some pools were not activated, although they should be; then, we recommend using the “with drop-outs” regime of the simulation. It imitates drop-outs of all possible pools, so you should be able to find your case in the resulting table.</p></li>
</ul>
<p>If the number of activated pools is higher than according to the rule described above, then two options are possible:</p>
<ul class="simple">
<li><p>For the target peptide, overlap with its neighbor is bigger than usual, and therefore target epitope is shared between more peptides. You can check that using <code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.all_overlaps()</span></code> or <a class="reference internal" href="#cpp.how_many_peptides" title="cpp.how_many_peptides"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.how_many_peptides()</span></code></a>. Nevertheless, given the absence of drop-outs, you still should be able to find the target peptide in the table with simulation results by searching for all rows where the “Act Pools” column contains your combination of activated pools.</p></li>
<li><p>Some pools were activated, although they should not be. This issue is not addressed in the package.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">run_experiment</span><span class="p">(</span><span class="n">lst</span><span class="o">=</span><span class="n">lst</span><span class="p">,</span> <span class="n">peptide_address</span><span class="o">=</span><span class="n">peptide_address</span><span class="p">,</span> <span class="n">ep_length</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">pools</span><span class="o">=</span><span class="n">pools</span><span class="p">,</span> <span class="n">iters</span><span class="o">=</span><span class="n">iters</span><span class="p">,</span> <span class="n">n_pools</span><span class="o">=</span><span class="n">n_pools</span><span class="p">,</span> <span class="n">regime</span><span class="o">=</span><span class="s1">&#39;with dropouts&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
<col style="width: 9.1%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Peptide</p></th>
<th class="head"><p>Address</p></th>
<th class="head"><p>Epitope</p></th>
<th class="head"><p>Act Pools</p></th>
<th class="head"><p># of pools</p></th>
<th class="head"><p># of epitopes</p></th>
<th class="head"><p># of peptides</p></th>
<th class="head"><p>Remained</p></th>
<th class="head"><p># of lost</p></th>
<th class="head"><p>Right peptide</p></th>
<th class="head"><p>Right epitope</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>MFVFLVLLPLVSSQCVN</p></td>
<td><p>[0, 1, 2, 3]</p></td>
<td><p>MFVFLVLL</p></td>
<td><p>[0, 1, 2, 3]</p></td>
<td><p>4</p></td>
<td><p>40</p></td>
<td><p>12</p></td>
<td><p>[0, 1, 2]</p></td>
<td><p>1</p></td>
<td><p>True</p></td>
<td><p>False</p></td>
</tr>
<tr class="row-odd"><td><p>MFVFLVLLPLVSSQCVN</p></td>
<td><p>[0, 1, 2, 3]</p></td>
<td><p>MFVFLVLL</p></td>
<td><p>[0, 1, 2, 3]</p></td>
<td><p>4</p></td>
<td><p>76</p></td>
<td><p>25</p></td>
<td><p>[0, 1, 3]</p></td>
<td><p>1</p></td>
<td><p>True</p></td>
<td><p>False</p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>RTQLPPAYTNSFTRGVY</p></td>
<td><p>[8, 9, 10, 11]</p></td>
<td><p>RTQLPPAY</p></td>
<td><p>[0, 8, 9, 10, 11]</p></td>
<td><p>5</p></td>
<td><p>5</p></td>
<td><p>2</p></td>
<td><p>[0, 8, 9, 10, 11]</p></td>
<td><p>0</p></td>
<td><p>True</p></td>
<td><p>True</p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>RTQLPPAYTNSFTRGVY</p></td>
<td><p>[8, 9, 10, 11]</p></td>
<td><p>TQLPPAYT</p></td>
<td><p>[0, 8, 9, 10, 11]</p></td>
<td><p>5</p></td>
<td><p>190</p></td>
<td><p>53</p></td>
<td><p>[8, 9]</p></td>
<td><p>3</p></td>
<td><p>True</p></td>
<td><p>True</p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Peptide</strong> — peptide sequence</p>
<p><strong>Address</strong> — pool indices where this peptide should be added</p>
<p><strong>Epitope</strong> — checked epitope from this peptide</p>
<p><strong>Act pools</strong> — list with pool indices where this epitope is present</p>
<p><strong># of pools</strong> — number of pools where this epitope is present</p>
<p><strong># of epitopes</strong> — number of epitopes that are present in the same pools
(= number of possible peptides upon activation of such pools)</p>
<p><strong># of peptides</strong> — number of peptides in which there are epitopes that
are present in the same pools (= number of possible peptides upon
activation of such pools)</p>
<p><strong>Remained</strong> — only upon regime=”with dropouts”, list of pools remained
after mistake</p>
<p><strong># of lost</strong> — only upon regime=”with dropouts”, number of dropped pools
due to mistake</p>
<p><strong>Right peptide</strong> — True or False, whether the peptide is present in the list
of possible peptides</p>
<p><strong>Right epitope</strong> — True or False, whether the peptide is present in the list
of possible peptides</p>
<p><strong>Right peptide</strong> and <strong>Right epitope</strong> columns are needed to check the
algorithm of dropped pool recovery. Either “Right peptide” or “Right
epitope” should contain the value “True”; otherwise, recovery was
unsuccessful.</p>
<p>Also, the regime “with drop-outs” can not differentiate between
dropped pools due to a mistake and absent pools due to experiment
design. This way, for epitopes located at the end of proteins, the
algorithm would think that pools were dropped and would try to
recover them. Because of that, if you suspect the epitope located at
the end of the peptide to be the target epitope, we recommend first
using the “without drop-outs” regime. You can look at the sequence of
actions described above. The same applies to peptides with longer
overlap. So, we strongly recommend using peptides with consistent
overlap length.</p>
</dd></dl>

</section>
<section id="d-models">
<span id="d-section"></span><h2>3D models<a class="headerlink" href="#d-models" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="cpp.pick_engine">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">pick_engine</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#cpp.pick_engine" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>available engine for trimesh.boolean operations, “manifold” or “blender”</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>str or error</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">pick_engine</span><span class="p">()</span>
<span class="go">manifold</span>
</pre></div>
</div>
<p>If manifold is not available, cpp.pick_engine() will check availability of Blender and raise an error if it is not available:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">pick_engine</span><span class="p">()</span>
<span class="go">&quot;No boolean backend available. Install manifold3d or Blender.&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.stl_generator">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">stl_generator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rows</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thickness</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hole_radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">well_spacing</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">engine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marks</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Mesh</span> <span class="pre">object</span></span></span><a class="headerlink" href="#cpp.stl_generator" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rows</strong> (<em>int</em>) – int</p></li>
<li><p><strong>cols</strong> (<em>int</em>) – number of columns in your plate with peptides</p></li>
<li><p><strong>length</strong> (<em>float</em>) – length of the plate in mm</p></li>
<li><p><strong>width</strong> (<em>float</em>) – width of the plate in mm</p></li>
<li><p><strong>thickness</strong> (<em>float</em>) – desired thickness of the mask, in mm</p></li>
<li><p><strong>hole_radius</strong> (<em>float</em>) – the radius of the holes, in mm, should be adjusted to fit your tip</p></li>
<li><p><strong>x_offset</strong> (<em>float</em>) – the margin along the X axis for the A1 hole, in mm</p></li>
<li><p><strong>y_offset</strong> (<em>float</em>) – the margin along the Y axis for the A1 hole, in mm</p></li>
<li><p><strong>well_spacing</strong> (<em>float</em>) – the distance between wells, in mm</p></li>
<li><p><strong>coordinates</strong> (<em>list</em>) – coordinates of holes, in tuples in list</p></li>
<li><p><strong>engine</strong> (<em>str</em>) – engine for trimesh.boolean.union() and trimesh.difference(), “manifold”</p></li>
<li><p><strong>marks</strong> – whether marks to indicate pool index will be added to the plate</p></li>
<li><p><strong>marks</strong> – int or Boolean</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>masks with holes based in entered coordinates</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Mesh object</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">stl_generator</span><span class="p">(</span><span class="n">rows</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="mf">122.10</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="mf">79.97</span><span class="p">,</span> <span class="n">thickness</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">hole_radius</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x_offset</span> <span class="o">=</span> <span class="mf">9.05</span><span class="p">,</span> <span class="n">y_offset</span> <span class="o">=</span> <span class="mf">6.20</span><span class="p">,</span> <span class="n">well_spacing</span> <span class="o">=</span> <span class="mf">4.5</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="go">Mesh object</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.pools_stl">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">pools_stl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">peptides_table</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pools</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">engine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">24</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">122.10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">79.97</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thickness</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hole_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.0</span> <span class="pre">/</span> <span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">9.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">well_spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.5</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dictionary</span></span></span><a class="headerlink" href="#cpp.pools_stl" title="Link to this definition"></a></dt>
<dd><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rendering of 3D models might take some time.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>peptides_table</strong> (<em>pandas DataFrame</em>) – table representing the arrangement of peptides in a plate, is not produced by any function in the package</p></li>
<li><p><strong>pools</strong> (<em>pandas DataFrame</em>) – table with a pooling scheme, where one row represents each pool, pool index is the index column, and a string with all peptides added to this pool separated by “;” is “Peptides” column.</p></li>
<li><p><strong>engine</strong> (<em>str</em>) – engine for trimesh.boolean.union() and trimesh.difference(), “manifold”</p></li>
<li><p><strong>rows</strong> (<em>int</em>) – int</p></li>
<li><p><strong>cols</strong> (<em>int</em>) – number of columns in your plate with peptides</p></li>
<li><p><strong>length</strong> (<em>float</em>) – length of the plate in mm</p></li>
<li><p><strong>width</strong> (<em>float</em>) – width of the plate in mm</p></li>
<li><p><strong>thickness</strong> (<em>float</em>) – desired thickness of the mask, in mm</p></li>
<li><p><strong>hole_radius</strong> (<em>float</em>) – the radius of the holes, in mm, should be adjusted to fit your tip</p></li>
<li><p><strong>x_offset</strong> (<em>float</em>) – the margin along the X axis for the A1 hole, in mm</p></li>
<li><p><strong>y_offset</strong> (<em>float</em>) – the margin along the Y axis for the A1 hole, in mm</p></li>
<li><p><strong>well_spacing</strong> (<em>float</em>) – the distance between wells, in mm</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>dictionary with Mesh objects, where key is pool index, and value is a Mesh object of a corresponding mask</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dictionary</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">meshes_list</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">pools_stl</span><span class="p">(</span><span class="n">peptides_table</span><span class="p">,</span> <span class="n">pools</span><span class="p">,</span> <span class="n">engine</span> <span class="o">=</span> <span class="n">ENGINE</span><span class="p">,</span> <span class="n">rows</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="mf">122.10</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="mf">79.97</span><span class="p">,</span> <span class="n">thickness</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">hole_radius</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">x_offset</span> <span class="o">=</span> <span class="mf">9.05</span><span class="p">,</span> <span class="n">y_offset</span> <span class="o">=</span> <span class="mf">6.20</span><span class="p">,</span> <span class="n">well_spacing</span> <span class="o">=</span> <span class="mf">4.5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.zip_meshes_export">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">zip_meshes_export</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">meshes_list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#cpp.zip_meshes_export" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>meshes_list</strong> (<em>dictionary</em>) – dictionary with Mesh objects, generated by <a class="reference internal" href="#cpp.pools_stl" title="cpp.pools_stl"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.pools_stl()</span></code></a></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>export Mesh objects as STL files in .zip archive.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">zip_meshes_export</span><span class="p">(</span><span class="n">meshes_list</span><span class="p">)</span>
</pre></div>
</div>
<p>Generated STL file you can check using OpenSCAD or any other program that can open STL files:</p>
<a class="reference internal image-reference" href="_images/pools_stl.png"><img alt="_images/pools_stl.png" src="_images/pools_stl.png" style="width: 400px; height: 200px;" />
</a>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.zip_meshes">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">zip_meshes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">meshes_list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">BytesIO</span> <span class="pre">object</span></span></span><a class="headerlink" href="#cpp.zip_meshes" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>meshes_list</strong> (<em>dictionary</em>) – dictionary with Mesh objects, generated by <a class="reference internal" href="#cpp.pools_stl" title="cpp.pools_stl"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.pools_stl()</span></code></a></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>zip archive with generated STL files in BytesIO format (suitable for emails)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>BytesIO</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">zip_meshes</span><span class="p">(</span><span class="n">meshes_list</span><span class="p">)</span>
<span class="go">&lt;_io.BytesIO at 0x1d42a1440&gt;</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="results-interpretation-with-a-bayesian-mixture-model">
<span id="interpretation"></span><h2>Results interpretation with a Bayesian mixture model<a class="headerlink" href="#results-interpretation-with-a-bayesian-mixture-model" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="cpp.activation_model">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">activation_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_pools</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg_control</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neg_share</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cores</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">model,</span> <span class="pre">fig,</span> <span class="pre">pandas</span> <span class="pre">DataFrame,</span> <span class="pre">list,</span> <span class="pre">InferenceData,</span> <span class="pre">list</span></span></span><a class="headerlink" href="#cpp.activation_model" title="Link to this definition"></a></dt>
<dd><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fitting might take several minutes.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obs</strong> (<em>list</em>) – list with observed values</p></li>
<li><p><strong>n_pools</strong> (<em>int</em>) – number of pools</p></li>
<li><p><strong>inds</strong> (<em>list</em>) – list with indices for observed values</p></li>
<li><p><strong>neg_control</strong> (<em>list</em><em> or </em><em>None</em>) – optional list with negative control values; if not provided, it is estimated from obs</p></li>
<li><p><strong>neg_share</strong> (<em>float</em><em> or </em><em>None</em>) – expected share of negative pools (between 0 and 1); default is 0.5</p></li>
<li><p><strong>cores</strong> (<em>int</em>) – number of CPU cores to use for MCMC sampling</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ol class="arabic simple">
<li><p>model – PyMC model object used for fitting</p></li>
<li><p>fig – posterior predictive KDE and observed data KDE (ArviZ)</p></li>
<li><p>probs – probability for each pool of being drawn from a distribution of activated or non-activated pools</p></li>
<li><p>neg_control – normalized control values used in model</p></li>
<li><p>idata_alt – full posterior sampling trace (InferenceData object)</p></li>
<li><p>[p_mean, n_mean] – posterior mean of the offset and baseline (negative) component</p></li>
</ol>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>model, figure, pandas DataFrame, list, arviz.InferenceData, list</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">probs</span><span class="p">,</span> <span class="n">neg_control</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="p">[</span><span class="n">p_mean</span><span class="p">,</span> <span class="n">n_mean</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">activation_model</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="n">inds</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/model_fit.png" src="_images/model_fit.png" />
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">probs</span>
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Pool</p></th>
<th class="head"><p>assign</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0.99900</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1.00000</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>0.00025</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>0.36475</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>0.00025</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>0.00000</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>1.00000</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>1.00000</p></td>
</tr>
<tr class="row-even"><td><p>8</p></td>
<td><p>0.99975</p></td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>0.99975</p></td>
</tr>
<tr class="row-even"><td><p>10</p></td>
<td><p>0.00000</p></td>
</tr>
<tr class="row-odd"><td><p>11</p></td>
<td><p>0.99975</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.peptide_probabilities">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">peptide_probabilities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">pandas</span> <span class="pre">DataFrame</span></span></span><a class="headerlink" href="#cpp.peptide_probabilities" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sim</strong> (<em>pandas DataFrame</em>) – check_results table with simulation with or without drop-outs</p></li>
<li><p><strong>probs</strong> (<em>pandas DataFrame</em>) – DataFrame with probabilities produced by <a class="reference internal" href="#cpp.activation_model" title="cpp.activation_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.activation_model()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>peptide_probs – probabilitity for each peptide to cause such a pattern of activation</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas DataFrame</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">peptide_probs</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">peptide_probabilities</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.results_analysis">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">results_analysis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">peptide_probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span></span></span><a class="headerlink" href="#cpp.results_analysis" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>peptide_probs</strong> (<em>pandas DataFrame</em>) – DataFrame with probabilities for each peptide produced by <a class="reference internal" href="#cpp.peptide_probabilities" title="cpp.peptide_probabilities"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.peptide_probabilities()</span></code></a></p></li>
<li><p><strong>probs</strong> (<em>pandas DataFrame</em>) – DataFrame with probabilities produced by <a class="reference internal" href="#cpp.activation_model" title="cpp.activation_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.activation_model()</span></code></a></p></li>
<li><p><strong>sim</strong> (<em>pandas DataFrame</em>) – check_results table with simulation with or without drop-outs</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ol class="arabic simple">
<li><p>number of activated pools</p></li>
<li><p>note about detected drop-outs (erroneously non-activated pools);</p></li>
<li><p>list of the most possible peptides;</p></li>
<li><p>list of all possible peptides given this pattern of pools activation.</p></li>
</ol>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, list, list, list</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n_act_pools</span><span class="p">,</span> <span class="n">note</span><span class="p">,</span> <span class="n">most</span><span class="p">,</span> <span class="n">possible</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">peptide_probabilities</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">probs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_act_pools</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">note</span>
<span class="go">No drop-outs were detected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">most</span>
<span class="go">[&#39;SSANNCTFEYVSQPFLM&#39;, &#39;CTFEYVSQPFLMDLEGK&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">possible</span>
<span class="go">[&#39;SSANNCTFEYVSQPFLM&#39;, &#39;CTFEYVSQPFLMDLEGK&#39;]</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="in-silico-data-generation">
<h2>In silico data generation<a class="headerlink" href="#in-silico-data-generation" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="cpp.random_amino_acid_sequence">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">random_amino_acid_sequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#cpp.random_amino_acid_sequence" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>length</strong> (<em>int</em>) – length of the random amino acid sequence from which peptides would be generated, calculate how long it should be for your number of peptides</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>generated amino acid sequence of determined length</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sequence</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">random_amino_acid_sequence</span><span class="p">(</span><span class="n">shift</span><span class="o">*</span><span class="n">len_lst</span> <span class="o">+</span> <span class="p">(</span><span class="mi">100</span><span class="o">-</span><span class="n">shift</span><span class="o">*</span><span class="n">len_lst</span><span class="o">%</span><span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sequence</span>
<span class="go">&#39;EMKFLDQSQLGYVHPKWHHGTEMDEWSRSNSAYGKHQEATRLCSQWWVKTYMPTDPCWMLRYTNCCAMVPRYADFCMRDYRYAYIYFVNWNHECSDVIMETCCFALGKKLSTPTCTPGCVTVIYECKSEFEVGWPPHIIEGSAEFYAVACFVTRFMCPQTKANLLKIIISFHLHHYGQAEQICYKNEIPCCAMKFFDHREGLESNCLTCMQWPCNKSLFDPFPVMYRFSMAGNQGEPPCGYAVTMNARCTMGRWQKFRCEFKGCFYHNINVYTGCETMHECQIPVPMVHQTTLLYPCNVRSKDIDPCDWSYLEDDKERGWCGKFQMGSQIFRKFTPPPWTNRGWNHMDDTEARHRWCLTWKFTLDEPAEDTCILWIHSVYLWVVCMQGTAMSMRMVSFTLLCFMRAPPCEVMHYCDPQQTRDEELPMVGYITEELKSMFTSSSWPGSQSPGWGTWDLSIKRHSVKVPDMINPTHVVKPTKCICNQSLGWTFSEIDMYARHDIQKRWKCPIWNGQFRYEVIHSKQNPFQNSDEQPT&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.simulation">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">simulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu_off</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_off</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_p_r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_n_r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_pools</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pl_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_offset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cores</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span></span></span><a class="headerlink" href="#cpp.simulation" title="Link to this definition"></a></dt>
<dd><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Generation might take several minutes.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mu_off</strong> (<em>float</em><em>, </em><em>from 0 to 100</em>) – mu of the Truncated Normal distribution for the offset.</p></li>
<li><p><strong>sigma_off</strong> (<em>float</em><em>, </em><em>from 0 to 100</em>) – sigma of the Truncated Normal distribution for the offset.</p></li>
<li><p><strong>mu_n</strong> (<em>float</em><em>, </em><em>from 0 to 100</em>) – mu of the Truncated Normal distribution for the negative (non-activated) signal source.</p></li>
<li><p><strong>sigma_n</strong> (<em>float</em><em>, </em><em>from 0 to 100</em>) – sigma of the Truncated Normal distribution for the negative signal source.</p></li>
<li><p><strong>r</strong> (<em>int</em>) – number of replicas for each pool</p></li>
<li><p><strong>sigma_p_r</strong> (<em>float</em><em>, </em><em>from 0 to 100</em>) – sigma of measurement error for positive and low-positive pools (replicate variability)</p></li>
<li><p><strong>sigma_n_r</strong> (<em>float</em><em>, </em><em>from 0 to 100</em>) – sigma of measurement error for negative pools (replicate variability)</p></li>
<li><p><strong>n_pools</strong> (<em>int</em>) – total number of pools in the experiment</p></li>
<li><p><strong>p_shape</strong> (<em>int</em>) – number of strongly activated pools</p></li>
<li><p><strong>pl_shape</strong> (<em>int</em>) – number of low-activated (weak signal) pools</p></li>
<li><p><strong>low_offset</strong> (<em>float</em>) – scalar between 0 and 1 to reduce signal intensity for low-activated pools</p></li>
<li><p><strong>cores</strong> (<em>int</em>) – number of CPU cores to use for MCMC sampling</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ol class="arabic simple">
<li><p>p_results – simulated signal values (mean) for activated pools</p></li>
<li><p>pl_results – simulated signal values for low-activated pools</p></li>
<li><p>n_results – simulated signal values for non-activated pools</p></li>
<li><p>n_control – simulated values for negative control</p></li>
<li><p>[p_mean, n_mean] – posterior means of offset and baseline signal</p></li>
</ol>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list, list, list, list</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">control</span><span class="p">,</span> <span class="p">[</span><span class="n">offset_mean</span><span class="p">,</span> <span class="n">neg_mean</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">simulation</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">mu_off</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">sigma_off</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">mu_n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sigma_n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">sigma_p_r</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">sigma_n_r</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">n_pools</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">p_shape</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">pl_shape</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">low_offset</span><span class="o">=</span><span class="mf">0.5</span>
<span class="gp">... </span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">[15.1, 14.8, 15.0, 15.2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pl</span>
<span class="go">[7.2, 7.4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span>
<span class="go">[5.1, 5.2, 5.0, 5.3, 5.1, 5.0, 5.2, 5.3, 5.0, 5.1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">control</span>
<span class="go">[4.9, 5.0, 5.1]</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="plotting-results">
<h2>Plotting results<a class="headerlink" href="#plotting-results" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="cpp.poolplot">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">poolplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cells</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">most</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">fig</span></span></span><a class="headerlink" href="#cpp.poolplot" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>df</strong> (<em>pandas DataFrame</em>) – table with pool probabilities generated by <a class="reference internal" href="#cpp.activation_model" title="cpp.activation_model"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.activation_model()</span></code></a></p></li>
<li><p><strong>cells</strong> (<em>list</em>) – list with observed values</p></li>
<li><p><strong>inds</strong> (<em>list</em>) – list with indices for observed values</p></li>
<li><p><strong>most</strong> (<em>list</em>) – list with most possible peptides generated by <code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.run_analysis()</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>bubbleplot</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>fig</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">poolplot</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">cells</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">most</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/pool_plot.png" src="_images/pool_plot.png" />
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.bubbleplot">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">bubbleplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">fig</span></span></span><a class="headerlink" href="#cpp.bubbleplot" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>df</strong> (<em>pandas DataFrame</em>) – table with peptide probabilities generated by <a class="reference internal" href="#cpp.peptide_probabilities" title="cpp.peptide_probabilities"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.peptide_probabilities()</span></code></a></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>bubbleplot</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>fig</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cpp</span><span class="o">.</span><span class="n">bubbleplot</span><span class="p">(</span><span class="n">peptide_probs</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/bubble_plot.png" src="_images/bubble_plot.png" />
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cpp.hover_bubbleplot">
<span class="sig-prename descclassname"><span class="pre">cpp.</span></span><span class="sig-name descname"><span class="pre">hover_bubbleplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">interactive</span> <span class="pre">fig</span></span></span><a class="headerlink" href="#cpp.hover_bubbleplot" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>df</strong> (<em>pandas DataFrame</em>) – table with peptide probabilities generated by <a class="reference internal" href="#cpp.peptide_probabilities" title="cpp.peptide_probabilities"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpp.peptide_probabilities()</span></code></a></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>bubbleplot</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>fig</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span> <span class="o">=</span> <span class="n">cpp</span><span class="o">.</span><span class="n">hover_bubbleplot</span><span class="p">(</span><span class="n">peptide_probs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Installation.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ShinyApp.html" class="btn btn-neutral float-right" title="Shiny App" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Vasilisa Kovaleva.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>