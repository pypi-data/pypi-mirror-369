---
source: crates/cribo/tests/test_bundling_snapshots.rs
input_file: crates/cribo/tests/fixtures/wildcard_imports/main.py
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

import functools
import types
SHARED_CONSTANT_1 = "SHARED_FROM_B"
SAFE_CONSTANT = "SAFE_VALUE"
class SharedClass_1:
    """Class with same name in multiple modules."""

    def method(self):
        return "SharedClass_from_module_b"
class SafeClass:
    """A class that will be exported via __all__."""

    def method(self):
        return "SafeClass.method_result"
def shared_function_1():
    """Function with same name in multiple modules."""
    return "shared_function_from_module_b"
def unique_b_function():
    """Function unique to module B."""
    return "unique_b_result"
def unique_a_function():
    """Function unique to module A."""
    return "unique_a_result"
def safe_function():
    """A function that will be exported via __all__."""
    return "safe_function_result"
SharedClass_1.__module__ = 'clash_module_b'
SharedClass_1.__name__ = 'SharedClass'
SharedClass_1.__qualname__ = 'SharedClass'
"""Second module with potentially clashing names (no side-effects)."""
"""First module with potentially clashing names (no side-effects)."""
SafeClass.__module__ = 'explicit_all'
"""Module with no side-effects and explicit __all__."""
@functools.cache
def __cribo_init___cribo_9a9871_with_side_effects():
    module = types.SimpleNamespace()
    module.__name__ = 'with_side_effects'
    """Module with side-effects and no explicit __all__."""
    print("Loading with_side_effects module")
    _module_state = []
    module._module_state = _module_state
    _module_state.append("initialized")

    def effect_function():
        """Function from module with side-effects."""
        return "effect_function_result"
    module.effect_function = effect_function

    class EffectClass:
        """Class from module with side-effects."""
        instances = []

        def __init__(self):
            self.instances.append(self)

        def method(self):
            return "EffectClass.method_result"
    module.EffectClass = EffectClass
    EFFECT_CONSTANT = "EFFECT_VALUE"
    module.EFFECT_CONSTANT = EFFECT_CONSTANT
    _registry = {}
    module._registry = _registry

    def register(name):
        """Decorator with side-effects."""

        def decorator(func):
            module._registry[name] = func
            return func
        return decorator
    module.register = register

    @register("sample")
    def registered_function():
        """Function registered as a side-effect."""
        return "registered_result"
    module.registered_function = registered_function
    if len(_module_state) > 0:
        print(f"Module state initialized with {len(_module_state)} items")
    return module
"""Main module demonstrating various wildcard import patterns."""
safe_function = safe_function
SafeClass = SafeClass
SAFE_CONSTANT = SAFE_CONSTANT
with_side_effects = __cribo_init___cribo_9a9871_with_side_effects()
EFFECT_CONSTANT = with_side_effects.EFFECT_CONSTANT
EffectClass = with_side_effects.EffectClass
effect_function = with_side_effects.effect_function
register = with_side_effects.register
registered_function = with_side_effects.registered_function
unique_a_function = unique_a_function
shared_function = shared_function_1
SharedClass = SharedClass_1
SHARED_CONSTANT = SHARED_CONSTANT_1
unique_b_function = unique_b_function
def main():
    """Test all imported symbols."""
    results = []
    results.append(f"safe_function: {safe_function()}")
    results.append(f"SafeClass: {SafeClass().method()}")
    results.append(f"SAFE_CONSTANT: {SAFE_CONSTANT}")
    try:
        results.append(f"_private_function: {_private_function()}")
    except NameError:
        results.append("_private_function: correctly not imported")
    try:
        results.append(f"PRIVATE_CONSTANT: {PRIVATE_CONSTANT}")
    except NameError:
        results.append("PRIVATE_CONSTANT: correctly not imported")
    results.append(f"effect_function: {effect_function()}")
    results.append(f"EffectClass: {EffectClass().method()}")
    results.append(f"EFFECT_CONSTANT: {EFFECT_CONSTANT}")
    results.append(f"registered_function: {registered_function()}")
    results.append(f"shared_function: {shared_function()}")
    results.append(f"SharedClass: {SharedClass().method()}")
    results.append(f"SHARED_CONSTANT: {SHARED_CONSTANT}")
    results.append(f"unique_a_function: {unique_a_function()}")
    results.append(f"unique_b_function: {unique_b_function()}")
    return results
if __name__ == "__main__":
    print("Testing wildcard imports:")
    print("-" * 40)
    for result in main():
        print(result)
    print("-" * 40)
    print("All tests completed!")
