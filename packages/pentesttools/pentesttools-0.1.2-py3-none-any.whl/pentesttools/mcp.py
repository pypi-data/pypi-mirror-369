"""
The Model-Context Protocol (MCP) module for Pentest-Tools.com. It uses the ptt API to provide tools, resources and prompts
to LLM agents that implement MCP.
"""

try:
    from mcp.server.fastmcp import Context, FastMCP
except ImportError:
    # We use this as a guard, in case `pentesttools` was not installed with mcp support
    FastMCP = None


import asyncio
import json
import os
import sys
import time
import logging

import pentesttools as ptt

if not getattr(ptt.api, "api_key", False):
    api_key = os.getenv("PTT_KEY", "")
    if not api_key:
        sys.exit(
            "API key not found. Please provide it using the --key flag or set the PTT_KEY environment variable."
        )

    ptt.api.api_key = api_key


os.environ["PTT_USER_AGENT"] = "ptt-cli-mcp"

API_URL = "https://app.pentest-tools.com/api/v2/"
ptt.api.init()

HEADERS = {
    "User-Agent": "ptt-cli-mcp",
    "Accept": "*/*",
}
HEADERS["Authorization"] = f"Bearer {ptt.api.api_key}"


def run_tool(
    tool_id: int, target: str, tool_params: dict, scan_params: dict, raw: bool = False
):
    res = ptt.api.start_scan(target, tool_id, tool_params, scan_params, headers=HEADERS)
    res_json = res.json()

    scan_id = res_json["data"]["created_id"]
    logging.info("Started scan %i, for tool_id %s", scan_id, tool_id)

    while True:
        time.sleep(2)

        # Get the status of our scan
        status = ptt.api.get_scan_status(scan_id, headers=HEADERS)
        status_name = status.json()["data"]["status_name"]

        if status_name == "finished":
            logging.debug("Scan status: %s" % res_json["data"])
            logging.debug("Getting JSON report")

            if raw:
                res = ptt.api.get_raw_output(scan_id, headers=HEADERS)
                return res.text

            res = ptt.api.get_output(scan_id, headers=HEADERS)
            output_json = json.dumps(res.json())
            return output_json


async def run_tool_long_running(
    tool_id: int,
    target: str,
    tool_params: dict,
    scan_params: dict,
    raw: bool = False,
    mcp_task=None,
):
    """
    Run a tool as a long-running MCP task, reporting progress/status updates to the LLM via mcp_task.
    """
    res = ptt.api.start_scan(target, tool_id, tool_params, scan_params, headers=HEADERS)
    res_json = res.json()

    scan_id = res_json["data"]["created_id"]
    logging.info("Started scan %i, for tool_id %s", scan_id, tool_id)

    # Status groups
    progress_statuses = {"running", "waiting"}
    finished_statuses = {"finished"}
    failed_statuses = {
        "failed to start",
        "stopped",
        "timed out",
        "aborted",
        "VPN connection error",
        "auth failed",
        "connection error",
    }

    while True:
        await asyncio.sleep(2)

        # Get the status of our scan
        status = ptt.api.get_scan_status(scan_id, headers=HEADERS)
        status_data = status.json()["data"]
        status_name = status_data["status_name"]

        # Compose progress message using the provided output structure
        progress_msg = (
            f"Scan {scan_id} is {status_name}.\n"
            f"Progress: {status_data.get('progress', 0.0)}\n"
            f"Status message: {status_data.get('status_message', '')}\n"
            f"Critical: {status_data.get('result_summary', {}).get('critical', 0)}, "
            f"High: {status_data.get('result_summary', {}).get('high', 0)}, "
            f"Medium: {status_data.get('result_summary', {}).get('medium', 0)}, "
            f"Low: {status_data.get('result_summary', {}).get('low', 0)}, "
            f"Info: {status_data.get('result_summary', {}).get('info', 0)}"
        )

        # Report progress if running or waiting
        if mcp_task is not None and status_name in progress_statuses:
            await mcp_task.report_progress(
                float(status_data.get("progress", 0.0)),
                total=100.0,
                message="Scan id " + str(scan_id) + " Status: " + str(status_name),
            )

        if status_name in finished_statuses:
            logging.debug("Scan status: %s" % status_data)
            logging.debug("Getting JSON report")

            if raw:
                res = ptt.api.get_raw_output(scan_id, headers=HEADERS)
                return res.text

            res = ptt.api.get_output(scan_id, headers=HEADERS)
            output_json = json.dumps(res.json())
            return output_json

        elif status_name in failed_statuses:
            # Report failure to the LLM
            if mcp_task is not None:
                await mcp_task.info(
                    f"Scan {scan_id} failed with status: {status_name}. Status message: {status_data.get('status_message', '')}"
                )
            return json.dumps(
                {
                    "error": f"Scan failed with status: {status_name}",
                    "details": status_data,
                }
            )

        # Otherwise, keep waiting and reporting progress


def website_scanner(target: str) -> str:
    tool_id = ptt.api.Tool.WEBSITE_SCANNER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}

    return run_tool(tool_id, target, tool_params, scan_params)


async def website_scanner_long(target: str, mcp_task=None) -> str:
    tool_id = ptt.api.Tool.WEBSITE_SCANNER
    tool_params = {"scan_type": "deep"}
    scan_params = {"max_scan_time": "5"}

    return await run_tool_long_running(
        tool_id, target, tool_params, scan_params, mcp_task=mcp_task
    )


def icmp_ping(target: str) -> str:
    tool_id = ptt.api.Tool.ICMP_PING
    tool_params = {"scan_type": "light"}

    return run_tool(tool_id, target, tool_params, {}, raw=True)


def subdomain_finder(target: str) -> str:
    tool_id = ptt.api.Tool.SUBDOMAIN_FINDER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}

    return run_tool(tool_id, target, tool_params, scan_params)


def network_scanner(target: str) -> str:
    tool_id = ptt.api.Tool.NETWORK_SCANNER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}

    return run_tool(tool_id, target, tool_params, scan_params)


def url_fuzzer(target: str) -> str:
    tool_id = ptt.api.Tool.URL_FUZZER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}

    return run_tool(tool_id, target, tool_params, scan_params)


def whois_lookup(target: str) -> str:
    tool_id = ptt.api.Tool.WHOIS_LOOKUP
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def port_scanner(target: str) -> str:
    tool_id = ptt.api.Tool.PORT_SCANNER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def vhosts_finder(target: str) -> str:
    tool_id = ptt.api.Tool.VIRTUAL_HOSTS_FINDER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def sharepoint_scanner(target: str) -> str:
    tool_id = ptt.api.Tool.SHARE_POINT_SCANNER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def wordpress_scanner(target: str) -> str:
    tool_id = ptt.api.Tool.WORDPRESS_SCANNER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def drupal_scanner(target: str) -> str:
    tool_id = ptt.api.Tool.DRUPAL_SCANNER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def joomla_scanner(target: str) -> str:
    tool_id = ptt.api.Tool.JOOMLA_SCANNER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def website_recon(target: str) -> str:
    tool_id = ptt.api.Tool.WEBSITE_RECON
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def sqli_exploiter(target: str) -> str:
    tool_id = ptt.api.Tool.SQLI_EXPLOITER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def domain_finder(target: str) -> str:
    tool_id = ptt.api.Tool.DOMAIN_FINDER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def password_auditor(target: str) -> str:
    tool_id = ptt.api.Tool.PASSWORD_AUDITOR
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def ssl_scanner(target: str) -> str:
    tool_id = ptt.api.Tool.SSL_SCANNER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def sniper(target: str) -> str:
    tool_id = ptt.api.Tool.SNIPER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def waf_detector(target: str) -> str:
    tool_id = ptt.api.Tool.WAF_DETECTOR
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def api_scanner(target: str) -> str:
    tool_id = ptt.api.Tool.API_SCANNER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def cloud_scanner(target: str) -> str:
    tool_id = ptt.api.Tool.CLOUD_SCANNER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def people_hunter(target: str) -> str:
    tool_id = ptt.api.Tool.PEOPLE_HUNTER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


def kubernetes_scanner(target: str) -> str:
    tool_id = ptt.api.Tool.KUBERNETES_SCANNER
    tool_params = {"scan_type": "light"}
    scan_params = {"max_scan_time": "5"}
    return run_tool(tool_id, target, tool_params, scan_params)


if FastMCP is not None:
    mcp = FastMCP("ptt-http", port=9000)

    ### Resources
    # TODO: Resources have not worked in vscode copilot. Try to make them work and test in other MCP clients as well.
    # Resources are generally the GET requests from API
    # @mcp.resource("scans://")
    # def get_scans() -> str:
    #     """Get the current running scans"""
    #     res = ptt.api.get_scans(headers=HEADERS)

    #     # TODO: json data may not be suitable for LLMs, at least for the less powerful ones.
    #     # Make the data more LLM friendly
    #     return json.dumps(res.json())

    # @mcp.resource("targets://")
    # def get_targets() -> str:
    #     """Get the current targets available"""
    #     res = ptt.api.get_targets(headers=HEADERS)

    #     return json.dumps(res.json())

    ### Prompts
    # Prompts should match the intended use-cases for the pentesttools MCP
    @mcp.prompt()
    def pentest(target: str) -> str:
        """Create a pentesting report prompt"""
        return f"Please provide a comprehensive pentesting report for this target: {target}, using the tools at your disposal."

    @mcp.prompt()
    def is_up(target: str) -> str:
        """Create a simple target checking prompt"""
        return f"Please see if this target: {target} is up, using the tools at your disposal."

    @mcp.prompt()
    def subdomains(target: str) -> str:
        """Discover all subdomains for the target domain"""
        return f"Please find all the subdomains that you can for this domain: {target}, using the tools at your disposal."

    ### Tools
    # These are the actual pentesting tools, with some added management tools, available through `ptt.api`

    # Pentesting tools
    @mcp.tool()
    async def run_website_scanner(target: str) -> str:
        """
        Run a website scanner on the target URL.
        If you need to run a general website scan, this is the tool to use.
        If you need more information from a website under test, use this tool and tell the user you'll use this tool to accomplish your goal.

        Args:
            target: The target URL to scan.
        """
        return website_scanner(target)

    @mcp.tool()
    async def run_website_scanner_long(target: str, mcp_task: Context) -> str:
        """
        Run a long-running website scanner on the target URL, reporting progress/status updates.

        Args:
            target: The target URL to scan.
            mcp_task: (optional) The MCP task object for reporting progress.
        """
        return await website_scanner_long(target, mcp_task=mcp_task)

    @mcp.tool()
    async def run_icmp_ping(target: str) -> str:
        """
        Run an icmp ping on the target URL.
        If you need to check that a target is reachable by ping or live, in general, this is the tool to use.

        Args:
            target: The target URL to ping.
        """
        return icmp_ping(target)

    @mcp.tool()
    async def run_subdomain_finder(target: str) -> str:
        """
        Run a subdomain finder scan on the target domain name.
        If you want to see all the findable subdomains on the target domain, this is the domain to use.

        It can be paired with website scans or api scans on the most important subdomains found.

        Args:
            target: The target domain to scan.
        """
        return subdomain_finder(target)

    @mcp.tool()
    async def run_network_scanner(target: str) -> str:
        """
        Run a network scanner on the target hostname.
        If you need to run a general network scan, something like nmap, this is the tool to use.
        If you need more information about the target network, use this tool and tell the user you'll use this tool to accomplish your goal.

        Args:
            target: The target hostname to scan.
        """
        return network_scanner(target)

    @mcp.tool()
    async def run_url_fuzzer(target: str) -> str:
        """
        This tool, The URL Fuzzer, can be used to find hidden files and directories on a web server by fuzzing.

        This is a discovery activity that allows you to discover resources that were not meant to be publicly accessible (e.g. /backups, /index.php.old, /archive.tgz, /source_code.zip, etc.).
        Since 'security by obscurity' is not a good practice, you can often find sensitive information in the hidden locations identified by the URL Fuzzer.

        Args:
            target: The target path to scan
            It has the following format: https://example.com/test?id=FUZZ
        """
        return url_fuzzer(target)

    @mcp.tool()
    async def run_whois_lookup(target: str) -> str:
        """This tool allows you to perform Whois lookups online and extract information about domain names and IP addresses.

        Args:
            target: The internet resource that you want to find information about. This parameter can be an IP address or a domain name
        """
        return whois_lookup(target)

    @mcp.tool()
    async def run_port_scanner(target: str) -> str:
        """
        This tool can easily give you a quick overview of the network attack surface that includes all open TCP/UDP ports and services.

        Args:
            target: This is the hostname or the IP address to scan.
        """
        return port_scanner(target)

    @mcp.tool()
    async def run_vhosts_finder(target: str) -> str:
        """This tool discovers the virtual hosts configured on a given IP address.
        This identifies the server on which you search for virtual hosts.
        If a hostname is given, DNS resolution will be attempted first to find its IP address.

        Args:
            target: IP address or Hostname.
        """
        return vhosts_finder(target)

    @mcp.tool()
    async def run_sharepoint_scanner(target: str) -> str:
        """
        This tool discovers various security weaknesses and vulnerabilities in web applications built on top of Microsoft SharePoint and FrontPage.

        Args:
            target: This is the URL of the SharePoint website that will be scanned. All URLs must start with 'http' or 'https'.
        """
        return sharepoint_scanner(target)

    @mcp.tool()
    async def run_wordpress_scanner(target: str) -> str:
        """
        This tool helps you discover security issues and vulnerabilities in the target WordPress website using the most advanced WordPress scanner: WPScan.

        Args:
            target: This is the URL of the WordPress website that will be scanned. All URLs must start with http or https. Don't forget to specify the complete path to the base directory of the WordPress installation. Ex. http://targetwp.com/blog/.
        """
        return wordpress_scanner(target)

    @mcp.tool()
    async def run_drupal_scanner(target: str) -> str:
        """
        This tool finds Drupal version, modules, theme, and their vulnerabilities. Checks for common Drupal misconfigurations and weak server settings.

        Args:
            target: This is the URL of the Drupal website that will be scanned. All URLs must start with http or https. Don't forget to specify the complete path to the base directory of the Drupal installation (if exists). Ex. http://targetdrupal.com/path/.
        """
        return drupal_scanner(target)

    @mcp.tool()
    async def run_joomla_scanner(target: str) -> str:
        """
        This tool performs a Joomla security assessment by finding vulnerabilities in Joomla core, components, modules, and templates.

        Args:
            target: This is the URL of the Joomla website that will be scanned. All URLs must start with http or https. Don't forget to specify the complete path to the base directory of the Joomla installation. Ex. http://targetjoomla.com/cms/.
        """
        return joomla_scanner(target)

    @mcp.tool()
    async def run_website_recon(target: str) -> str:
        """
        This tool allows you to discover the technologies used by a target web application - server-side and client-side. It can also scan multiple virtual hosts on the same IP.

        Args:
            target: Is the address of the website which will be searched for known technologies. Must start with http:// or https://
        """
        return website_recon(target)

    @mcp.tool()
    async def run_sqli_exploiter(target: str) -> str:
        """
        This tool allows you to confirm SQL Injection vulnerabilities in your site, to see the vulnerable parameters, and also to demonstrate the business risk by extracting data from the database. Powered by SQLMap.

        Args:
            target: This is the URL of the website that will be scanned. All URLs must start with http or https.
        """
        return sqli_exploiter(target)

    @mcp.tool()
    async def run_domain_finder(target: str) -> str:
        """
        This tool discovers the domain names owned by a company and map its attack surface.

        Args:
            target: The target domain name (e.g. oracle.com, yahoo.com, etc.) that will be searched for associated domains
        """
        return domain_finder(target)

    @mcp.tool()
    async def run_password_auditor(target: str) -> str:
        """
        This tool scans an URL, IP address, or hostname for network services that require authentication (ex. HTTP web forms, SSH, FTP, MYSQL, PostgreSQL, RDP, etc) and detects weak credentials by trying to log in using the usernames and passwords from the input wordlists.

        Args:
            target: This is the hostname or IP address to scan.
        """
        return password_auditor(target)

    @mcp.tool()
    async def run_ssl_scanner(target: str) -> str:
        """
        This tool connects to the target port and attempts to negotiate various cipher suites and multiple SSL/TLS versions to determine weak configurations and common vulnerabilities (ex. POODLE, Heartbleed, DROWN, ROBOT, etc.). The full version of the SSL Scanner scans multiple ports and services (HTTPS, SMTPs, IMAPs, etc.).

        Args:
            target: This specifies the target that will be scanned. It can be a single IP address or a hostname (ex. 8.8.8.8 or www.example.com)
        """
        return ssl_scanner(target)

    @mcp.tool()
    async def run_sniper(target: str) -> str:
        """
        This tool automatically exploits known, widespread vulnerabilities in high-profile software. The tool gains remote command execution on the vulnerable targets and automatically runs post-exploitation modules to extract interesting data (artefacts) as solid proof for vulnerability validation.

        Args:
            target: Specifies the system that will be scanned. Target can be an IP address, hostname or an URL.
        """
        return sniper(target)

    @mcp.tool()
    async def run_waf_detector(target: str) -> str:
        """
        This tool discovers if a website is protected by a web application firewall (WAF).

        Args:
            target: This is the URL of the website that will be scanned. All URLs must start with http:// or https://.
        """
        return waf_detector(target)

    @mcp.tool()
    async def run_api_scanner(target: str) -> str:
        """
        This tool is a custom tool designed to assess the security of REST and GraphQL APIs quickly.

        Args:
            target: This is the URL of the API that will be scanned.
        """
        return api_scanner(target)

    @mcp.tool()
    async def run_cloud_scanner(target: str) -> str:
        """
        This tool evaluates multi-cloud environments (Amazon Web Services - AWS and Google Cloud Platform - GCP) to identify misconfigurations, vulnerabilities, weak access controls, interesting files, and other security issues.
        A penetration tester can use the tool to discover and confirm security vulnerabilities in cloud infrastructure and report them.

        Args:
            target: Specifies the system to be scanned. Target can be an IP address, hostname or URL. If you want to scan an AWS S3 bucket, you can input it in the URL form: http(s)://<bucket_name>.s3.amazonaws.com. If you want to scan a Google Cloud Storage bucket, you can input it in the URL form: https://storage.googleapis.com/<bucket_name>
        """
        return cloud_scanner(target)

    @mcp.tool()
    async def run_people_hunter(target: str) -> str:
        """
        This tool discovers email addresses and social media profiles from a web application.

        Args:
            target: Specifies the system to be scanned. Target can be an IP address or a hostname.
        """
        return people_hunter(target)

    @mcp.tool()
    async def run_kubernetes_scanner(target: str) -> str:
        """
        This tool automates the search for security vulnerabilities and misconfigurations in Kubernetes clusters. Its findings vary from reconnaissance to initial access vulnerabilities.

        Args:
            target: Specifies the target that will be scanned. It can be a single IP address or a hostname (ex. www.example.com)
        """
        return kubernetes_scanner(target)

    # Administrative tools
    @mcp.tool()
    async def get_scan_output_by_id(scan_id: str) -> str:
        """Get the scan report as json output, by scan_id"""
        res = ptt.api.get_output(scan_id, headers=HEADERS)

        return json.dumps(res.json())

    @mcp.tool()
    async def get_findings() -> str:
        """Get all the findings that you have"""
        res = ptt.api.get_findings(headers=HEADERS)

        return json.dumps(res.json())

    @mcp.tool()
    async def get_all_reports() -> str:
        """Get all the reports that you have"""
        res = ptt.api.get_all_reports(headers=HEADERS)

        return json.dumps(res.json())

    @mcp.tool()
    async def get_targets() -> str:
        """Get the current targets available."""
        res = ptt.api.get_targets(headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def get_scans() -> str:
        """Get the current running scans."""
        res = ptt.api.get_scans(headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def get_scan_status(scan_id: str) -> str:
        """Get the status of a scan by scan_id."""
        res = ptt.api.get_scan_status(scan_id, headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def get_raw_output(scan_id: str) -> str:
        """Get the raw output of a scan by scan_id."""
        res = ptt.api.get_raw_output(scan_id, headers=HEADERS)
        return res.text

    @mcp.tool()
    async def get_output(scan_id: str) -> str:
        """Get the parsed output of a scan by scan_id."""
        res = ptt.api.get_output(scan_id, headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def start_scan_by_targetid(
        target_id: int, tool_id: int, tool_params: dict
    ) -> str:
        """Start a scan using the given target_id."""
        res = ptt.api.start_scan_by_targetid(
            target_id, tool_id, tool_params, headers=HEADERS
        )
        return json.dumps(res.json())

    @mcp.tool()
    async def stop_scan(scan_id: int) -> str:
        """Stop a running scan."""
        res = ptt.api.stop_scan(scan_id, headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def delete_scan(scan_id: int) -> str:
        """Delete a scan."""
        res = ptt.api.delete_scan(scan_id, headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def add_target(
        name: str, description: str = "", workspace_id: int = None
    ) -> str:
        """Add a new target."""
        res = ptt.api.add_target(name, description, workspace_id, headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def delete_target(target_id: int) -> str:
        """Delete a target and its scans."""
        res = ptt.api.delete_target(target_id, headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def create_report(
        format: str,
        group_by: str,
        source: str,
        resources: list,
        filters: dict = None,
        webhook_url: str = None,
    ) -> str:
        """Create a report."""
        res = ptt.api.create_report(
            format, group_by, source, resources, filters, webhook_url, headers=HEADERS
        )
        return json.dumps(res.json())

    # TODO: Maybe it's a good idea to add elicitation for these dangerous deletes
    @mcp.tool()
    async def delete_report(report_id: int) -> str:
        """Delete a report by its ID."""
        res = ptt.api.delete_report(report_id, headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def download_report(report_id: int) -> str:
        """Download a report by its ID."""
        res = ptt.api.download_report(report_id, headers=HEADERS)
        return res.text

    @mcp.tool()
    async def create_http_logger(label: str, workspace_id: int = None) -> str:
        """Create a new HTTP request logger."""
        res = ptt.api.create_http_logger(label, workspace_id, headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def delete_logger(logger_id: int) -> str:
        """Delete an HTTP logger by its ID."""
        res = ptt.api.delete_logger(logger_id, headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def clear_data_for_logger(logger_id: int) -> str:
        """Clear all data captured by a specific HTTP logger."""
        res = ptt.api.clear_data_for_logger(logger_id, headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def create_workspace(name: str, description: str = "") -> str:
        """Create a new workspace."""
        res = ptt.api.create_workspace(name, description, headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def delete_workspace(workspace_id: int) -> str:
        """Delete a workspace by its ID."""
        res = ptt.api.delete_workspace(workspace_id, headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def edit_workspace(
        workspace_id: int, name: str = None, description: str = None
    ) -> str:
        """Edit an existing workspace."""
        res = ptt.api.edit_workspace(workspace_id, name, description, headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def get_workspaces() -> str:
        """Get all workspaces."""
        res = ptt.api.get_workspaces(headers=HEADERS)
        return json.dumps(res.json())

    @mcp.tool()
    async def get_workspace_by_id(workspace_id: int) -> str:
        """Get information about a specific workspace by its ID."""
        res = ptt.api.get_workspace_by_id(workspace_id, headers=HEADERS)
        return json.dumps(res.json())


def entrypoint(mcp_method: str = "stdio"):
    """Entrypoint for ptt-mcp"""
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    if FastMCP is None:
        logging.error(
            "PentestTools has been installed without MCP support. Install with pip install PentestTools[mcp] if you want MCP support."
        )
        return

    logging.info("Starting the PentestTools MCP server")
    if mcp_method == "stdio":
        logging.info("Using the `stdio` mcp type")
        return mcp.run(transport="stdio")
    elif mcp_method == "http":
        logging.info("Using the `http` mcp type")
        return mcp.run(transport="streamable-http")
