var Q={};Q.layout=(d,p,y,_)=>{let C=0,z=e=>{let l=++C;return e+l},X=e=>{if(Array.isArray(e)&&e.every(t=>!Array.isArray(t)))return e;let l=[];for(let t of e){if(!Array.isArray(t)){l.push(t);continue}for(let a of t)l.push(a)}return l},j=(e,l,t,a)=>{let c="";do c=z(a);while(e.hasNode(c));return t.dummy=l,e.setNode(c,t),c},U=e=>{let l=new Q.Graph(!0,!1);for(let t of e.nodes.values()){let a=t.v;e.hasChildren(a)||l.setNode(a,t.label)}for(let t of e.edges.values())l.setEdge(t.v,t.w,t.label);return l},re=e=>{let l=Number.NEGATIVE_INFINITY;for(let t of e.nodes.values()){let a=t.label.rank;a!==void 0&&a>l&&(l=a)}return l===Number.NEGATIVE_INFINITY?void 0:l},se=e=>{let l=re(e),t=l===void 0?0:l+1,a=Array.from(new Array(t),()=>[]);for(let c of e.nodes.values()){let o=c.label,f=o.rank;f!==void 0&&(a[f][o.order]=c.v)}return a},le=(e,l,t)=>{t.ranksep/=2;let a=t.rankdir;for(let c of e.edges.values()){let o=c.label;o.minlen*=2,o.labelpos.toLowerCase()!=="c"&&(a==="TB"||a==="BT"?o.width+=o.labeloffset:o.height+=o.labeloffset)}},_e=e=>{for(let l of e.edges.values())if(l.v===l.w){let t=l.vNode.label;t.selfEdges||(t.selfEdges=[]),t.selfEdges.push({e:l,label:l.label}),e.removeEdge(l)}},Re=e=>{let l=[],t=new Set,a=new Set,c=Array.from(e.nodes.keys()).reverse();for(;c.length>0;){let o=c.pop();if(Array.isArray(o))a.delete(o[0]);else if(!t.has(o)){t.add(o),a.add(o),c.push([o]);let f=e.node(o).out;for(let b=f.length-1;b>=0;b--){let x=f[b];a.has(x.w)&&l.push(x),c.push(x.w)}}}for(let o of l){let f=o.label;e.removeEdge(o),f.forwardName=o.name,f.reversed=!0,e.setEdge(o.w,o.v,f,z("rev"))}},Oe=e=>{for(let l of e.edges.values()){let t=l.label;if(t.reversed){t.points.reverse(),e.removeEdge(l);let a=t.forwardName;delete t.reversed,delete t.forwardName,e.setEdge(l.w,l.v,t,a)}}},ie=(e,l)=>l.wNode.label.rank-l.vNode.label.rank-l.label.minlen,Le=e=>{e=U(e);let l=c=>{let o=new Q.Graph(!1,!1),f=c.nodes.keys().next().value,b=c.nodes.size;o.setNode(f,{});let x=(w,G)=>{let O=Array.from(w.nodes.keys()).reverse();for(;O.length>0;){let S=O.pop(),H=G.node(S);for(let T of H.in.concat(H.out)){let P=T.v,q=S===P?T.w:P;!w.hasNode(q)&&!ie(G,T)&&(w.setNode(q,{}),w.setEdge(S,q,{}),O.push(q))}}return w.nodes.size};for(;x(o,c)<b;){let w=Number.MAX_SAFE_INTEGER,G=null;for(let S of c.edges.values())if(o.hasNode(S.v)!==o.hasNode(S.w)){let H=ie(c,S);H<w&&(w=H,G=S)}let O=o.hasNode(G.v)?ie(c,G):-ie(c,G);for(let S of o.nodes.keys())c.node(S).label.rank+=O}return o},t=c=>{let o=new Set,f=[Array.from(c.nodes.values()).filter(b=>b.in.length===0).reverse()];for(;f.length>0;){let b=f[f.length-1];if(Array.isArray(b)){let x=b.pop();if(b.length===0&&f.pop(),!o.has(x)){o.add(x);let w=x.out.map(G=>G.wNode);w.length>0?(f.push(x),f.push(w.reverse())):x.label.rank=0}}else{f.pop();let x=Number.MAX_SAFE_INTEGER;for(let w of b.out)x=Math.min(x,w.wNode.label.rank-w.label.minlen);b.label.rank=x}}},a=c=>{let o=T=>{let P=new Q.Graph(!0,!1);for(let q of T.nodes.values())P.setNode(q.v,q.label);for(let q of T.edges.values()){let u=P.edge(q.v,q.w),R=u?u.label:{weight:0,minlen:1},v=q.label;P.setEdge(q.v,q.w,{weight:R.weight+v.weight,minlen:Math.max(R.minlen,v.minlen)})}return P},f=(T,P)=>{let q=(R,v,k)=>{let i=1,s=new Map,r=[[k,null,0]];for(;r.length>0;){let[n,h,m]=r.pop();if(m===0){if(!v.has(n)){v.add(n);let g=R.node(n).label,A=i;s.set(n,{label:g,low:A,parent:h,lim:null}),r.push([n,h,1]);for(let I of R.neighbors(n))v.has(I)||r.push([I,n,0])}}else{let g=s.get(n),A=g.label;A.low=g.low,A.lim=i++,g.parent?A.parent=g.parent:delete A.parent}}};P=T.nodes.keys().next().value,q(T,new Set,P)},b=(T,P)=>{let q=[],u=new Set,R=[Array.from(T.nodes.keys()).reverse()];for(;R.length>0;){let v=R[R.length-1];if(Array.isArray(v)){let k=v.pop();if(v.length===0&&R.pop(),!u.has(k)){u.add(k);let i=T.neighbors(k);i.size>0?(R.push(k),R.push(Array.from(i).reverse())):q.push(k)}}else q.push(R.pop())}for(let v of q.slice(0,q.length-1)){let i=T.node(v).label.parent,s=P.edge(v,i),r=!!s,h=(s?s.label:P.edge(i,v).label).weight,m=P.node(v);for(let g of m.in.concat(m.out)){let A=g.v===v,I=A?g.w:g.v;if(I!==i){let N=A===r;h+=N?g.label.weight:-g.label.weight;let L=T.edge(v,I);if(L){let E=L.label.cutvalue;h+=N?-E:E}}}T.edge(v,i).label.cutvalue=h}},x=T=>Array.from(T.edges.values()).find(P=>P.label.cutvalue<0),w=(T,P,q)=>{let u=q.v,R=q.w;P.edge(u,R)||(u=q.w,R=q.v);let v=T.node(u).label,k=T.node(R).label,i=v,s=!1;v.lim>k.lim&&(i=k,s=!0);let r=(m,g)=>g.low<=m.lim&&m.lim<=g.lim,n=Number.POSITIVE_INFINITY,h=null;for(let m of P.edges.values())if(s===r(T.node(m.v).label,i)&&s!==r(T.node(m.w).label,i)){let g=ie(P,m);g<n&&(n=g,h=m)}return h},G=(T,P,q,u)=>{T.removeEdge(q),T.setEdge(u.v,u.w,{}),f(T),b(T,P);let v=[Array.from(T.nodes.keys()).find(s=>!P.node(s).label.parent)],k=new Set;for(;v.length>0;){let s=v.pop();if(!k.has(s)){k.add(s);let r=Array.from(T.neighbors(s));for(let n=r.length-1;n>=0;n--)v.push(r[n])}}let i=Array.from(k);for(let s of i.slice(1)){let r=T.node(s).label.parent,n=P.edge(s,r),h=!1;n||(n=P.edge(r,s),h=!0),P.node(s).label.rank=P.node(r).label.rank+(h?n.label.minlen:-n.label.minlen)}};c=o(c),t(c);let O=l(c);f(O),b(O,c);let S=null,H=null;for(;S=x(O);)H=w(O,c,S),G(O,c,S,H)};switch(y.ranker){case"tight-tree":t(e),l(e);break;case"longest-path":t(e);break;default:a(e);break}},De=e=>{for(let l of e.edges.values()){let t=l.label;if(t.width&&t.height){let a=l.vNode.label,c=l.wNode.label;j(e,"edge-proxy",{rank:(c.rank-a.rank)/2+a.rank,e:l},"_ep")}}},Ge=(e,l)=>{if(e.nodes.size>0){let t=Number.MAX_SAFE_INTEGER,a=Number.MIN_SAFE_INTEGER,c=Array.from(e.nodes.values());for(let f of c){let b=f.label;b.rank!==void 0&&(t=Math.min(t,b.rank),a=Math.max(a,b.rank))}let o=a-t;if(o>0){let f=new Array(o);for(let w of c){let G=w.label;if(G.rank!==void 0){let O=G.rank-t;f[O]||(f[O]=[]),f[O].push(w.v)}}let b=0,x=l.nodeRankFactor;for(let w=0;w<f.length;w++){let G=f[w];if(G===void 0&&w%x!==0)b--;else if(b&&G)for(let O of G)e.node(O).label.rank+=b}}}},Me=(e,l)=>{let t=j(e,"root",{},"_root"),a=w=>{let G={},O=(S,H)=>{for(let T of w.children(S))O(T,H+1);G[S]=H};for(let S of w.children())O(S,1);return G},c=(w,G,O,S,H,T,P)=>{let q=Array.from(w.children(P));if(!q.length){P!==G&&w.setEdge(G,P,{weight:0,minlen:O});return}let u=j(w,"border",{width:0,height:0},"_bt"),R=j(w,"border",{width:0,height:0},"_bb"),v=w.node(P).label;w.hasBorder=!0,w.setParent(u,P),v.borderTop=u,w.setParent(R,P),v.borderBottom=R;for(let k of q){c(w,G,O,S,H,T,k);let i=w.node(k).label,s=i.borderTop?i.borderTop:k,r=i.borderBottom?i.borderBottom:k,n=i.borderTop?S:2*S,h=s===r?H-T[P]+1:1;w.setEdge(u,s,{weight:n,minlen:h,nestingEdge:!0}),w.setEdge(r,R,{weight:n,minlen:h,nestingEdge:!0})}w.parent(P)||w.setEdge(G,u,{weight:0,minlen:H+T[P]})},o=a(e),f=Math.max(...Object.values(o))-1,b=2*f+1;l.nestingRoot=t;for(let w of e.edges.values())w.label.minlen*=b;let x=Array.from(e.edges.values()).reduce((w,G)=>w+G.label.weight,0)+1;for(let w of e.children())c(e,t,b,x,f,o,w);l.nodeRankFactor=b},Ve=(e,l)=>{e.removeNode(l.nestingRoot),delete l.nestingRoot;for(let t of e.edges.values())t.label.nestingEdge&&e.removeEdge(t)},Ce=(e,l)=>{let t=Number.POSITIVE_INFINITY;for(let c of e.nodes.values()){let o=c.label.rank;o!==void 0&&o<t&&(t=o)}for(let c of e.nodes.values()){let o=c.label;o.rank!==void 0&&(o.rank-=t)}let a=0;if(e.hasBorder)for(let c of e.nodes.values()){let o=c.label;o.borderTop&&(o.minRank=e.node(o.borderTop).label.rank,o.maxRank=e.node(o.borderBottom).label.rank,a=Math.max(a,o.maxRank))}l.maxRank=a},Se=(e,l)=>{l.dummyChains=[];for(let t of e.edges.values()){let a=t.v,c=t.w,o=t.name,f=t.label,b=f.labelRank,x=e.node(a).label.rank,w=e.node(c).label.rank;if(w!==x+1){e.removeEdge(t);let G=!0;for(x++;x<w;){f.points=[],delete t.key;let O={width:0,height:0,edgeLabel:f,edgeObj:t,rank:x},S=j(e,"edge",O,"_d");x===b&&(O.width=f.width,O.height=f.height,O.dummy="edge-label",O.labelpos=f.labelpos),e.setEdge(a,S,{weight:f.weight},o),G&&(l.dummyChains.push(S),G=!1),a=S,x++}e.setEdge(a,c,{weight:f.weight},o)}}},Pe=(e,l)=>{for(let t of l.dummyChains){let a=e.node(t).label,c=a.edgeLabel,o=a.edgeObj;for(e.setEdge(o.v,o.w,c,o.name);a.dummy;){let f=e.successors(t).keys().next().value;e.removeNode(t),c.points.push({x:a.x,y:a.y}),a.dummy==="edge-label"&&(c.x=a.x,c.y=a.y,c.width=a.width,c.height=a.height),t=f,a=e.node(t).label}}},qe=e=>{for(let l of e.nodes.values()){let t=l.label;t.dummy==="edge-proxy"&&(t.e.label.labelRank=t.rank,e.removeNode(l.v))}},Ye=(e,l)=>{let t=(o,f,b,x)=>{let w=Math.min(f[b].low,f[x].low),G=Math.max(f[b].lim,f[x].lim),O=b,S=[];do O=o.parent(O),S.push(O);while(O&&(f[O].low>w||G>f[O].lim));let H=O;O=x;let T=[];for(;(O=o.parent(O))!==H;)T.push(O);return{path:S.concat(T.reverse()),lca:H}},c=(o=>{let f={},b=0,x=w=>{let G=b;for(let O of o.children(w))x(O);f[w]={low:G,lim:b++}};for(let w of o.children())x(w);return f})(e);for(let o of l.dummyChains||[]){let b=e.node(o).label.edgeObj,x=t(e,c,b.v,b.w),w=x.path,G=x.lca,O=0,S=w[O],H=!0;for(;o!==b.w;){let T=e.node(o).label;if(H){for(;(S=w[O])!==G&&e.node(S).label.maxRank<T.rank;)O++;S===G&&(H=!1)}if(!H){for(;O<w.length-1&&e.node(w[O+1]).label.minRank<=T.rank;)O++;S=w[O]}e.setParent(o,S),o=e.successors(o).keys().next().value}}},ze=e=>{let l=(a,c,o,f,b,x)=>{let w={width:0,height:0,rank:x,borderType:c},G=b[c][x-1],O=j(a,"border",w,o);b[c][x]=O,a.setParent(O,f),G&&a.setEdge(G,O,{weight:1})},t=Array.from(e.children());for(let a=0;a<t.length;a++){let c=t[a],o=e.node(c).label;if("minRank"in o){o.borderLeft=[],o.borderRight=[];let b=o.maxRank+1;for(let x=o.minRank;x<b;x++)l(e,"borderLeft","_bl",c,o,x),l(e,"borderRight","_br",c,o,x)}let f=e.children(c);for(let b of f)t.push(b)}},Fe=e=>{let l=(u,R,v,k)=>{let i=(E,D)=>{let V=new Map;for(let M=0;M<E.length;M++){let F=E[M],Z={indegree:0,in:[],out:[],vs:[F.v],i:M};F.barycenter!==void 0&&(Z.barycenter=F.barycenter,Z.weight=F.weight),V.set(F.v,Z)}for(let M of D.edges.values()){let F=V.get(M.v),Z=V.get(M.w);F&&Z&&(Z.indegree++,F.out.push(Z))}let Y=Array.from(V.values()).filter(M=>!M.indegree),$=[];function B(M){return function(F){if(!F.merged&&(F.barycenter===void 0||M.barycenter===void 0||F.barycenter>=M.barycenter)){let Z=0,te=0;M.weight&&(Z+=M.barycenter*M.weight,te+=M.weight),F.weight&&(Z+=F.barycenter*F.weight,te+=F.weight),M.vs=F.vs.concat(M.vs),M.barycenter=Z/te,M.weight=te,M.i=Math.min(F.i,M.i),F.merged=!0}}}function K(M){return function(F){F.in.push(M),--F.indegree===0&&Y.push(F)}}for(;Y.length;){let M=Y.pop();$.push(M),M.in.reverse().forEach(B(M)),M.out.forEach(K(M))}return $.filter(M=>!M.merged).map(M=>{let F={vs:M.vs,i:M.i};return M.barycenter!==void 0&&(F.barycenter=M.barycenter),M.weight!==void 0&&(F.weight=M.weight),F})},s=(E,D)=>Array.from(D).map(V=>{let Y=E.node(V).in;if(!Y.length)return{v:V};let $=Y.reduce((B,K)=>{let M=K.label,F=K.vNode.label;return{sum:B.sum+M.weight*F.order,weight:B.weight+M.weight}},{sum:0,weight:0});return{v:V,barycenter:$.sum/$.weight,weight:$.weight}}),r=(E,D)=>{let V=(J,ee,ne)=>{let xe=null;for(;ee.length&&(xe=ee[ee.length-1]).i<=ne;)ee.pop(),J.push(xe.vs),ne++;return ne},Y=J=>function(ee,ne){return ee.barycenter<ne.barycenter?-1:ee.barycenter>ne.barycenter?1:J?ne.i-ee.i:ee.i-ne.i},$={lhs:[],rhs:[]};for(let J of E)"barycenter"in J?$.lhs.push(J):$.rhs.push(J);let B=$.lhs,K=$.rhs.sort((J,ee)=>-J.i+ee.i),M=[],F=0,Z=0,te=0;B.sort(Y(!!D)),te=V(M,K,te);for(let J of B)te+=J.vs.length,M.push(J.vs),F+=J.barycenter*J.weight,Z+=J.weight,te=V(M,K,te);let fe={vs:X(M)};return Z&&(fe.barycenter=F/Z,fe.weight=Z),fe},n=u.node(R),h=n&&n.label?n.label.borderLeft:void 0,m=n&&n.label?n.label.borderRight:void 0,g={},A=h?Array.from(u.children(R)).filter(E=>E!==h&&E!==m):u.children(R),I=s(u,A);for(let E of I)if(u.hasChildren(E.v)){let D=l(u,E.v,v,k);g[E.v]=D,"barycenter"in D&&(E.barycenter===void 0?(E.barycenter=D.barycenter,E.weight=D.weight):(E.barycenter=(E.barycenter*E.weight+D.barycenter*D.weight)/(E.weight+D.weight),E.weight+=D.weight))}let N=i(I,v);for(let E of N)E.vs=X(E.vs.map(D=>g[D]?g[D].vs:D));let L=r(N,k);if(h){L.vs=X([h,L.vs,m]);let E=u.predecessors(h);if(E.size>0){let D=u.node(E.keys().next().value).label,V=u.node(u.predecessors(m).keys().next().value).label;"barycenter"in L||(L.barycenter=0,L.weight=0),L.barycenter=(L.barycenter*L.weight+D.order+V.order)/(L.weight+2),L.weight+=2}}return L},t=(u,R)=>{let v=new Q.Graph(!0,!1);for(let k of u){let i=k.root,r=l(k,i,v,R).vs,n=r.length;for(let A=0;A<n;A++)k.node(r[A]).label.order=A;let h={},m="",g=!1;for(let A of r){let I=k.parent(A),N=null;for(;I;){let L=k.parent(I);if(L?(N=h[L],h[L]=I):(N=m,m=I),N&&N!==I){v.setEdge(N,I,null),g=!0;break}I=L}if(g)break}}},a=(u,R,v)=>{let k=0;for(let i=1;i<R.length;i++){let s=R[i-1],r=R[i],n=new Map;for(let I=0;I<r.length;I++)n.set(r[I],I);let h=[];for(let I of s){let N=[];for(let L of u.node(I).out)N.push({pos:n.get(L.w),weight:L.label.weight});N.sort((L,E)=>L.pos-E.pos);for(let L of N)h.push(L)}let m=1;for(;m<r.length;)m<<=1;let g=2*m-1;m-=1;let A=Array.from(new Array(g),()=>0);for(let I of h){let N=I.pos+m;A[N]+=I.weight;let L=0;for(;N>0;)N%2&&(L+=A[N+1]),N=N-1>>1,A[N]+=I.weight;k+=I.weight*L}if(k>v)break}return k},c=u=>{let R=new Set,v=Array.from(u.nodes.values()).filter(i=>!u.hasChildren(i.v)),k=-1;for(let i of v){let s=i.label.rank;(k===-1||s!==void 0&&s>k)&&(k=s)}if(k!==-1){let i=Array.from(new Array(k+1),()=>[]),s=v.sort((r,n)=>r.label.rank-n.label.rank).map(r=>r.v).reverse();for(let r=0;r<s.length;r++){let n=s[r];if(!R.has(n)){R.add(n);let h=u.node(n).label.rank;i[h].push(n),s.push(...u.successors(n).keys())}}return i}return[]},o=(u,R,v,k,i)=>{let s="";for(;u.hasNode(s=z("_root")););let r=new Q.Graph(!0,!0);r.root=s,r.setDefaultNodeLabel(h=>{let m=u.node(h);return m?m.label:void 0});let n=R.length;if(u.hasBorder){let h=0;for(;h<n;){let m=R[h++],g=m.label;if(g.rank===k||"minRank"in g&&"maxRank"in g&&g.minRank<=k&&k<=g.maxRank){let A=m.v;r.setNode(A);let I=u.parent(A);if(r.setParent(A,I||s),i)for(let N of m.in)r.setEdge(N.v,A,{weight:N.label.weight});else for(let N of m.out)r.setEdge(N.w,A,{weight:N.label.weight});"minRank"in g&&r.setNode(A,{borderLeft:g.borderLeft[k],borderRight:g.borderRight[k]})}}}else{let h=v.get(k);for(;h<n;){let m=R[h++];if(m.label.rank!==k)break;let A=m.v;r.setNode(A);let I=u.parent(A);if(r.setParent(A,I||s),i)for(let N of m.in)r.setEdge(N.v,A,{weight:N.label.weight});else for(let N of m.out)r.setEdge(N.w,A,{weight:N.label.weight})}}return r},f=c(e),b=(u,R)=>{for(let v of R)for(let k=0;k<v.length;k++)u.node(v[k]).label.order=k};b(e,f);let x=re(e)||0,w=new Array(x),G=new Array(x),O=Array.from(e.nodes.values()),S=null;if(!e.hasBorder){O.sort((u,R)=>u.label.rank-R.label.rank),S=new Map;for(let u=0;u<O.length;++u){let v=O[u].label.rank;S.has(v)||S.set(v,u)}}for(let u=0;u<x;u++)w[u]=o(e,O,S,u+1,!0),G[u]=o(e,O,S,x-u-1,!1);let H=Number.POSITIVE_INFINITY,T=[];for(let u=0,R=0;R<4;++u,++R){t(u%2?w:G,u%4>=2),f=se(e);let v=a(e,f,H);if(v<H){R=0;let k=f.length;T=new Array(k);for(let i=0;i<k;i++)T[i]=f[i].slice();H=v}}let P=(u,R)=>u<R?1:2;for(let u=4;u<T.length;u+=2){let R=T[u];for(let v=0;v<R.length;++v){let k=e.nodes.get(R[v]);if(k.in&&k.in.length===2){let i=k.in[0].vNode.in[0].vNode,s=k.in[1].vNode.in[0].vNode,r=[],n=0;for(let h=u-2;h>=0;h-=2){let m=T[h],g=m.indexOf(i.v),A=m.indexOf(s.v),I=P(g,A);if(n|=I,g===A||Math.abs(g-A)!==1||i.in.length!==1||s.in.length!==1||i.out.length!==1||s.out.length!==1){if(n===3){let N=I,L=h+2;for(;r.length!==0;){let E=r.pop(),D=r.pop(),V=T[L],Y=T[L-1],$=Y.indexOf(e.node(V[D]).in[0].v),B=Y.indexOf(e.node(V[E]).in[0].v);P(D,E)!==N&&([V[D],V[E]]=[V[E],V[D]]),P($,B)!==N&&([Y[$],Y[B]]=[Y[B],Y[$]]),L+=2}}break}r.push(g,A),i=i.in[0].vNode.in[0].vNode,s=s.in[0].vNode.in[0].vNode}}}}let q=(u,R,v)=>{let k=u.indexOf(R.v),i=u.indexOf(v.v);u[i]=R.v,u[k]=v.v};for(let u=0;u<T.length-2;u+=2){let R=T[u],v=T[u+1],k=T[u+2];for(let i=0;i<R.length;++i){let s=e.nodes.get(R[i]);if(s.out&&s.out.length>=2)for(let r=0;r<s.out.length-1;++r){let n=s.out[r].wNode,h=s.out[r+1].wNode,m=n.out[0].wNode,g=h.out[0].wNode;v.indexOf(n.v)<v.indexOf(h.v)^k.indexOf(m.v)<k.indexOf(g.v)&&q(v,n,h)}}for(let i=0;i<k.length;++i){let s=e.nodes.get(k[i]);if(s.in&&s.in.length>=2)if(s.in.length===2){let r=s.in[0].vNode,n=s.in[1].vNode,h=r.in[0].vNode,m=n.in[0].vNode;v.indexOf(r.v)<v.indexOf(n.v)^R.indexOf(h.v)<R.indexOf(m.v)&&q(v,r,n)}else{let r=[];for(let n=0;n<s.in.length;++n){let h=s.in[n].vNode,m=h.in[0].vNode,g=R.indexOf(m.v),A=v.indexOf(h.v);s.in[n].idx0=g,r.push(A)}s.in.sort((n,h)=>n.idx0-h.idx0),r.sort((n,h)=>n-h);for(let n=0;n<r.length;++n)v[r[n]]=s.in[n].v}}}for(let u=0;u<T.length-4;u+=2){let R=T[u],v=T[u+2],k=T[u+4];if(v.length>=2&&k.length>=2){let i=T[u+1],s=T[u+3];for(let r=0;r<R.length;++r){let n=e.nodes.get(R[r]);if(n.in&&n.out&&n.out.length>=2)for(let h=0;h<n.out.length-1;++h){let m=n.out[h].wNode,g=n.out[h+1].wNode,A=m.out[0].wNode,I=g.out[0].wNode;if(A.out.length===1&&I.out.length===1){let N=v.indexOf(A.v),L=v.indexOf(I.v);if(N+1===L){let E=A.out[0].wNode,D=I.out[0].wNode;if(E.out.length===1&&D.out.length===1){let V=E.out[0].wNode,Y=D.out[0].wNode,$=k.indexOf(V.v),B=k.indexOf(Y.v);$>B&&(q(i,m,g),q(v,A,I),q(s,E,D),++h)}}}}}for(let r=0;r<v.length-1;++r){let n=e.nodes.get(v[r]);if(n.in&&n.out&&n.in.length===1&&n.out.length===1){let h=e.nodes.get(v[r+1]);if(h.in&&h.out&&h.in.length===1&&h.out.length===1){let m=n.in[0].vNode,g=h.in[0].vNode;if(m.in.length===1&&g.in.length===1){let A=m.in[0].vNode,I=g.in[0].vNode,N=R.indexOf(A.v),L=R.indexOf(I.v);if(L+1===N){let E=n.out[0].wNode,D=h.out[0].wNode;N=s.indexOf(E.v),L=s.indexOf(D.v),N+1===L&&E.out[0].wNode===D.out[0].wNode&&(q(i,m,g),q(v,n,h),q(s,E,D),r+=1)}}}}}}}b(e,T)},He=e=>{let l=se(e);for(let t of l){let a=0;t.forEach((c,o)=>{let f=e.node(c).label;if(f.order=o+a,f.selfEdges){for(let b of f.selfEdges)j(e,"selfedge",{width:b.label.width,height:b.label.height,rank:f.rank,order:o+ ++a,e:b.e,label:b.label},"_se");delete f.selfEdges}})}},ye=e=>{for(let l of e.nodes.values()){let t=l.label,a=t.width;t.width=t.height,t.height=a}for(let l of e.edges.values()){let t=l.label,a=t.width;t.width=t.height,t.height=a}},Be=(e,l,t)=>{let a=t.rankdir.toLowerCase();(a==="lr"||a==="rl")&&ye(e)},$e=(e,l,t)=>{let a=t.rankdir.toLowerCase();if(a==="bt"||a==="rl"){for(let c of e.nodes.values())c.label.y=-c.label.y;for(let c of e.edges.values()){let o=c.label;for(let f of o.points)f.y=-f.y;"y"in o&&(o.y=-o.y)}}if(a==="lr"||a==="rl"){let c=o=>{[o.x,o.y]=[o.y,o.x]};for(let o of e.nodes.values())c(o.label);for(let o of e.edges.values()){let f=o.label;for(let b of f.points)c(b);f.x!==void 0&&c(f)}ye(e)}},Xe=(e,l,t)=>{let a=(i,s,r)=>{s>r&&([s,r]=[r,s]);let n=i.get(s);n||(n=new Set,i.set(s,n)),n.add(r)},c=(i,s,r)=>(s>r&&([s,r]=[r,s]),i.has(s)&&i.get(s).has(r)),o=(i,s,r,n,h)=>{let m=s.nodesep,g=s.edgesep,A=new Q.Graph(!0,!1);for(let I of r){let N=null;for(let L of I){let E=n.get(L);if(A.setNode(E,{}),N){let D=n.get(N),V=i.node(L).label,Y=i.node(N).label,$=0,B=0;if($+=V.width/2,"labelpos"in V)switch(V.labelpos){case"l":B=-V.width/2;break;case"r":B=V.width/2;break;default:throw new Q.Error(`Unsupported label position '${V.labelpos}'.`)}if(B&&($+=h?B:-B),B=0,$+=(V.dummy?g:m)/2,$+=(Y.dummy?g:m)/2,$+=Y.width/2,"labelpos"in Y)switch(Y.labelpos){case"l":B=Y.width/2;break;case"r":B=-Y.width/2;break;default:throw new Q.Error(`Unsupported label position '${Y.labelpos}'.`)}B&&($+=h?B:-B);let K=A.edge(D,E),M=Math.max($,K?K.label:0);K?K.label=M:A.setEdge(D,E,M)}N=L}}return A},f=(i,s,r)=>{let n=new Map,h=new Map,m=new Map;for(let g of i){let A=0;for(let I of g)n.set(I,I),h.set(I,I),m.set(I,A),A++}for(let g of i){let A=-1;for(let I of g){let N=r(I);if(N.size>0){N=Array.from(N.keys()),N=N.sort((D,V)=>m.get(D)-m.get(V));let L=(N.length-1)/2.0000001,E=Math.ceil(L);for(let D=Math.floor(L);D<=E;D++){let V=N[D];if(h.get(I)===I&&A<m.get(V)&&!c(s,I,V)){let Y=n.get(V);h.set(V,I),h.set(I,Y),n.set(I,Y),A=m.get(V)}}}}}return{root:n,align:h}},b=(i,s,r,n,h,m)=>{let g=o(i,s,r,n,m),A=m?"borderLeft":"borderRight",I=new Map;if(g.nodes.size>0){let N=Array.from(g.nodes.keys()),L=new Set;for(;N.length>0;){let E=N.pop();if(L.has(E)){let D=0;for(let V of g.node(E).in)D=Math.max(D,I.get(V.v)+V.label);I.set(E,D)}else L.add(E),N.push(E),N.push(...g.predecessors(E).keys())}}if(g.nodes.size>0){let N=Array.from(g.nodes.keys()),L=new Set;for(;N.length>0;){let E=N.pop();if(L.has(E)){let D=Number.POSITIVE_INFINITY;for(let Y of g.node(E).out)D=Math.min(D,I.get(Y.w)-Y.label);let V=i.node(E).label;if(V.dummy)continue;D!==Number.POSITIVE_INFINITY&&V.borderType!==A&&I.set(E,Math.max(I.get(E),D))}else L.add(E),N.push(E),N.push(...g.successors(E).keys())}}for(let N of h.values())I.set(N,I.get(n.get(N)));return I},x=(i,s)=>{let r=new Map;if(s.length>0){let[n]=s;for(let h=1;h<s.length;h++){let m=s[h],g=0,A=0,I=n.length,N=m[m.length-1];for(let L=0;L<m.length;L++){let E=m[L],D=i.node(E).label.dummy?Array.from(i.predecessors(E).keys()).find(V=>i.node(V).label.dummy):null;if(D||E===N){let V=D?i.node(D).label.order:I;for(let Y of m.slice(A,L+1))if(i.predecessors(Y).size>0)for(let B of i.predecessors(Y).keys()){let K=i.node(B).label,M=K.order;(M<g||V<M)&&!(K.dummy&&i.node(Y).label.dummy)&&a(r,B,Y)}A=L+1,g=V}}n=m}}return r},w=(i,s)=>{let r=new Map,n=(h,m,g,A,I)=>{for(let N=m;N<g;N++){let L=h[N];if(i.node(L).labeldummy)for(let E of i.predecessors(L).keys()){let D=i.node(E).label;D.dummy&&(D.order<A||D.order>I)&&a(r,E,L)}}};if(s.length>0){let[h]=s;for(let m=1;m<s.length;m++){let g=s[m],A=-1,I=0,N=0;g.forEach((L,E)=>{if(i.node(L).label.dummy==="border"){let D=i.predecessors(L);D.size>0&&(I=i.node(D.keys().next().value).label.order,n(g,N,E,A,I),N=E,A=I)}n(g,N,g.length,I,h.length)}),h=g}}return r};e=U(e);let G=se(e),O=t.ranksep,S=0;for(let i of G){let s=i.reduce((r,n)=>Math.max(r,e.node(n).label.height),0);for(let r of i)e.node(r).label.y=S+s/2;S+=s+O}let H=new Map([...x(e,G).entries(),...w(e,G).entries()]),T={};for(let i of["u","d"]){let s=i==="u"?G:Object.values(G).reverse();for(let r of["l","r"]){r==="r"&&(s=s.map(g=>Object.values(g).reverse()));let n=(i==="u"?e.predecessors:e.successors).bind(e),h=f(s,H,n),m=b(e,t,s,h.root,h.align,r==="r");if(r==="r")for(let[g,A]of m.entries(m))m.set(g,-A);T[i+r]=m}}let P=Number.POSITIVE_INFINITY,q=null;for(let i of Object.values(T)){let s=Number.NEGATIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(let[h,m]of i.entries()){let g=e.node(h).label.width/2;s=Math.max(m+g,s),r=Math.min(m-g,r)}let n=s-r;n<P&&(P=n,q=i)}let u=q,R=i=>{let s=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;for(let n of i)n<s&&(s=n),n>r&&(r=n);return[s,r]},v=R(u.values(u));for(let i of["u","d"])for(let s of["l","r"]){let r=i+s,n=T[r];if(n!==u){let h=R(n.values()),m=s==="l"?v[0]-h[0]:v[1]-h[1];if(m){let g=new Map;for(let[A,I]of n.entries())g.set(A,I+m);T[r]=g}}}let k=t.align;if(k){let i=T[k.toLowerCase()];for(let s of T.ul.keys())e.node(s).label.x=i.get(s)}else for(let i of T.ul.keys()){let s=[T.ul.get(i),T.ur.get(i),T.dl.get(i),T.dr.get(i)].sort((r,n)=>r-n);e.node(i).label.x=(s[1]+s[2])/2}},je=e=>{for(let l of e.nodes.values()){let t=l.label;if(t.dummy==="selfedge"){let a=l.v,c=e.node(t.e.v).label,o=c.x+c.width/2,f=c.y,b=t.x-o,x=c.height/2;e.setEdge(t.e.v,t.e.w,t.label),e.removeNode(a),t.label.points=[{x:o+2*b/3,y:f-x},{x:o+5*b/6,y:f-x},{x:o+b,y:f},{x:o+5*b/6,y:f+x},{x:o+2*b/3,y:f+x}],t.label.x=t.x,t.label.y=t.y}}},We=e=>{for(let l of e.nodes.values()){let t=l.v;if(e.hasChildren(t)){let a=l.label,c=e.node(a.borderTop).label,o=e.node(a.borderBottom).label,f=e.node(a.borderLeft[a.borderLeft.length-1]).label,b=e.node(a.borderRight[a.borderRight.length-1]).label;a.width=Math.abs(b.x-f.x),a.height=Math.abs(o.y-c.y),a.x=f.x+a.width/2,a.y=c.y+a.height/2}}for(let l of e.nodes.values())l.label.dummy==="border"&&e.removeNode(l.v)},Ue=e=>{for(let l of e.edges.values()){let t=l.label;if("x"in t)switch((t.labelpos==="l"||t.labelpos==="r")&&(t.width-=t.labeloffset),t.labelpos){case"l":t.x-=t.width/2+t.labeloffset;break;case"r":t.x+=t.width/2+t.labeloffset;break;default:throw new Q.Error(`Unsupported label position '${t.labelpos}'.`)}}},Ze=(e,l)=>{let t=Number.POSITIVE_INFINITY,a=0,c=Number.POSITIVE_INFINITY,o=0,f=b=>{let x=b.x,w=b.y,G=b.width,O=b.height;t=Math.min(t,x-G/2),a=Math.max(a,x+G/2),c=Math.min(c,w-O/2),o=Math.max(o,w+O/2)};for(let b of e.nodes.values())f(b.label);for(let b of e.edges.values()){let x=b.label;"x"in x&&f(x)}for(let b of e.nodes.values())b.label.x-=t,b.label.y-=c;for(let b of e.edges.values()){let x=b.label;for(let w of x.points)w.x-=t,w.y-=c;"x"in x&&(x.x-=t),"y"in x&&(x.y-=c)}l.width=a-t,l.height=o-c},Ke=e=>{let l=(t,a)=>{let c=t.x,o=t.y,f=a.x-c,b=a.y-o;if(f===0&&b===0)throw new Error("Not possible to find intersection inside of the rectangle");let x=t.width/2,w=t.height/2;return Math.abs(b)*x>Math.abs(f)*w?(w=b<0?-w:w,{x:c+w*f/b,y:o+w}):(x=f<0?-x:x,{x:c+x,y:o+x*b/f})};for(let t of e.edges.values()){let a=t.label,c=t.vNode.label,o=t.wNode.label,f=null,b=null;a.points?([f]=a.points,b=a.points[a.points.length-1]):(a.points=[],f=o,b=c),a.points.unshift(l(c,f)),a.points.push(l(o,b))}},oe=new Q.Graph(!0,!0);for(let e of d)oe.setNode(e.v,{width:e.width,height:e.height}),e.parent&&oe.setParent(e.v,e.parent);for(let e of p)oe.setEdge(e.v,e.w,{minlen:e.minlen||1,weight:e.weight||1,width:e.width||0,height:e.height||0,labeloffset:e.labeloffset||10,labelpos:e.labelpos||"r"});y={ranksep:50,edgesep:20,nodesep:50,rankdir:"tb",...y};let Ne=[le,_e,Re,Me,Le,De,Ge,Ve,Ce,qe,Se,Ye,ze,Fe,He,Be,Xe,je,We,Pe,Ue,$e,Ze,Ke,Oe];for(;Ne.length>0;)Ne.shift()(oe,_,y);for(let e of d){let l=oe.node(e.v).label;e.x=l.x,e.y=l.y,oe.hasChildren(e.v)&&(e.width=l.width,e.height=l.height)}for(let e of p){let l=oe.edge(e.v,e.w).label;e.points=l.points,"x"in l&&(e.x=l.x,e.y=l.y)}_.log&&(_.log=oe.toString())};Q.Graph=class{constructor(d,p){this.directed=d,this.compound=p,this._defaultNodeLabelFn=()=>{},this.nodes=new Map,this.edges=new Map,this.compound&&(this._parent=new Map,this._children=new Map,this._children.set("\0",new Map))}setDefaultNodeLabel(d){this._defaultNodeLabelFn=d}setNode(d,p){let y=this.nodes.get(d);if(y)p&&(y.label=p);else{let _={label:p||this._defaultNodeLabelFn(d),in:[],out:[],predecessors:new Map,successors:new Map,v:d};this.nodes.set(d,_),this.compound&&(this._parent.set(d,"\0"),this._children.set(d,new Map),this._children.get("\0").set(d,!0))}}node(d){return this.nodes.get(d)}hasNode(d){return this.nodes.has(d)}removeNode(d){let p=this.nodes.get(d);if(p){if(this.compound){this._children.get(this._parent.get(d)).delete(d),this._parent.delete(d);for(let y of this.children(d))this.setParent(y);this._children.delete(d)}for(let y of p.in.concat())this.removeEdge(y);for(let y of p.out.concat())this.removeEdge(y);this.nodes.delete(d)}}setParent(d,p){if(!this.compound)throw new Error("Cannot set parent in a non-compound graph");if(p){for(let y=p;y!==void 0;y=this.parent(y))if(y===d)throw new Error(`Setting ${p} as parent of ${d} would create a cycle.`);this.setNode(p)}else p="\0";this._children.get(this._parent.get(d)).delete(d),this._parent.set(d,p),this._children.get(p).set(d,!0)}parent(d){if(this.compound){let p=this._parent.get(d);if(p!=="\0")return p}return null}children(d){return this.compound?this._children.get(d===void 0?"\0":d).keys():d===void 0?this.nodes.keys():this.hasNode(d)?[]:null}hasChildren(d){return this.compound?this._children.get(d===void 0?"\0":d).size>0:d===void 0?this.nodes.size>0:!1}predecessors(d){return this.nodes.get(d).predecessors}successors(d){return this.nodes.get(d).successors}neighbors(d){let p=this.nodes.get(d),y=p.predecessors.keys(),_=p.successors.keys(),C=new Set;for(let z of y)C.add(z);for(let z of _)C.add(z);return C}edge(d,p){return this.edges.get(this._edgeKey(this.directed,d,p))}setEdge(d,p,y,_){let C=this._edgeKey(this.directed,d,p,_),z=this.edges.get(C);if(z)z.label=y;else{!this.directed&&d>p&&([d,p]=[p,d]);let X={label:y,v:d,w:p,name:_,key:C,vNode:null,wNode:null};this.edges.set(C,X),this.setNode(d),this.setNode(p);let j=this.nodes.get(p),U=this.nodes.get(d);X.wNode=j,X.vNode=U;let re=(se,le)=>{se.set(le,(se.get(le)??0)+1)};re(j.predecessors,d),re(U.successors,p),j.in.push(X),U.out.push(X)}}removeEdge(d){let p=d.key,y=d.v,_=d.w,C=d.wNode,z=d.vNode;if(C.predecessors.has(y)){let U=C.predecessors.get(y);U===1?C.predecessors.delete(y):C.predecessors.set(y,U-1)}if(z.successors.has(_)){let U=z.successors.get(_);U===1?z.successors.delete(_):z.successors.set(_,U-1)}let X=C.in.findIndex(U=>U.key===p);X!==-1&&C.in.splice(X,1);let j=z.out.findIndex(U=>U.key===p);j!==-1&&z.out.splice(j,1),this.edges.delete(p)}_edgeKey(d,p,y,_){return!d&&p>y?_?`${y}:${p}:${_}`:`${y}:${p}:`:_?`${p}:${y}:${_}`:`${p}:${y}:`}toString(){return["[nodes]",Array.from(this.nodes.values()).map(d=>JSON.stringify(d.label)).join(`
`),"[edges]",Array.from(this.edges.values()).map(d=>JSON.stringify(d.label)).join(`
`),"[parents]",JSON.stringify(this._parent,null,2),"[children]",JSON.stringify(this._children,null,2)].join(`
`)}};var{layout:ve,Graph:nt}=Q;var Ie=6,ae=30,Ee=12,de=Ee+Ie*2;var ke="--qds-node-category-uncategorized",W={DATA:"Data",NN_LAYER:"NN Layer",ACTIVATION:"Activation",POOLING:"Pooling",NORMALIZATION:"Normalization",MATH:"Math",SHAPE:"Shape",TRANSFORM:"Transform",QUANTIZATION:"Quantization",SYNTHETIC_LAYER:"Synthetic Layer",NAMESPACE_LAYER:"Namespace Layer",DEFAULT:"Default"},Je={[W.DATA]:"--qds-node-category-data",[W.NN_LAYER]:"--qds-node-category-layer",[W.ACTIVATION]:"--qds-node-category-activation",[W.POOLING]:"--qds-node-category-pool",[W.NORMALIZATION]:"--qds-node-category-normalization",[W.MATH]:"--qds-node-category-math",[W.SHAPE]:"--qds-node-category-shape",[W.TRANSFORM]:"--qds-node-category-transform",[W.QUANTIZATION]:"--qds-node-category-quantization",[W.SYNTHETIC_LAYER]:"--qds-artificial-layer-header-1",[W.NAMESPACE_LAYER]:"--qds-layer-header-1",[W.DEFAULT]:ke},it={[W.NN_LAYER]:["conv","deconv","fc","dense","linear","lstm","gru","rnn","attention","transformer","embedding"],[W.ACTIVATION]:["relu","sigmoid","tanh","softmax","gelu","swish","elu","selu","activation"],[W.POOLING]:["pool","maxpool","avgpool"],[W.NORMALIZATION]:["norm","batchnorm","layernorm","groupnorm","instancenorm","rmsnorm","lrn"],[W.MATH]:["add","sub","mul","div","mod","pow","neg","abs","sin","cos","tan","asin","acos","atan","sinh","cosh","tanh","exp","log","sqrt","reciprocal","erf","sum","mean","max","min","reducesum","reducemean","reducemax","reducemin","reduceprod","reducel1","reducel2","reducelogsum","reducelogsumexp","reducesumsquare","equal","greater","less","greaterorequal","lessorequal","and","or","xor","not","floor","ceil","round","clip","sign","matmul","bitwiseand","bitwiseor","bitwisexor","bitwisenot","cumsum"],[W.SHAPE]:["reshape","shape","size","flatten"],[W.TRANSFORM]:["transpose","gather","slice","concat","split","cast","pad","tile","repeat","flip","squeeze","unsqueeze","expand"],[W.QUANTIZATION]:["quant","dequant","quantize","dequantize"]};function he(d){return d.children?.length>0}function ce(d){let p=1/0,y=1/0,_=-1/0,C=-1/0;for(let j of d)p=Math.min(p,j.x),_=Math.max(_,j.x+(j.width??0)),y=Math.min(y,j.y),C=Math.max(C,j.y+(j.height??0));let z=_-p,X=C-y;return{x:p,y,width:z,height:X}}var Qe={nodesep:20,ranksep:20};function ue(d,p,y){let _=d.children.map(X=>{let{width:j,height:U}=p[X.id];return{v:X.id,x:void 0,y:void 0,globalX:void 0,globalY:void 0,width:j,height:U,data:X,parentGraph:y}}),C=d.edges.map(X=>({v:X.sourceNode.id,w:X.targetNode.id,data:X,points:[],globalPoints:[],globalEdgeBounds:void 0})),z={nodes:_,edges:C};return Ae(z),z}function pe(d,p){if(d.nodes.find(y=>y.data.id===p))return d;for(let y of d.nodes)if(y.childGraph){let _=pe(y.childGraph,p);if(_)return _}}function Ae(d){ve(d.nodes,d.edges,Qe,{}),d.nodes.forEach(p=>{p.x-=p.width/2,p.y-=p.height/2,p.globalX=p.x,p.globalY=p.y}),d.edges.forEach(p=>{p.globalPoints=p.points,p.globalEdgeBounds=ce(p.globalPoints)})}function et(d){let p=d.nodes,y=d.edges.flatMap(C=>C.points),_=[...p,...y];return ce(_)}function be(d,p,y){let _=d.nodes.find(C=>C.data.id===p);if(_.expanded){let{width:C,height:z}=et(_.childGraph);_.width=C+ae*2,_.height=z+ae*2+de}else _.width=y[_.data.id].width,_.height=y[_.data.id].height;if(Ae(d),_.data.parent){let C=_.data.parent.id;_.parentGraph&&be(_.parentGraph,C,y)}}function me(d,p,y){let _=p.nodes.find(C=>C.data.id===d);!he(_.data)||_.expanded||(_.expanded=!0,_.childGraph=ue(_.data,y,p),be(p,d,y))}function Te(d,p,y){let _=p.nodes.find(C=>C.data.id===d);!he(_.data)||!_.expanded||(_.expanded=!1,delete _.childGraph,be(p,d,y))}function ge(d,p){for(let y of d.edges)y.globalPoints=y.points.map(_=>({x:_.x+p.x,y:_.y+p.y})),y.globalEdgeBounds=ce(y.globalPoints);for(let y of d.nodes)y.globalX=y.x+p.x,y.globalY=y.y+p.y,y.childGraph&&ge(y.childGraph,{x:y.globalX+ae,y:y.globalY+ae+de})}function tt(d){let{type:p,data:y}=d.data;switch(p){case 0:{let{layerNode:_,nodeDimensions:C}=y,z=ue(_,C);postMessage({rootViewGraph:z});break}case 1:{let{rootViewGraph:_,clickedNodeId:C,nodeDimensions:z}=y;we(me,_,C,z),postMessage({rootViewGraph:_});break}case 2:{let{rootViewGraph:_,clickedNodeId:C,nodeDimensions:z}=y;we(Te,_,C,z),postMessage({rootViewGraph:_});break}case 3:{let{rootViewGraph:_,ancestors:C,nodeDimensions:z}=y;for(let X of C)we(me,_,X.id,z);postMessage({rootViewGraph:_});break}}}function we(d,p,y,_){let C=pe(p,y);if(!C){console.error(`Graph cannot be updated - clicked node "${y}" was not found`);return}d(y,C,_),ge(p,{x:0,y:0})}addEventListener("message",tt);export{tt as messageHandler};
