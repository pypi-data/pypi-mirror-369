

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>upoqa.utils.model &mdash; UPOQA v1.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=d29a5c0e"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            UPOQA
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../upoqa.html">upoqa package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../upoqa.utils.html">upoqa.utils package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">UPOQA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">upoqa.utils.model</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for upoqa.utils.model</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2025, Yichuan Liu and Yingzhou Li</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Interpolation Surrogate Model</span>
<span class="sd">=============================</span>

<span class="sd">Maintain two core classes:</span>

<span class="sd">1. :class:`~upoqa.utils.model.QuadSurrogate`: Quadratic interpolation surrogate </span>
<span class="sd">   model using the derivative-free symmetric Broyden update [1]_. Serves as the </span>
<span class="sd">   element model in UPOQA.</span>

<span class="sd">2. :class:`~upoqa.utils.model.OverallSurrogate`: Overall surrogate model formed by </span>
<span class="sd">   assembling multiple element models.</span>

<span class="sd">References</span>
<span class="sd">----------</span>
<span class="sd">.. [1] Michael J. D. Powell. 2004. Least Frobenius norm updating of quadratic </span>
<span class="sd">    models that satisfy interpolation conditions. *Math. Program.* 100, 1 </span>
<span class="sd">    (May 2004), 183-215.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.linalg</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">LA</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.interp_set</span><span class="w"> </span><span class="kn">import</span> <span class="n">InterpSet</span><span class="p">,</span> <span class="n">OverallInterpSet</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.params</span><span class="w"> </span><span class="kn">import</span> <span class="n">UPOQAParameterList</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SurrogateLinAlgError&quot;</span><span class="p">,</span> <span class="s2">&quot;QuadSurrogate&quot;</span><span class="p">,</span> <span class="s2">&quot;OverallSurrogate&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="SurrogateLinAlgError">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.SurrogateLinAlgError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SurrogateLinAlgError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exception raised for linear algebra errors in the surrogate model</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ele_idx : int or None</span>
<span class="sd">        Index of the element function that caused the error.</span>
<span class="sd">        If the error is not related to a specific element, this is None.</span>
<span class="sd">    ele_name : Any or None</span>
<span class="sd">        Name of the element function that caused the error.</span>
<span class="sd">        If the error is not related to a specific element, this is None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">ele_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ele_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ele_idx</span> <span class="o">=</span> <span class="n">ele_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ele_name</span> <span class="o">=</span> <span class="n">ele_name</span></div>



<div class="viewcode-block" id="QuadSurrogate">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.QuadSurrogate">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">QuadSurrogate</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quadratic interpolation surrogate model using the *derivative-free symmetric</span>
<span class="sd">    Broyden update* [1]_. Serves as the elemental surrogate model in UPOQA.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    interp_set: :class:`~upoqa.utils.interp_set.InterpSet`</span>
<span class="sd">        The interpolation set. It must be provided in order for the interpolation</span>
<span class="sd">        surrogate model to be built based on the interpolation points.</span>
<span class="sd">    center: ndarray, optional</span>
<span class="sd">        The initial center of the surrogate model. If provided, it overrides the ``n``</span>
<span class="sd">        argument. Otherwise, the center will be set as a zero vector.</span>
<span class="sd">    n : int, optional</span>
<span class="sd">        Problem dimension. Required if ``center`` is not provided.</span>
<span class="sd">        Note that either ``n`` or ``center`` must be provided.</span>
<span class="sd">    ref_surrogate : :class:`~upoqa.utils.model.QuadSurrogate`, optional</span>
<span class="sd">        A reference surrogate model to help initialize the KKT coefficients</span>
<span class="sd">        and other cached information.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Problem dimension</span>
<span class="sd">    interp_set : :class:`~upoqa.utils.interp_set.InterpSet`</span>
<span class="sd">        The interpolation set used to build the surrogate model</span>
<span class="sd">    npt : int</span>
<span class="sd">        Number of interpolation points in the interpolation set</span>
<span class="sd">    model_center : ndarray, shape (n,)</span>
<span class="sd">        Center of the surrogate model</span>
<span class="sd">    model_cons : float</span>
<span class="sd">        Constant term of the model at the center</span>
<span class="sd">    model_grad : ndarray, shape (n,)</span>
<span class="sd">        Gradient of the model at the center</span>
<span class="sd">    model_hess_explicit : ndarray, shape (n, n)</span>
<span class="sd">        Explicit Hessian of the model</span>
<span class="sd">    model_hess_implicit : ndarray, shape (npt,)</span>
<span class="sd">        Implicit Hessian of the model</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Michael J. D. Powell. 2004. Least Frobenius norm updating of quadratic models that</span>
<span class="sd">        satisfy interpolation conditions. *Math. Program.* 100, 1 (May 2004), 183-215.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">interp_set</span><span class="p">:</span> <span class="n">InterpSet</span><span class="p">,</span>
        <span class="n">center</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ref_surrogate</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;QuadSurrogate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">center</span><span class="o">.</span><span class="n">size</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">interp_set</span><span class="o">.</span><span class="n">npt</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="p">),</span> <span class="s2">&quot;QuadSurrogate requires npt to be &lt;= (n + 1) * (n + 2) / 2.&quot;</span>
        <span class="k">assert</span> <span class="n">interp_set</span><span class="o">.</span><span class="n">npt</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;QuadSurrogate requires npt to be &gt;= n + 1.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">interp_set</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">ref_surrogate</span><span class="p">)</span>

<div class="viewcode-block" id="QuadSurrogate.reset">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.QuadSurrogate.reset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">interp_set</span><span class="p">:</span> <span class="n">InterpSet</span><span class="p">,</span>
        <span class="n">center</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">ref_surrogate</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;QuadSurrogate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the model with the given interpolation set, center point and dimension,</span>
<span class="sd">        and optionally a reference model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        interp_set: :class:`~upoqa.utils.interp_set.InterpSet`</span>
<span class="sd">            The interpolation set. It must be provided in order for the interpolation</span>
<span class="sd">            surrogate model to be built based on the interpolation points.</span>
<span class="sd">        center: ndarray</span>
<span class="sd">            The initial center of the surrogate model.</span>
<span class="sd">        ref_surrogate : :class:`~upoqa.utils.model.QuadSurrogate`, optional</span>
<span class="sd">            A reference surrogate model to help initialize the KKT coefficients</span>
<span class="sd">            and other cached information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">center</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span> <span class="o">=</span> <span class="n">interp_set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">npt</span>

        <span class="c1"># surrogate model coeff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_hess_explicit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_hess_implicit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">interp_set</span><span class="o">.</span><span class="n">npt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_cons</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_center</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">center</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>
            <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">ref_surrogate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if ref_surrogate is provided, initialize KKT coefficients to match ref_surrogate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">ref_surrogate</span><span class="o">.</span><span class="n">_KKT_R</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">ref_surrogate</span><span class="o">.</span><span class="n">_KKT_B</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_Y_shift</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ref_surrogate</span><span class="o">.</span><span class="n">cached_Y_shift</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="p">)</span>  <span class="c1"># interp set points - center</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_x_anchor</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">ref_surrogate</span><span class="o">.</span><span class="n">cached_x_anchor</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_x_anchor_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">ref_surrogate</span><span class="o">.</span><span class="n">cached_x_anchor_idx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">ref_surrogate</span><span class="o">.</span><span class="n">_negative_s_idx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_surrogate_coeff</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># otherwise, initialize all KKT coefficients to zero and update them later</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_Y_shift</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">get_interp_set</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_center</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_x_anchor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">get_anchor</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_x_anchor_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">x_anchor_idx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_KKT_and_model_coeff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">last_init_step_size</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_init_KKT_and_model_coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the KKT and model coefficients based on the interpolation set and</span>
<span class="sd">        the given step size. Detailed explanations can be found around formula (2.10)</span>
<span class="sd">        of [1]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        step_size : float, optional</span>
<span class="sd">            The step size used for initializing the KKT and model coefficients. If not</span>
<span class="sd">            provided, the initialization step size from the interpolation set is used.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Michael J. D. Powell. 2009. The BOBYQA algorithm for bound constrained</span>
<span class="sd">            optimization without derivatives. *Cambridge NA Report NA2009/06,</span>
<span class="sd">            University of Cambridge, Cambridge* 26 (2009): 26-46.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">init_step_size</span> <span class="o">=</span> <span class="n">step_size</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">init_step_size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">xpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">):</span>
            <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
                <span class="n">xpt</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">init_step_size</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">init_step_size</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">init_step_size</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">init_step_size</span><span class="o">**</span><span class="mf">2.0</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
                <span class="n">xpt</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">init_step_size</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">/</span> <span class="n">xpt</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">init_step_size</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">init_step_size</span><span class="o">**</span><span class="mf">2.0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">shift</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">shift</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">init_step_size</span><span class="o">**</span><span class="mf">2.0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">init_step_size</span><span class="o">**</span><span class="mf">2.0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">init_step_size</span><span class="o">**</span><span class="mf">2.0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">init_step_size</span><span class="o">**</span><span class="mf">2.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_surrogate_coeff</span><span class="p">()</span>

<div class="viewcode-block" id="QuadSurrogate.inv_kkt_matrix_dot">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.QuadSurrogate.inv_kkt_matrix_dot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">inv_kkt_matrix_dot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">w_star</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute inv(W) @ x, where W is the coefficient matrix of the KKT equation generated</span>
<span class="sd">        by the derivative-free symmetric Broyden update [1]_, and return the vector formed</span>
<span class="sd">        by the first ``npt`` and last ``n`` dimensions of the result.</span>

<span class="sd">        In the multiplication, we can safely ignore the ``(npt + 1)``-th dimension of ``x``.</span>
<span class="sd">        Therefore, the input vector ``x`` only needs to include the first ``npt`` and the last</span>
<span class="sd">        ``n`` elements, instead of the full ``(npt + 1 + n)``-dimensional vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray, shape (npt + n,)</span>
<span class="sd">            The vector to be dotted with the inverse of the KKT matrix.</span>
<span class="sd">        w_star : ndarray, shape (npt + n,), optional</span>
<span class="sd">            The auxiliary vector to assist in the calculation. It is formed by</span>

<span class="sd">                ``[0.5 * ((yi - center) @ (Y - center).T) ** 2, yi - center]``,</span>

<span class="sd">            where ``Y`` is of shape ``(npt, n)`` which represents the interpolation points.</span>
<span class="sd">            ``yi`` can be any point in the interpolation set, and is ``x_anchor`` by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, shape (npt + n,)</span>
<span class="sd">            The vector formed by the first ``npt`` and last ``n`` dimensions of the result.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Michael J. D. Powell. 2004. Least Frobenius norm updating of quadratic</span>
<span class="sd">            models that satisfy interpolation conditions. *Math. Program.* 100, 1</span>
<span class="sd">            (May 2004), 183-215.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># assert x.size == self.npt + self.n</span>
        <span class="n">w_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_w</span><span class="p">()</span> <span class="k">if</span> <span class="n">w_star</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">w_star</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
        <span class="n">Zx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="o">.</span><span class="n">T</span>
        <span class="n">tmp</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tmp</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">]</span>
        <span class="n">Zx</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span>
        <span class="n">Zx</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="p">:]</span> <span class="o">@</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Zx</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span> <span class="o">-=</span> <span class="n">w_star</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="p">:]</span> <span class="o">@</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">w_star</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="o">.</span><span class="n">T</span>
        <span class="n">tmp</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tmp</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">]</span>
        <span class="n">Zx</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span> <span class="o">-=</span> <span class="n">tmp</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span>
        <span class="n">Zx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">w_star</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span>
        <span class="n">Zx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cached_x_anchor_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">Zx</span></div>


<div class="viewcode-block" id="QuadSurrogate.inv_kkt_matrix_partial_dot">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.QuadSurrogate.inv_kkt_matrix_partial_dot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">inv_kkt_matrix_partial_dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute inv(W) @ x, where W is the coefficient matrix of the KKT equation</span>
<span class="sd">        generated by the derivative-free symmetric Broyden update [1]_, and return the</span>
<span class="sd">        vector formed by the first ``npt`` and last ``n`` dimensions of the result.</span>

<span class="sd">        Unlike ``self.inv_kkt_matrix_dot(x)``, this method assumes that ``x`` is zero for</span>
<span class="sd">        indices ``[npt:]``, allowing for a simplified calculation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray, shape (npt + n,)</span>
<span class="sd">            The vector to be dotted with the inverse of the KKT matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, shape (npt + n,)</span>
<span class="sd">            The vector formed by the first ``npt`` and last ``n`` dimensions of the result.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Michael J. D. Powell. 2004. Least Frobenius norm updating of quadratic</span>
<span class="sd">            models that satisfy interpolation conditions. *Math. Program.* 100, 1</span>
<span class="sd">            (May 2004), 183-215.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="o">.</span><span class="n">T</span>
        <span class="n">tmp</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tmp</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">tmp</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">,</span> <span class="n">x</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]))</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="o">-</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>
            <span class="n">tmp</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tmp</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">tmp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_beta</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">w</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">Zw</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">x_shift</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">w_star</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">w_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_w</span><span class="p">()</span> <span class="k">if</span> <span class="n">w_star</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">w_star</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_shift</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x_shift</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="o">-</span> <span class="n">w</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cached_x_anchor_idx</span><span class="p">]</span>
            <span class="o">-</span> <span class="n">w</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Zw</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">w_star</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Zw</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_shift</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">x_shift</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_x_anchor</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_center</span>
            <span class="k">if</span> <span class="n">x_shift</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">x_shift</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">w</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x_shift</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_Y_shift</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">w</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">x_shift</span>
        <span class="k">return</span> <span class="n">w</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<div class="viewcode-block" id="QuadSurrogate.get_determinant_ratio">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.QuadSurrogate.get_determinant_ratio">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_determinant_ratio</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="nb">float</span><span class="p">,</span>
        <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate key intermediate quantities (``alpha``, ``beta``, ``tau``, ``sigma``) for</span>
<span class="sd">        updating the inverse KKT matrix in the derivative-free symmetric Broyden</span>
<span class="sd">        update [1]_. These quantities are defined in [2]_, where ``sigma`` (the denominator</span>
<span class="sd">        in the update equation) represents the ratio of the determinant of the inverse</span>
<span class="sd">        KKT matrix before and after update.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_new : ndarray, shape (n,)</span>
<span class="sd">            New point to be added to the interpolation set (not yet added).</span>
<span class="sd">        idx : int, optional</span>
<span class="sd">            Index of the interpolation point to be replaced by ``x_new``.</span>
<span class="sd">            If provided, returns scalar values at this index; otherwise returns full arrays.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        alpha : ndarray or float</span>
<span class="sd">            Quantity ``alpha``. Returns ``alpha[idx]`` if ``idx`` is provided.</span>
<span class="sd">        beta : float</span>
<span class="sd">            Quantity ``beta``.</span>
<span class="sd">        tau : ndarray or float</span>
<span class="sd">            Quantity ``tau``. Returns ``tau[idx]`` if ``idx`` is provided.</span>
<span class="sd">        sigma : ndarray or float</span>
<span class="sd">            Quantity ``sigma``. Returns ``sigma[idx]`` if ``idx`` is provided.</span>
<span class="sd">        ndarray</span>
<span class="sd">            Result of ``self.inv_kkt_matrix_dot(w)``, where:</span>
<span class="sd">            ``w = [0.5 * ((x_new - center) @ (Y - center).T) ** 2, x_new - center]``,</span>
<span class="sd">            where ``Y`` is of shape ``(npt, n)`` which represents the interpolation points.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Michael J. D. Powell. 2004. Least Frobenius norm updating of quadratic</span>
<span class="sd">            models that satisfy interpolation conditions. *Math. Program.* 100, 1</span>
<span class="sd">            (May 2004), 183-215.</span>

<span class="sd">        .. [2] Michael J. D. Powell. 2004. On updating the inverse of a KKT matrix.</span>
<span class="sd">            *Numerical Linear Algebra and Optimization, ed. Ya-xiang Yuan, Science Press</span>
<span class="sd">            (Beijing)* (2004): 56-78.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_new_shift</span> <span class="o">=</span> <span class="n">x_new</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_center</span>
        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_w</span><span class="p">(</span><span class="n">x_new_shift</span><span class="p">)</span>
        <span class="n">w_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_w</span><span class="p">()</span>

        <span class="n">Zw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_kkt_matrix_dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">w_star</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_beta</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">Zw</span><span class="p">,</span> <span class="n">x_new_shift</span><span class="p">,</span> <span class="n">w_star</span><span class="o">=</span><span class="n">w_star</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_alpha</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">Zw</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">Zw</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">beta</span> <span class="o">+</span> <span class="n">tau</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">Zw</span></div>


<div class="viewcode-block" id="QuadSurrogate.update">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.QuadSurrogate.update">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cached_kkt_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the KKT and model coefficients using the method detailed in [1]_, [2]_ and [3]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cached_kkt_info : tuple, optional</span>
<span class="sd">            If not None, it should be the cached output of ``self.get_determinant_ratio(x_new)``,</span>
<span class="sd">            where ``x_new`` denotes the new point just added into the interpolation set.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Michael J. D. Powell. 2004. Least Frobenius norm updating of quadratic models</span>
<span class="sd">            that satisfy interpolation conditions. *Math. Program.* 100, 1 (May 2004), 183-215.</span>

<span class="sd">        .. [2] Michael J. D. Powell. 2004. On updating the inverse of a KKT matrix. *Numerical</span>
<span class="sd">            Linear Algebra and Optimization, ed. Ya-xiang Yuan, Science Press (Beijing)*</span>
<span class="sd">            (2004): 56-78.</span>

<span class="sd">        .. [3] Michael J. D. Powell. 2006. *The NEWUOA Software for Unconstrained Optimization</span>
<span class="sd">            without Derivatives*. Springer US, Boston, MA, 255-297.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">last_update_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">last_update_idx</span>
        <span class="n">x_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">get_interp_set</span><span class="p">(</span><span class="n">last_update_idx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">deleted_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">just_deleted_point</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_KKT_coeff</span><span class="p">(</span><span class="n">x_new</span><span class="p">,</span> <span class="n">last_update_idx</span><span class="p">,</span> <span class="n">cached_kkt_info</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_surrogate_coeff</span><span class="p">(</span><span class="n">deleted_x</span><span class="p">,</span> <span class="n">last_update_idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cached_x_anchor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">get_anchor</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cached_x_anchor_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">x_anchor_idx</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_update_KKT_coeff</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x_new</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">cached_kkt_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the KKT coefficients using the method detailed in [1]_, [2]_ and [3]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_new : ndarray, shape (n,)</span>
<span class="sd">            The new point which was just added into the interpolation set.</span>
<span class="sd">        idx : int</span>
<span class="sd">            The index in the interpolation set where ``x_new`` was added.</span>
<span class="sd">        cached_kkt_info : tuple, optional</span>
<span class="sd">            If not None, it should be the cached output of ``self.get_determinant_ratio(x_new)``,</span>
<span class="sd">            where ``x_new`` denotes the new point just added into the interpolation set.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The implementation here largely references that in COBYQA [4]_.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Michael J. D. Powell. 2004. Least Frobenius norm updating of quadratic</span>
<span class="sd">            models that satisfy interpolation conditions. *Math. Program.* 100, 1</span>
<span class="sd">            (May 2004), 183-215.</span>

<span class="sd">        .. [2] Michael J. D. Powell. 2004. On updating the inverse of a KKT matrix.</span>
<span class="sd">            *Numerical Linear Algebra and Optimization, ed. Ya-xiang Yuan, Science Press</span>
<span class="sd">            (Beijing)* (2004): 56-78.</span>

<span class="sd">        .. [3] Michael J. D. Powell. 2006. *The NEWUOA Software for Unconstrained Optimization</span>
<span class="sd">            without Derivatives*. Springer US, Boston, MA, 255-297.</span>

<span class="sd">        .. [4] Tom M. Ragonneau. *Model-Based Derivative-Free Optimization Methods</span>
<span class="sd">            and Software*. PhD thesis, Department of Applied Mathematics, The Hong</span>
<span class="sd">            Kong Polytechnic University, Hong Kong, China, 2022. URL:</span>
<span class="sd">            https://theses.lib.polyu.edu.hk/handle/200/12294.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">householder_transform</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Perform an in-place Householder transformation on ``mat`` to make the ``idx``-th</span>
<span class="sd">            column align with the first standard basis vector ``e_1``.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">vec_norm</span> <span class="o">=</span> <span class="n">LA</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vec_norm</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">vec_norm</span> <span class="k">if</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="n">vec_norm</span>
                <span class="n">mat</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">vec</span> <span class="o">@</span> <span class="n">mat</span><span class="p">)</span> <span class="o">/</span> <span class="n">vec</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>

        <span class="c1"># Perform Householder transformation on _KKT_R</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">householder_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">],</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">householder_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span> <span class="p">:],</span> <span class="n">idx</span><span class="p">)</span>

        <span class="c1"># Prepare alpha, beta, tau, sigma, and Zw</span>
        <span class="k">if</span> <span class="n">cached_kkt_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">Zw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_determinant_ratio</span><span class="p">(</span><span class="n">x_new</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">Zw</span> <span class="o">=</span> <span class="n">cached_kkt_info</span>
            <span class="n">alpha</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">tau</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">b_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">),</span> <span class="n">initial</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">z_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">),</span> <span class="n">initial</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">b_max</span><span class="p">,</span> <span class="n">z_max</span><span class="p">):</span>
            <span class="c1"># The denominator of the updating formula is too small to safely</span>
            <span class="c1"># divide the coefficients of the KKT matrix of interpolation.</span>
            <span class="c1"># Theoretically, the value of abs(sigma) is always positive, and</span>
            <span class="c1"># becomes small only for ill-conditioned problems.</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;The denominator of the updating formula is zero&quot;</span><span class="p">)</span>

        <span class="c1"># Update _KKT_B first</span>
        <span class="n">_KKT_B_on_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">Ze_ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">],</span> <span class="n">_KKT_B_on_idx</span><span class="p">))</span>
        <span class="n">Zw_minus_e_ell</span> <span class="o">=</span> <span class="n">Zw</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">Zw_minus_e_ell</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">temp_vec1</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">Zw</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">_KKT_B_on_idx</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma</span>
        <span class="n">temp_vec2</span> <span class="o">=</span> <span class="p">(</span><span class="n">tau</span> <span class="o">*</span> <span class="n">Zw</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">_KKT_B_on_idx</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span>
            <span class="n">Zw_minus_e_ell</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">],</span> <span class="n">temp_vec1</span>
        <span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">Ze_ell</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">],</span> <span class="n">temp_vec2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">Zw_minus_e_ell</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="p">:],</span> <span class="n">temp_vec1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">Ze_ell</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="p">:],</span> <span class="n">temp_vec2</span><span class="p">)</span>

        <span class="c1"># Then update _KKT_R</span>
        <span class="n">jdz</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">jdz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">tau</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">Zw_minus_e_ell</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span>
            <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sigma</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scala</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="k">if</span> <span class="n">jdz</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">scalb</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">jdz</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">jdz</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="n">kdz</span> <span class="o">=</span> <span class="n">jdz</span> <span class="k">if</span> <span class="n">beta</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">jdz</span> <span class="o">-=</span> <span class="n">kdz</span>
            <span class="n">tempb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">jdz</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">tau</span> <span class="o">/</span> <span class="n">sigma</span>
            <span class="n">tmp1</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">jdz</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="n">tau</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">kdz</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">tau</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">kdz</span><span class="p">]</span>
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">jdz</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">Zw_minus_e_ell</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">kdz</span><span class="p">]</span> <span class="o">*=</span> <span class="n">tmp1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">jdz</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">jdz</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">beta</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">scala</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">scalb</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">]</span>
            <span class="p">)</span> <span class="o">+</span> <span class="n">tempb</span> <span class="o">*</span> <span class="n">Zw_minus_e_ell</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span><span class="n">jdz</span><span class="p">]</span> <span class="o">*=</span> <span class="n">tmp1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">sigma</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beta</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="c1"># If sigma &lt;= 0 and beta &lt; 0, the positive-definite property is broken.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="p">[</span>
                        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="p">]</span>

<div class="viewcode-block" id="QuadSurrogate.shift_center_to">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.QuadSurrogate.shift_center_to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shift_center_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift the model center to ``x``, then update the KKT and model coefficients.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray, shape (n,)</span>
<span class="sd">            The new model center.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The computational cost is O(npt^3) with BLAS-3 operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_center</span>

        <span class="c1"># Prepare intermediate variables</span>
        <span class="n">Phi_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_Y_shift</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">step</span>
        <span class="n">Psi_T</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span> <span class="o">@</span> <span class="n">Phi_T</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">Phi_T</span> <span class="o">+</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">step</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span>
        <span class="n">R_T_Psi_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span> <span class="o">@</span> <span class="n">Psi_T</span>
        <span class="n">Xi_Psi_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Psi_T</span>
        <span class="n">S_R_T_Psi_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">R_T_Psi_T</span><span class="p">)</span>
        <span class="n">S_R_T_Psi_T</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S_R_T_Psi_T</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_s_idx</span><span class="p">]</span>
        <span class="n">Omega_Psi_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_R</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">S_R_T_Psi_T</span>
        <span class="n">Psi_Omega_Psi_T</span> <span class="o">=</span> <span class="n">R_T_Psi_T</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">S_R_T_Psi_T</span>

        <span class="c1"># Update _KKT_B</span>
        <span class="c1"># Note: _KKT_R remains invariant when shifting the model center.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Omega_Psi_T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_KKT_B</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">Xi_Psi_T</span> <span class="o">+</span> <span class="n">Xi_Psi_T</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">Psi_Omega_Psi_T</span>

        <span class="c1"># Update surrogate coefficients</span>
        <span class="n">center_shift</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_center</span>
        <span class="n">Hess_center_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hess_operator</span><span class="p">(</span><span class="n">center_shift</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_cons</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_cons</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_grad</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">center_shift</span><span class="p">)</span>
            <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">center_shift</span> <span class="o">@</span> <span class="n">Hess_center_shift</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_grad</span> <span class="o">=</span> <span class="n">Hess_center_shift</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_grad</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_center</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Phi_T</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_hess_implicit</span><span class="p">)</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_hess_explicit</span> <span class="o">+=</span> <span class="n">temp</span> <span class="o">+</span> <span class="n">temp</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cached_Y_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_Y_shift</span> <span class="o">-</span> <span class="n">step</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_update_surrogate_coeff</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">deleted_x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assuming the KKT coefficients have been updated, this function updates the model</span>
<span class="sd">        coefficients based on the updated KKT coefficients.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deleted_x : ndarray, shape (n,), optional</span>
<span class="sd">            The old interpolation point that was replaced with a new point at the index</span>
<span class="sd">            ``idx``. Both ``deleted_x`` and ``idx`` should be None if the model is being</span>
<span class="sd">            updated for the first time after being established.</span>
<span class="sd">        idx : int, optional</span>
<span class="sd">            The index where the old interpolation point ``deleted_x`` was replaced with a</span>
<span class="sd">            new point. Both ``deleted_x`` and ``idx`` should be None if the model is being</span>
<span class="sd">            updated for the first time after being established.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Y_new</span><span class="p">,</span> <span class="n">f_Y_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">get_interp_set</span><span class="p">()</span>
        <span class="n">f_Y_shift</span> <span class="o">=</span> <span class="n">f_Y_new</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fun_eval</span><span class="p">(</span><span class="n">Y_new</span><span class="p">)</span>
        <span class="n">model_lambda</span><span class="p">,</span> <span class="n">model_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_interpolation_KKT</span><span class="p">(</span><span class="n">f_Y_shift</span><span class="o">=</span><span class="n">f_Y_shift</span><span class="p">)</span>
        <span class="n">model_hess_explicit_p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_hess_explicit</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">model_hess_implicit_p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_hess_implicit</span> <span class="o">+</span> <span class="n">model_lambda</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># assert deleted_x is not None</span>
            <span class="n">deleted_x</span> <span class="o">=</span> <span class="n">deleted_x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_center</span>
            <span class="n">model_hess_explicit_p1</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_hess_implicit</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span>
                <span class="n">deleted_x</span><span class="p">,</span> <span class="n">deleted_x</span>
            <span class="p">)</span>
            <span class="n">model_hess_implicit_p1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">model_lambda</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">model_grad_p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grad_eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_center</span><span class="p">)</span> <span class="o">+</span> <span class="n">model_g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_hess_explicit</span> <span class="o">=</span> <span class="n">model_hess_explicit_p1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_hess_implicit</span> <span class="o">=</span> <span class="n">model_hess_implicit_p1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_grad</span> <span class="o">=</span> <span class="n">model_grad_p1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cached_Y_shift</span> <span class="o">=</span> <span class="n">Y_new</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_cons</span> <span class="o">+=</span> <span class="n">f_Y_new</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">x_anchor_idx</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fun_eval</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">x_anchor</span>
        <span class="p">)</span>

<div class="viewcode-block" id="QuadSurrogate.solve_interpolation_KKT">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.QuadSurrogate.solve_interpolation_KKT">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_interpolation_KKT</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">f_Y_shift</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the interpolation set, solves the first-order KKT optimality conditions</span>
<span class="sd">        for the derivative-free symmetric Broyden update subproblem and returns the solution:</span>
<span class="sd">        the Lagrange multipliers and the gradient update term.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        f_Y_shift : ndarray, shape (npt,)</span>
<span class="sd">            Represents ``fun(Y) - surrogate(Y)``, where ``Y`` denotes the interpolation points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lambda : ndarray, shape (npt,)</span>
<span class="sd">            The Lagrange multipliers.</span>
<span class="sd">        g : ndarray, shape (n,)</span>
<span class="sd">            The gradient update term.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_kkt_matrix_partial_dot</span><span class="p">(</span><span class="n">f_Y_shift</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">npt</span><span class="p">],</span> <span class="n">coeff</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">npt</span> <span class="p">:]</span></div>


<div class="viewcode-block" id="QuadSurrogate.reset_surrogate_coeff">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.QuadSurrogate.reset_surrogate_coeff">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset_surrogate_coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset all surrogate model coefficients to zero values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_hess_explicit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_hess_implicit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">npt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_cons</span> <span class="o">=</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="QuadSurrogate.reinit">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.QuadSurrogate.reinit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reinit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reinitialize the surrogate model by first resetting and then updating the coefficients.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_surrogate_coeff</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_surrogate_coeff</span><span class="p">()</span></div>


<div class="viewcode-block" id="QuadSurrogate.alt_grad_eval">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.QuadSurrogate.alt_grad_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">alt_grad_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate gradient of a newly-instantiated surrogate model at point ``x``.</span>

<span class="sd">        Conceptually equivalent to:</span>
<span class="sd">        </span>
<span class="sd">        1. Creating a new surrogate model with current interpolation set</span>
<span class="sd">        2. Updating its coefficients from zero</span>
<span class="sd">        3. Returning its gradient at ``x``</span>

<span class="sd">        Avoids actual model reconstruction by leveraging KKT solution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray, shape (n,)</span>
<span class="sd">            Evaluation point for gradient calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        g : ndarray</span>
<span class="sd">            Gradient vector of the conceptual surrogate model at ``x``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">f_Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">get_interp_set</span><span class="p">()</span>
        <span class="n">model_lambda</span><span class="p">,</span> <span class="n">model_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve_interpolation_KKT</span><span class="p">(</span><span class="n">f_Y_shift</span><span class="o">=</span><span class="n">f_Y</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_center</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_Y_shift</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">model_lambda</span>
        <span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_Y_shift</span> <span class="o">+</span> <span class="n">model_g</span></div>


<div class="viewcode-block" id="QuadSurrogate.fun_eval">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.QuadSurrogate.fun_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fun_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the surrogate model at given point(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray, shape (n,) or ndarray, shape (n_samples, n)</span>
<span class="sd">            Evaluation point(s). Can be a single point (1D) or batch of points (2D).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fval : float or ndarray, shape (n_samples,)</span>
<span class="sd">            Model value(s). Scalar for single point input, array of shape (n_samples,)</span>
<span class="sd">            for multiple points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X_shift</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_center</span>
        <span class="k">if</span> <span class="n">X_shift</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">X_shift</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">hess_operator</span><span class="p">(</span><span class="n">X_shift</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_grad</span><span class="p">)</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_cons</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hess_operator</span><span class="p">(</span><span class="n">X_shift</span><span class="p">)</span> <span class="o">@</span> <span class="n">X_shift</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">X_shift</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_grad</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_cons</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">value</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="k">else</span> <span class="n">value</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="QuadSurrogate.grad_eval">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.QuadSurrogate.grad_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">grad_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the gradient vector(s) of the surrogate model at given point(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray, shape (n,) or ndarray, shape (n_samples, n)</span>
<span class="sd">            Evaluation point(s). Can be a single point (1D) or batch of points (2D).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        g : ndarray, shape (n, ) or ndarray, shape (n_samples, n)</span>
<span class="sd">            Gradient vector(s). Shape (n,) for single point, (n_samples, n) for</span>
<span class="sd">            multiple points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hess_operator</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_center</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_grad</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">model_hess</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Full Hessian matrix of the surrogate model&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cached_Y_shift</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_hess_implicit</span>
        <span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_Y_shift</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_hess_explicit</span>

<div class="viewcode-block" id="QuadSurrogate.hess_eval">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.QuadSurrogate.hess_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">hess_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the full Hessian matrix of the surrogate model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        H : ndarray, shape (n, n)</span>
<span class="sd">            Hessian matrix (same as ``model_hess`` property).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_hess</span></div>


<div class="viewcode-block" id="QuadSurrogate.hess_operator">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.QuadSurrogate.hess_operator">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">hess_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">V</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Hessian-vector product(s) for the surrogate model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        V : ndarray, shape (n, ) or ndarray, shape (n_samples, n)</span>
<span class="sd">            Input vector(s). Single vector (1D) or batch of vectors (2D).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        HV : ndarray, shape (n, ) or ndarray, shape (n_samples, n)</span>
<span class="sd">            Hessian-vector product(s). Shape (n,) for single input vector,</span>
<span class="sd">            (n_samples, n) for multiple vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">V</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_Y_shift</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_hess_implicit</span>
        <span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">cached_Y_shift</span> <span class="o">+</span> <span class="n">V</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_hess_explicit</span>
        <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
</div>



<div class="viewcode-block" id="OverallSurrogate">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.OverallSurrogate">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">OverallSurrogate</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Overall surrogate model formed by assembling multiple elemental surrogate models.</span>

<span class="sd">    Represent a full-system surrogate as a sum of component models, each defined on</span>
<span class="sd">    a subspace of the full design space.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Problem dimension</span>
<span class="sd">    interp_set : :class:`~upoqa.utils.interp_set.OverallInterpSet`</span>
<span class="sd">        Interpolation set for the overall surrogate model</span>
<span class="sd">    proj_onto_ele : callable</span>
<span class="sd">        Projection function mapping full-space points to element subspaces:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            (full_point: ndarray, element_name: Any) -&gt; element_point: ndarray</span>

<span class="sd">        For example, ``proj_onto_ele([1.0, 2.0], &quot;f_1&quot;)`` yields ``[1.0,]``, where</span>
<span class="sd">        ``&quot;f_1&quot;`` denotes a function that depends only on the first variable of ``x``.</span>
<span class="sd">    coords : list of 1D arrays</span>
<span class="sd">        Variable indices for each element&#39;s subspace (parallel to ``ele_names``).</span>
<span class="sd">    ele_models : list</span>
<span class="sd">        List of elemental surrogate models</span>
<span class="sd">    xforms : list</span>
<span class="sd">        Transformations :math:`h_1, \ldots, h_q` applied to element function outputs</span>
<span class="sd">    weights : list</span>
<span class="sd">        Weights :math:`w_1, \ldots, w_q` for each element in the model</span>
<span class="sd">    extra_fun : list</span>
<span class="sd">        The white-box component :math:`f_0` of the objective function, which is a list of</span>
<span class="sd">        length 3 containing callables to evaluate the function value, gradient, and Hessian.</span>
<span class="sd">    params : :class:`~upoqa.utils.params.UPOQAParameterList`</span>
<span class="sd">        Parameter list used for the algorithm</span>
<span class="sd">    ele_names : list</span>
<span class="sd">        List containing the names of all elements in order</span>
<span class="sd">    model_center : ndarray, shape (n,)</span>
<span class="sd">        Center of the surrogate model</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">interp_set</span><span class="p">:</span> <span class="n">OverallInterpSet</span><span class="p">,</span>
        <span class="n">proj_onto_ele</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">coords</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
        <span class="n">ele_models</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">QuadSurrogate</span><span class="p">],</span>
        <span class="n">extra_fun</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">float</span><span class="p">]],</span>
        <span class="n">ele_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">UPOQAParameterList</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span> <span class="o">=</span> <span class="n">interp_set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ele_models</span> <span class="o">=</span> <span class="n">ele_models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ele_names</span> <span class="o">=</span> <span class="n">ele_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ele_idxs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ele_names</span><span class="p">)))</span>

        <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">proj_onto_ele</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_onto_ele</span> <span class="o">=</span> <span class="n">proj_onto_ele</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp_set</span><span class="o">.</span><span class="n">x_opt</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">extra_fun</span> <span class="o">=</span> <span class="n">extra_fun</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xforms</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ele_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QuadSurrogate</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_models</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span>

<div class="viewcode-block" id="OverallSurrogate.set_weights">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.OverallSurrogate.set_weights">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the weights for the elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        - weights : ndarray</span>
<span class="sd">            The weights to assign to each element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span></div>


<div class="viewcode-block" id="OverallSurrogate.set_xforms">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.OverallSurrogate.set_xforms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_xforms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xforms</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set transformation functions for the elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xforms : list</span>
<span class="sd">            Transformation functions to apply to each element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xforms</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">xforms</span><span class="p">)</span></div>


<div class="viewcode-block" id="OverallSurrogate.update_weights">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.OverallSurrogate.update_weights">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_weights</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">weights</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
        <span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the weights for the elements, handling both list and dictionary inputs.</span>

<span class="sd">        If ``weights`` is a dictionary, it maps element names to weight values.</span>
<span class="sd">        Missing elements retain their current weights.</span>

<span class="sd">        This method should only be called by </span>
<span class="sd">        :meth:`~upoqa.utils.manager.UPOQAManager.update_weights()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weights : list or dict or ndarray</span>
<span class="sd">            New weights for model elements. Can be a 1D array, or a list of weights</span>
<span class="sd">            for all elements or a dictionary mapping element names to weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">weights_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ele_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_idxs</span><span class="p">:</span>
                <span class="n">ele_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_names</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ele_name</span> <span class="ow">in</span> <span class="n">weights</span><span class="p">:</span>
                    <span class="n">weights_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">ele_name</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">weights_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">weights_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_weights</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span></div>


<div class="viewcode-block" id="OverallSurrogate.update_xforms">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.OverallSurrogate.update_xforms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_xforms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xforms</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update transformation functions with input validation.</span>
<span class="sd">        This method should only be called by </span>
<span class="sd">        :meth:`~upoqa.utils.manager.UPOQAManager.update_xforms()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xforms : list</span>
<span class="sd">            List of updated transformation lists for all elements. each transformation</span>
<span class="sd">            list should contain exactly 3 callables: ``[function, gradient, hessian]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xforms</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">xforms_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ele_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_idxs</span><span class="p">:</span>
                <span class="n">ele_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_names</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ele_name</span> <span class="ow">in</span> <span class="n">xforms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">xforms</span><span class="p">[</span><span class="n">ele_name</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                            <span class="n">xforms</span><span class="p">[</span><span class="n">ele_name</span><span class="p">],</span> <span class="nb">list</span>
                        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;xforms[</span><span class="si">{</span><span class="n">ele_name</span><span class="si">}</span><span class="s2">] should be a list, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">xforms</span><span class="p">[</span><span class="n">ele_name</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="k">assert</span> <span class="p">(</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">xforms</span><span class="p">[</span><span class="n">ele_name</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span>
                        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;xforms[</span><span class="si">{</span><span class="n">ele_name</span><span class="si">}</span><span class="s2">] should be a list of length 3, but got length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">xforms</span><span class="p">[</span><span class="n">ele_name</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
                            <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">Callable</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">xforms</span><span class="p">[</span><span class="n">ele_name</span><span class="p">]]</span>
                        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;xforms[</span><span class="si">{</span><span class="n">ele_name</span><span class="si">}</span><span class="s2">] should contain only callable functions.&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xforms</span><span class="p">[</span><span class="n">ele_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xforms</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span>
                <span class="n">xforms_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xforms</span><span class="p">[</span><span class="n">ele_name</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_xforms</span><span class="p">(</span><span class="n">xforms_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_xforms</span><span class="p">(</span><span class="n">xforms</span><span class="p">)</span></div>


<div class="viewcode-block" id="OverallSurrogate.shift_center_to">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.OverallSurrogate.shift_center_to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shift_center_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift the model center to a new point ``x``.</span>
<span class="sd">        Note that this does not change the centers of the element models.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray</span>
<span class="sd">            The new center point for the overall surrogate model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_center</span> <span class="o">=</span> <span class="n">x</span></div>


<div class="viewcode-block" id="OverallSurrogate.update">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.OverallSurrogate.update">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">want_update</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span>
        <span class="n">cached_KKT_info_eles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span>
            <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the element models based on the provided update flags and cached KKT</span>
<span class="sd">        information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        want_update : list of bool</span>
<span class="sd">            A list of flags indicating whether each element model should be updated.</span>
<span class="sd">        cached_KKT_info_eles : list of tuples, optional</span>
<span class="sd">            List of cached outputs of ``ele_surrogate.get_determinant_ratio(x_ele_new)``</span>
<span class="sd">            for each element model ``ele_surrogate``, where ``x_ele_new`` denotes the new</span>
<span class="sd">            point just added into the corresponding elemental interpolation set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ele_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_idxs</span><span class="p">:</span>
            <span class="n">ele_surrogate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_models</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">want_update</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ele_surrogate</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="n">cached_kkt_info</span><span class="o">=</span><span class="p">(</span>
                            <span class="n">cached_KKT_info_eles</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">cached_KKT_info_eles</span>
                            <span class="k">else</span> <span class="kc">None</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="n">LA</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">,</span> <span class="ne">ZeroDivisionError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SurrogateLinAlgError</span><span class="p">(</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">ele_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ele_names</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">],</span> <span class="n">ele_idx</span><span class="o">=</span><span class="n">ele_idx</span>
                    <span class="p">)</span></div>


<div class="viewcode-block" id="OverallSurrogate.fun_eval">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.OverallSurrogate.fun_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fun_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the overall surrogate model at given point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray, shape (n,)</span>
<span class="sd">            Evaluation point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fval : float</span>
<span class="sd">            The model value of the overall surrogate model at the point ``x``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extra_fun</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">x</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ele_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_idxs</span><span class="p">:</span>
            <span class="n">ele_surrogate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_models</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span>
            <span class="n">x_ele</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_onto_ele</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ele_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xforms</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">value_ele</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">xforms</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">](</span>
                    <span class="n">ele_surrogate</span><span class="o">.</span><span class="n">fun_eval</span><span class="p">(</span><span class="n">x_ele</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value_ele</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">ele_surrogate</span><span class="o">.</span><span class="n">fun_eval</span><span class="p">(</span><span class="n">x_ele</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">(</span><span class="s2">&quot;debug.check_nan_fval&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value_ele</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;(element </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ele_names</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span><span class="si">}</span><span class="s2">) NaN encountered in the return value&quot;</span>
                    <span class="s2">&quot; of the surrogate function. &quot;</span>
                    <span class="s2">&quot;This may be caused by some numerical error or matrix singularity. &quot;</span>
                <span class="p">)</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="n">value_ele</span>
        <span class="k">return</span> <span class="n">value</span></div>


<div class="viewcode-block" id="OverallSurrogate.grad_eval">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.OverallSurrogate.grad_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">grad_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the gradient vector of the overall surrogate model at given point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray, shape (n,)</span>
<span class="sd">            Evaluation point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        g : ndarray, shape (n, )</span>
<span class="sd">            The gradient vector of the overall surrogate model at the point ``x``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extra_fun</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">x</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ele_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_idxs</span><span class="p">:</span>
            <span class="n">ele_surrogate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_models</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span>
            <span class="n">x_ele</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_onto_ele</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ele_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xforms</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">grad_ele</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">xforms</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">](</span><span class="n">ele_surrogate</span><span class="o">.</span><span class="n">fun_eval</span><span class="p">(</span><span class="n">x_ele</span><span class="p">))</span>
                    <span class="o">*</span> <span class="n">ele_surrogate</span><span class="o">.</span><span class="n">grad_eval</span><span class="p">(</span><span class="n">x_ele</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grad_ele</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">ele_surrogate</span><span class="o">.</span><span class="n">grad_eval</span><span class="p">(</span><span class="n">x_ele</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">(</span><span class="s2">&quot;debug.check_nan_fval&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">grad_ele</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;(element </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ele_names</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span><span class="si">}</span><span class="s2">) NaN encountered in the return value&quot;</span>
                    <span class="s2">&quot; of the surrogate gradient. &quot;</span>
                    <span class="s2">&quot;This may be caused by some numerical error or matrix singularity. &quot;</span>
                <span class="p">)</span>
            <span class="n">grad</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">grad_ele</span>
        <span class="k">return</span> <span class="n">grad</span></div>


<div class="viewcode-block" id="OverallSurrogate.hess_eval">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.OverallSurrogate.hess_eval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">hess_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the full Hessian matrix of the overall surrogate model at given point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray, shape (n,)</span>
<span class="sd">            Evaluation point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        H : ndarray, shape (n, n)</span>
<span class="sd">            The Hessian matrix of the overall surrogate model at the point ``x``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extra_fun</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="n">x</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ele_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_idxs</span><span class="p">:</span>
            <span class="n">ele_surrogate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_models</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span>
            <span class="n">model_dim_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">x_ele</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_onto_ele</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ele_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xforms</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ele_model_fval</span> <span class="o">=</span> <span class="n">ele_surrogate</span><span class="o">.</span><span class="n">fun_eval</span><span class="p">(</span><span class="n">x_ele</span><span class="p">)</span>
                <span class="n">ele_model_grad</span> <span class="o">=</span> <span class="n">ele_surrogate</span><span class="o">.</span><span class="n">grad_eval</span><span class="p">(</span><span class="n">x_ele</span><span class="p">)</span>
                <span class="n">xform_grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xforms</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">](</span><span class="n">ele_model_fval</span><span class="p">)</span>
                <span class="n">xform_hess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xforms</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">][</span><span class="mi">2</span><span class="p">](</span><span class="n">ele_model_fval</span><span class="p">)</span>
                <span class="n">hess_ele</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">xform_hess</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">ele_model_grad</span><span class="p">,</span> <span class="n">ele_model_grad</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">xform_grad</span> <span class="o">*</span> <span class="n">ele_surrogate</span><span class="o">.</span><span class="n">hess_eval</span><span class="p">(</span><span class="n">x_ele</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hess_ele</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">ele_surrogate</span><span class="o">.</span><span class="n">hess_eval</span><span class="p">(</span><span class="n">x_ele</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">(</span><span class="s2">&quot;debug.check_nan_fval&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hess_ele</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;(element </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ele_names</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span><span class="si">}</span><span class="s2">) NaN encountered in the return value&quot;</span>
                    <span class="s2">&quot; of the surrogate hessian. &quot;</span>
                    <span class="s2">&quot;This may be caused by some numerical error or matrix singularity. &quot;</span>
                <span class="p">)</span>
            <span class="n">hess</span><span class="p">[</span><span class="n">model_dim_idx</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">model_dim_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hess_ele</span>
        <span class="k">return</span> <span class="n">hess</span></div>


<div class="viewcode-block" id="OverallSurrogate.hess_operator">
<a class="viewcode-back" href="../../../upoqa.utils.html#upoqa.utils.model.OverallSurrogate.hess_operator">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">hess_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Hessian-vector product for the overall surrogate model at given point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : ndarray, shape (n,)</span>
<span class="sd">            The point at which to evaluate the Hessian-vector product.</span>
<span class="sd">        v : ndarray, shape (n, )</span>
<span class="sd">            The vector to multiply with the Hessian matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hv : ndarray, shape (n, )</span>
<span class="sd">            The result of the Hessian-vector product.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">v</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extra_fun</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="n">x</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ele_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_idxs</span><span class="p">:</span>
            <span class="n">ele_surrogate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ele_models</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span>
            <span class="n">v_ele</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_onto_ele</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ele_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xforms</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">x_ele</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_onto_ele</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ele_idx</span><span class="p">)</span>
                <span class="n">ele_model_fval</span> <span class="o">=</span> <span class="n">ele_surrogate</span><span class="o">.</span><span class="n">fun_eval</span><span class="p">(</span><span class="n">x_ele</span><span class="p">)</span>
                <span class="n">ele_model_grad</span> <span class="o">=</span> <span class="n">ele_surrogate</span><span class="o">.</span><span class="n">grad_eval</span><span class="p">(</span><span class="n">x_ele</span><span class="p">)</span>
                <span class="n">xform_grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xforms</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">](</span><span class="n">ele_model_fval</span><span class="p">)</span>
                <span class="n">xform_hess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xforms</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">][</span><span class="mi">2</span><span class="p">](</span><span class="n">ele_model_fval</span><span class="p">)</span>
                <span class="n">hess_operator_ele</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">xform_hess</span>
                    <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">ele_model_grad</span><span class="p">,</span> <span class="n">v_ele</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ele_model_grad</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                    <span class="o">+</span> <span class="n">xform_grad</span> <span class="o">*</span> <span class="n">ele_surrogate</span><span class="o">.</span><span class="n">hess_operator</span><span class="p">(</span><span class="n">v_ele</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hess_operator_ele</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">ele_surrogate</span><span class="o">.</span><span class="n">hess_operator</span><span class="p">(</span>
                    <span class="n">v_ele</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">(</span><span class="s2">&quot;debug.check_nan_fval&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hess_operator_ele</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;(element </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ele_names</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]</span><span class="si">}</span><span class="s2">) NaN encountered in the return &quot;</span>
                    <span class="s2">&quot;value of the surrogate hessian operator. &quot;</span>
                    <span class="s2">&quot;This may be caused by some numerical error or matrix singularity. &quot;</span>
                <span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">ele_idx</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">hess_operator_ele</span>
        <span class="k">return</span> <span class="n">result</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Yichuan Liu and Yingzhou Li.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>