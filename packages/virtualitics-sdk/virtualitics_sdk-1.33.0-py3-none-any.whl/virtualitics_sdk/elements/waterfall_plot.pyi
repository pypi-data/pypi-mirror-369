from _typeshed import Incomplete
from enum import Enum
from predict_backend.validation.type_validation import validate_types
from virtualitics_sdk.elements.plot import Plot as Plot, PlotAxisScale as PlotAxisScale, PlotDataPoint as PlotDataPoint, PlotType as PlotType, XAxis as XAxis, XAxisOrientation as XAxisOrientation, YAxis as YAxis, YAxisOrientation as YAxisOrientation

class DataType(Enum):
    NUMERICAL: str
    CATEGORICAL: str

class WaterfallPlotData(PlotDataPoint):
    name: Incomplete
    weight: Incomplete
    min: Incomplete
    max: Incomplete
    percentile: Incomplete
    count: Incomplete
    frequency: Incomplete
    explanation: Incomplete
    value: Incomplete
    type: Incomplete
    @validate_types
    def __init__(self, name: str, weight: float, value: int | float | str, explanation: str, type: DataType, _min: float | None = None, _max: float | None = None, percentile: str | None = None, count: int | None = None, frequency: float | None = None) -> None: ...
    def to_json(self): ...

class WaterfallPlot(Plot):
    '''
    Waterfall plots are usually generated by the :class:`~virtualitics_sdk.assets.explainer.Explainer` class and are not
    recommended creating manually. 
    
    **EXAMPLE:**

       .. code-block:: python

           # Imports 
           from xgboost import XGBRegressor
           from virtualitics_sdk import Explainer
           . . . 
           # Example usage
           def produce_waterfall_xai_plot(data):
                . . .
                # Creating Virtualitics Ensemble Model
                xgb = Model(
                    XGBRegressor(learning_rate=0.1, 
                                 n_jobs=-1, 
                                 n_estimators=100, 
                                 max_depth=5, 
                                 eval_metric="mae", 
                                 random_state=42),
                    label="pmx",
                    name="remaining useful life predictor",
                )
                # Training Virtualitics Ensemble Model
                xgb.fit(modeling_data[ohe_features], modeling_data[target])
                # Create explainer training data asset
                explain_data = Dataset(
                    modeling_data[ohe_features],
                    label="pmx",
                    name="explainer modeling set",
                    categorical_cols=categorical_ft_cols,
                    encoding=DataEncoding.ONE_HOT,
                )
                # Create explainer for ensemble model
                explainer = Explainer(
                    model=xgb,
                    training_data=explain_data,
                    output_names=target,
                    mode="regression",
                    label="pmx project",
                    name="ensemble model",
                    use_shap=True,
                    use_lime=False,
                )
                plot = explainer.explain(
                    explain_instances[ohe_features],
                    method="manual",
                    titles=titles,
                    expected_title="Average Gearbox Lifespan",
                    predicted_title="Predicted Gearbox Lifespan",
                    return_as="plots",
                )
    '''
    expected_value: Incomplete
    returned_value: Incomplete
    expected_title: Incomplete
    predicted_title: Incomplete
    pred_explanation: Incomplete
    positive_color: Incomplete
    negative_color: Incomplete
    additional_args: Incomplete
    @validate_types
    def __init__(self, title: str, expected: int | float, returned: int | float, pred_explanation: str, x_axis_label: str, data: list[WaterfallPlotData], description: str = '', positive_color: str | None = None, negative_color: str | None = None, expected_title: str | None = None, predicted_title: str | None = None, show_title: bool = True, show_description: bool = True, **kwargs) -> None: ...
    def to_json(self): ...
