# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: k_full.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    List,
    Optional,
)

import betterproto


class ProductType(betterproto.Enum):
    play = 0
    """
    play series 0 - 20
     epos series 21 - 40
    """

    play_pro = 1
    play_evolution = 2
    epos_300_lamphead = 21
    epos_300_controller = 22
    epos_600_lamphead = 23
    epos_600_controller = 24
    unknown = 10000


class RequestTypes(betterproto.Enum):
    VERSION = 0
    CALIBRATION_DATA_CHANNEL_BASIC = 1
    CALIBRATION_DATA_LIGHT_BASIC = 2
    COB_DRIVER_STATE = 3
    COB_DRIVER_VERSION = 4
    COB_DRIVER_SERIAL_NUMBER = 5
    SERIAL_NUMBER = 6
    POWER_STATE = 7
    SEPERATE_LAMP_HEAD_IMAGE_VERSION = 8
    DEVICE_STATS = 9
    FAN_DATA = 10
    DEVICE_TEMPERATURES = 11
    """request_param1 to indicate which fan to get data for."""

    CURRENT_LIGHT_OUTPUT = 26
    LAMP_HEAD_IMAGE_INFO = 27
    DEVICE_ID = 28
    DEVICE_HW_CODE = 29
    """identify rl usb devices."""

    BATTERY = 30
    POWER_SUPPLY = 31
    CURRENT_MODE = 32
    LIGHT_SETTINGS = 33
    """and current mode data"""

    PERIPHERIAL_STATE = 34
    HARDWARE_VERIFICATION = 35
    """
    Used to verify hardware components of a device during production.
     It will be possible to do remote hardware debugging via the Narrator app.
     Make sure to use the request_param1 for successive messages if number of devices surpass the max_count of 12
     request_param1 [0-1] returns first 12 device states, [2] returns the next 12 and so on...
    """

    CRMX_STATE = 36
    CHARGER_INFO = 37


class RgbColorSpace(betterproto.Enum):
    LEDS_ON_LIGHT = 0
    S_RGB = 1
    ADOBE_1988 = 2
    ADOBE_WIDE = 3
    PRO_PHOTO = 4
    DCI_P3 = 5
    REC_2020 = 6


class CommandType(betterproto.Enum):
    SAVE_CALIBRATION_DATA_TO_FLASH = 0
    LOAD_CALIBRATION_DATA_FROM_FLASH = 1
    CLEAR_CALIBRATION_DATA_FROM_FLASH = 2
    RESET_MCU = 3
    CLEAR_WHOLE_EXTERNAL_FLASH = 4
    SAVE_MODE_PARAMETERS_TO_FLASH = 5
    LOAD_MODE_PARAMETERS_FROM_FLASH = 6
    CLEAR_MODE_PARAMETERS_FROM_FLASH = 7
    TURN_OFF_BTLE_ADVERTISING = 8
    TURN_ON_BTLE_ADVERTISING = 9
    FLASH_LIGHT_FOR_IDENTIFICATION = 10
    DRIVER_IGNORE_CONTROLLER = 11
    """Set the driver to ignore the controller box"""

    RESET_DEVICE_STATS = 12
    """Use this to reset all stats such as device hours, lamp hours etc"""

    DFU_NOTFICATION_RESET = 13
    """
    The app will send this command before it tells mcumgr to reset. The light
    can f.ex display "Running bootloader" before it is reset.
    """

    ENABLE_BOOSTER = 14
    DISABLE_BOOSTER = 15
    ENABLE_CHARGE_PORT = 16
    DISABLE_CHARGE_PORT = 17
    FACTORY_RESET = 18
    CRMX_UNLINK = 19
    CLEAR_RESET_REASON_REGISTER = 20
    CRMX_UPDATE_FW = 21
    CRMX_ERASE_FW_IMAGE = 22


class EmitterOutputType(betterproto.Enum):
    PWM_OUTPUT = 0
    DAC_OUTPUT = 1


class BatteryPosition(betterproto.Enum):
    """
    //////////////////////
     Power related
    //////////////////////
    """

    FRONT = 0
    REAR = 1


class ChargingState(betterproto.Enum):
    NO_CHARGE = 0
    TRICKLE_CHARGE = 1
    PRE_CHARGE = 2
    CC_CHARGE = 3
    CV_CHARGE = 4
    TERMINATION_CHARGE = 5


class DcDcSwitchState(betterproto.Enum):
    SWITCH_IDLE = 0
    SWITCH_BUCK = 1
    SWITCH_BUCK_BOOST = 2
    SWITCH_BOOST = 3


class DeviceState(betterproto.Enum):
    DEVICE_ON = 0
    DEVICE_OFF = 1
    DEVICE_STANDBY = 2
    """The following stats are not used at the moment"""

    DEVICE_SLEEP = 3


class DeviceId(betterproto.Enum):
    ID_UNKNOWN = 0
    ID_NONE = 1
    ID_TEMPERATURE_SENSOR = 10
    """Temperature"""

    ID_TEMPERATURE_SENSOR_EMITTER = 11
    ID_TEMPERATURE_SENSOR_DRIVER = 12
    ID_TEMPERATURE_SENSOR_CONTROLLER = 13
    ID_TEMPERATURE_SENSOR_BATTERY_1 = 14
    ID_TEMPERATURE_SENSOR_BATTERY_2 = 15
    ID_EXTERNAL_FLASH = 20
    """EXternal flash"""

    ID_EXTERNAL_FLASH_NVS_CALIBRATION_DATA = 21
    ID_EXTERNAL_FLASH_NVS_LIGHT_MODES = 22
    ID_EXTERNAL_FLASH_NVS_SETTINGS = 23
    ID_EXTERNAL_FLASH_LFS = 25
    """ID_EXTERNAL_FLASH_NVS_ = 24;"""

    ID_EXTERNAL_FLASH_LFS_GRAPHICS = 26
    ID_EXTERNAL_FLASH_LFS_GELS = 27
    ID_EXTERNAL_FLASH_LFS_PRESETS = 28
    ID_DISPLAY = 30
    """Display"""

    ID_DISPLAY_SITRONIX_ST7789V = 31
    ID_CRMX_DEVICE = 40
    """CRMX devices"""

    ID_CRMX_DEVICE_CRMX_CHIP = 41
    ID_CRMX_DEVICE_RDM_CHIP = 42
    ID_CRMX_DEVICE_TIMO_RX = 44
    """ID_CRMX_DEVICE_FX_CHIP = 43;"""

    ID_CRMX_DEVICE_TIMO_RX_RDM = 45
    ID_CRMX_DEVICE_TIMO_FX = 46
    ID_CRMX_DEVICE_TIMOTWO_FX = 47
    ID_USB_C_CONTROLLER = 50
    """USB Type-C controllers"""

    ID_USB_C_CONTROLLER_FUSB302B = 51
    ID_BATTERY_1 = 60
    """Batteries"""

    ID_BATTERY_2 = 61
    ID_BATTERY_CHARGER = 70
    """Battery chargers"""

    ID_BATTERY_CHARGER_MP2615 = 71
    ID_BATTERY_CHARGER_MP2760 = 72
    ID_ACCELEROMETER = 80
    """Accelerometers"""

    ID_ACCELEROMETER_MXC4005 = 81
    ID_HARDWARE_CODE = 90
    """Hardware codes"""

    ID_HARDWARE_CODE_DIGITAL = 91
    ID_HARDWARE_CODE_ANALOG = 92
    ID_PWM_LEDS = 100
    """LED PWMs"""

    ID_PWM_LED_RED = 101
    ID_PWM_LED_GREEN = 102
    ID_PWM_LED_BLUE = 103
    ID_PWM_LED_AMBER = 104
    ID_PWM_LED_CYAN = 105
    ID_PWM_LED_LIME = 106
    ID_PWM_DISPLAY_BACKLIGHT = 110
    """Other PWMs"""

    ID_GPIO_POWER_LATCH = 120
    """GPIOs"""

    ID_GPIO_USB_DMX_SWITCH = 121


class DeviceState2(betterproto.Enum):
    STATE_UNKNOWN = 0
    STATE_OFFLINE = 5
    """"""

    STATE_GOOD = 6
    STATE_BAD = 7
    STATE_UNINITIALIZED = 10
    """"""

    STATE_INITIALIZED = 12
    STATE_OFF = 15
    """"""

    STATE_ON = 16
    STATE_SLEEPING = 17
    STATE_STOPPED = 20
    """"""

    STATE_RUNNING = 21


class FeatureId(betterproto.Enum):
    f_UNKNOWN = 0
    f_DMX = 10
    """DMX related features"""

    f_DMX_RX = 11
    f_DMX_TX = 12
    f_DMX_RDM = 13
    f_DMX_RS485 = 15
    f_DMX_RS485_RX = 16
    f_DMX_RS485_TX = 17
    f_DMX_RS485_RDM = 18
    f_DMX_CRMX = 20
    f_DMX_CRMX_RX = 21
    f_DMX_CRMX_TX = 22
    f_DMX_CRMX_RDM = 23
    f_DMX_ARTNET = 25
    f_DMX_SACN = 28
    """
    f_DMX_ARTNET_RX = 26; // Reserved
     f_DMX_ARTNET_TX = 27; // Reserved
    """

    f_DMX_USB = 30
    f_DMX_USB_RX = 31
    f_DMX_USB_TX = 32
    f_DMX_USB_RDM = 33


class PeripherialState(betterproto.Enum):
    UNKNOWN = 0
    GOOD = 1
    BAD = 2


class FirmwareImageState(betterproto.Enum):
    IMAGE_NOT_AVAILABLE = 0
    IMAGE_UP_TO_DATE = 1
    IMAGE_READY_FOR_UPDATE = 2
    IMAGE_INVALID = 3
    IMAGE_CORRUT = 4


class CDataLinearInterpolationId(betterproto.Enum):
    NON_LIN_COMP = 0
    TEMP_COMP = 1
    X_XY_DRIFT_TEMP = 2
    Y_XY_DRIFT_TEMP = 3
    X_XY_DRIFT_DUTY_CYCLE = 4
    Y_XY_DRIFT_DUTY_CYCLE = 5
    MATRIX_FACTORS = 6
    WATT_DRAW = 7
    TRANSISTOR_TEMP_COMP = 8
    DAC_NON_LIN_COMP = 9
    DAC_MATRIX_FACTORS = 10
    DAC_X_XY_DRIFT_TEMP = 11
    DAC_Y_XY_DRIFT_TEMP = 12
    DAC_X_XY_DRIFT_DUTY_CYCLE = 13
    DAC_Y_XY_DRIFT_DUTY_CYCLE = 14
    DAC_WATT_DRAW = 15


class GelBrandCategory(betterproto.Enum):
    ROSCO_CALCOLOR = 0
    ROSCO_CINELUX = 1
    ROSCO_COLOR_CORRECTION = 2
    LEE_0_SERIES = 3
    LEE_100_SERIES = 4
    LEE_200_AND_300_SERIES = 5
    LEE_500_SERIES = 6
    LEE_700_SERIES = 7
    LEE_COLOR_CORRECTION = 8


class FanControllerMode(betterproto.Enum):
    MANUAL = 0
    FAN_SILENT = 1
    FAN_CURVE_QUIET = 2
    FAN_CURVE_REGULAR = 3
    FAN_CURVE_HIGH = 4


class McuMgrMessageTypes(betterproto.Enum):
    SWAP_IMAGE = 0
    CONFIRM_IMAGE = 1
    ERASE_EXTERNAL_FLASH_IMAGE_0_SLOT1 = 2
    """
    This is the normal external flash partition for firmware images used by
     mcuboot
    """

    ERASE_EXTERNAL_FLASH_IMAGE_1_SLOT1 = 3
    """
    This is an extra partition used to store firmware images. For example when
     epos 300 stores a driver image in its external flash
    """


class EffectLoopType(betterproto.Enum):
    NO_LOOP = 0
    NORMAL_LOOP = 1
    """continue from start"""

    BACK_AND_FORTH = 2
    """play to end, then back to start"""


class SirenColorCombination(betterproto.Enum):
    RED_BLUE_AND_WHITE = 0
    BLUE_RED_AND_WHITE = 1
    BLUE_RED_AND_AMBER = 2
    RED_AND_BLUE = 3
    RED_AND_WHITE = 4
    RED_AND_AMBER = 5
    BLUE_AND_WHITE = 6
    BLUE_AND_AMBER = 7
    AMBER_AND_WHITE = 8
    RED = 9
    BLUE = 10
    AMBER = 11


class SirenSpeed(betterproto.Enum):
    SIREN_VERY_SLOW = 0
    SIREN_SLOW = 1
    SIREN_MEDIUM = 2
    SIREN_FAST = 3
    SIREN_VERY_FAST = 4


class SirenFlashDuration(betterproto.Enum):
    SIREN_VERY_SHORT_FLASH = 0
    SIREN_SHORT_FLASH = 1
    SIREN_MEDIUM_FLASH = 2
    SIREN_LONG_FLASH = 3
    SIREN_VERY_LONG_FLASH = 4


class PulseType(betterproto.Enum):
    SINUSOIDAL = 0
    LOGARITHMIC = 1
    EXPONENTIAL = 2
    TRIANGLE = 3


class ColorType(betterproto.Enum):
    CCT = 0
    RGB = 1
    HSI = 2
    XY = 3


class LightEffectType(betterproto.Enum):
    NONE = 0
    FIRE = 1
    CCT_CHASE = 2
    COLOR_CHASE = 3
    PULSE = 4
    STROBE = 5
    LIGHTNING = 6
    DIMMING = 7
    SIREN = 8
    SEQUENCE = 9
    LightEffectType_count = 10


class LightEffectState(betterproto.Enum):
    PLAY = 0
    STOP = 1


class EffectNavigationState(betterproto.Enum):
    CHOOSE_EFFECT_SCREEN = 0
    EFFECT_SCREEN = 1
    EffectNavigationState_count = 2


class DimmingCurve(betterproto.Enum):
    D_EXPONENTIAL = 0
    D_LOGARITHMIC = 1
    D_S_CURVE = 2
    D_LINEAR = 3
    COUNT = 4


class LightAccessoryType(betterproto.Enum):
    bare = 0
    d75_diffuser = 1
    d90_diffuser = 2
    d100_diffuser = 3
    spacer_with_d75_diffuser = 4
    spacer_with_d90_diffuser = 5
    spacer_with_d100_diffuser = 6
    high_performance_lens = 7
    dome_diffuser = 8
    LightAccessoryType_count = 9


class PbDmxMode(betterproto.Enum):
    SLAVE_MODE = 0
    MASTER_MODE = 1
    PbDMXMode_count = 2


class PbDmxDropoutMode(betterproto.Enum):
    DMX_DROPOUT_MODE_REMAIN_ON = 0
    DMX_DROPOUT_MODE_LIGHT_OFF = 1
    DMX_DROPOUT_MODE_LIGHT_OFF_N_SEC = 2
    PbDMXDropoutMode_count = 3


class PbDmxConnection(betterproto.Enum):
    NO_CONNECTION = 0
    WIRED_DMX_CONNECTION = 1
    LUMEN_DMX_CONNECTION = 2
    ARTNET_SACN_CONNECTION = 3
    ARTNET_CONNECTION = 4
    SACN_CONNECTION = 5
    PbDMXConnection_count = 6


class PbLumenMode(betterproto.Enum):
    RX_MODE = 0
    TX_MODE = 1
    PbLumenMode_count = 2


class PbLumenRadioState(betterproto.Enum):
    RADIO_OFF = 0
    RADIO_ON = 1
    PbLumenRadioState_count = 2


class PbArtNetSacnState(betterproto.Enum):
    OFF = 0
    ARTNET = 1
    SACN = 2
    ARTNET_AND_SACN = 3
    PbArtNetSacnState_count = 4


class PbEthernetIpMode(betterproto.Enum):
    DHCP = 0
    STATIC = 1
    ARTNET_2XXX = 2
    ARTNET_10XXX = 3
    PbEthernetIPMode_count = 4


class PbChargeOnDcSetting(betterproto.Enum):
    ChargeOnDC_OFF = 0
    ChargeOnDC_ON = 1
    PbChargeOnDcSetting_count = 2


class PbDisplayIdleMode(betterproto.Enum):
    ALWAYS_ON = 0
    IDLE_DIM = 1
    PbDisplayIdleMode_count = 2


class PbOrientationLockSetting(betterproto.Enum):
    OrientationLock_OFF = 0
    OrientationLock_ON = 1


class PbLumenConnectionStatus(betterproto.Enum):
    RF_OFF = 0
    RX_NO_LINK = 1
    RX_LINKED = 2
    RX_ACTIVE_LINK = 3
    TX_INACTIVE = 4
    TX_ACTIVE = 5
    TX_LINKING = 6


class CubicSplineMessageCubicSplineFactorId(betterproto.Enum):
    SPLINE = 0
    C1 = 1
    C2 = 2
    C3 = 3
    C4 = 4


class LinearInterpolationMessageLinearInterpolationAxisId(betterproto.Enum):
    X_AXIS = 0
    Y_AXIS = 1


class CalibrationDataChannelArrayMessageCalibrationDataChannelArrayId(betterproto.Enum):
    OUTPUT_MEASUREMENTS = 0
    LUX_MEASUREMENTS = 1
    LED_SPECTRUM = 2


class IntensityMessageLightOutputType(betterproto.Enum):
    STABLE = 0
    MAXIMUM = 1


class PlayBoostMessagePlayPowerMode(betterproto.Enum):
    NORMAL = 0
    BOOST = 1


class FireEffectParamsFireType(betterproto.Enum):
    CANDLE = 0
    CAMP_FIRE = 1
    BON_FIRE = 2


class FireEffectParamsWindType(betterproto.Enum):
    NO_WIND = 0
    BREEZE = 1
    WINDY = 2
    STORMY = 3


class BleTestingMessageBleTestRequest(betterproto.Enum):
    start_scan = 0
    stop_scan = 1
    rssi = 2
    disconnect_all = 3


@dataclass(eq=False, repr=False)
class RequestMessage(betterproto.Message):
    request_type: Optional["RequestTypes"] = betterproto.enum_field(1, optional=True)
    request_param1: Optional[int] = betterproto.int32_field(2, optional=True)


@dataclass(eq=False, repr=False)
class DeviceIdMessage(betterproto.Message):
    name: Optional[str] = betterproto.string_field(1, optional=True)


@dataclass(eq=False, repr=False)
class CommandMessage(betterproto.Message):
    command: Optional["CommandType"] = betterproto.enum_field(1, optional=True)
    passwd: Optional[int] = betterproto.uint32_field(2, optional=True)


@dataclass(eq=False, repr=False)
class DeviceStatsMessage(betterproto.Message):
    device_hours: Optional[float] = betterproto.float_field(1, optional=True)
    """How many hours has this device been on?"""

    lamp_hours: Optional[float] = betterproto.float_field(2, optional=True)
    """How many hours has this device had brightness > 1 %"""

    power_cycles: Optional[int] = betterproto.uint32_field(3, optional=True)
    """How many times has this device been turned on/off"""


@dataclass(eq=False, repr=False)
class EmitterOutputMessage(betterproto.Message):
    output_type: Optional["EmitterOutputType"] = betterproto.enum_field(
        1, optional=True
    )


@dataclass(eq=False, repr=False)
class BatteryMessage(betterproto.Message):
    position: Optional["BatteryPosition"] = betterproto.enum_field(1, optional=True)
    remaining_runtime_in_minutes: Optional[int] = betterproto.uint32_field(
        2, optional=True
    )
    remaining_capacity_pct: Optional[float] = betterproto.float_field(3, optional=True)
    voltage: Optional[float] = betterproto.float_field(4, optional=True)
    is_connected: Optional[bool] = betterproto.bool_field(5, optional=True)
    is_smart: Optional[bool] = betterproto.bool_field(6, optional=True)
    read_voltage: Optional[float] = betterproto.float_field(7, optional=True)
    current_load_m_a: Optional[float] = betterproto.float_field(8, optional=True)
    time_since_last_pull_ms: Optional[int] = betterproto.int32_field(9, optional=True)
    battery_charge_current_m_a: Optional[int] = betterproto.int32_field(
        15, optional=True
    )
    battery_discharge_current_m_a: Optional[int] = betterproto.int32_field(
        16, optional=True
    )
    battery_temperature: Optional[float] = betterproto.float_field(17, optional=True)
    status_flags: Optional[int] = betterproto.uint32_field(20, optional=True)


@dataclass(eq=False, repr=False)
class ChargerMessage(betterproto.Message):
    charger_id: Optional["DeviceId"] = betterproto.enum_field(1, optional=True)
    charger_hardware_state: Optional["DeviceState2"] = betterproto.enum_field(
        2, optional=True
    )
    pd_manager_id: Optional["DeviceId"] = betterproto.enum_field(3, optional=True)
    pd_manager_hardware_state: Optional["DeviceState2"] = betterproto.enum_field(
        4, optional=True
    )
    charger_input_voltage_m_v: Optional[float] = betterproto.float_field(
        5, optional=True
    )
    charger_input_current_m_a: Optional[float] = betterproto.float_field(
        6, optional=True
    )
    charger_output_voltage_m_v: Optional[float] = betterproto.float_field(
        10, optional=True
    )
    charger_output_current_m_a: Optional[float] = betterproto.float_field(
        11, optional=True
    )
    charger_temperature1: Optional[float] = betterproto.float_field(15, optional=True)
    charger_temperature2: Optional[float] = betterproto.float_field(16, optional=True)
    charger_charging_state: Optional["ChargingState"] = betterproto.enum_field(
        20, optional=True
    )
    charger_dc_dc_switch_state: Optional["DcDcSwitchState"] = betterproto.enum_field(
        21, optional=True
    )
    status_flags: Optional[int] = betterproto.uint32_field(25, optional=True)
    usb_attached: Optional[bool] = betterproto.bool_field(30, optional=True)
    contract_negotiated: Optional[bool] = betterproto.bool_field(31, optional=True)
    contract_voltage_m_v: Optional[float] = betterproto.float_field(35, optional=True)
    contract_current_m_a: Optional[float] = betterproto.float_field(36, optional=True)


@dataclass(eq=False, repr=False)
class PowerSupplyMessage(betterproto.Message):
    voltage: Optional[float] = betterproto.float_field(1, optional=True)
    is_connected: Optional[bool] = betterproto.bool_field(2, optional=True)


@dataclass(eq=False, repr=False)
class Epos300PowerStateMessage(betterproto.Message):
    battery: "BatteryMessage" = betterproto.message_field(
        1, group="active_power_source"
    )
    power_supply: "PowerSupplyMessage" = betterproto.message_field(
        2, group="active_power_source"
    )
    max_power_draw: Optional[float] = betterproto.float_field(3, optional=True)
    booster_enabled: Optional[bool] = betterproto.bool_field(4, optional=True)
    booster_power_good: Optional[bool] = betterproto.bool_field(5, optional=True)
    charge_port_enabled: Optional[bool] = betterproto.bool_field(6, optional=True)


@dataclass(eq=False, repr=False)
class PlayPowerStateMessage(betterproto.Message):
    battery: Optional["BatteryMessage"] = betterproto.message_field(1, optional=True)
    max_power_draw: Optional[float] = betterproto.float_field(2, optional=True)
    is_charging: Optional[bool] = betterproto.bool_field(3, optional=True)


@dataclass(eq=False, repr=False)
class Epos600PowerStateMessage(betterproto.Message):
    psu_input: Optional["PowerSupplyMessage"] = betterproto.message_field(
        1, optional=True
    )
    psu_enabled: Optional[bool] = betterproto.bool_field(2, optional=True)
    psu_ok: Optional[bool] = betterproto.bool_field(3, optional=True)
    aux_input: Optional["PowerSupplyMessage"] = betterproto.message_field(
        4, optional=True
    )
    max_power_draw: Optional[float] = betterproto.float_field(5, optional=True)
    vbus_output: Optional["PowerSupplyMessage"] = betterproto.message_field(
        6, optional=True
    )
    aux_stat: Optional[bool] = betterproto.bool_field(7, optional=True)
    pd_usb_attached: Optional[bool] = betterproto.bool_field(8, optional=True)
    pd_contract_negotiated: Optional[bool] = betterproto.bool_field(9, optional=True)
    pd_contract_voltage: Optional[float] = betterproto.float_field(10, optional=True)
    pd_contract_current: Optional[float] = betterproto.float_field(11, optional=True)


@dataclass(eq=False, repr=False)
class PowerStateMessage(betterproto.Message):
    epos300_power_state_message: "Epos300PowerStateMessage" = betterproto.message_field(
        1, group="message_type"
    )
    play_power_state_message: "PlayPowerStateMessage" = betterproto.message_field(
        2, group="message_type"
    )
    epos600_power_state_message: "Epos600PowerStateMessage" = betterproto.message_field(
        3, group="message_type"
    )
    device_state: Optional["DeviceState"] = betterproto.enum_field(10, optional=True)
    reset_reason_value_device: Optional[int] = betterproto.uint32_field(
        11, optional=True
    )
    reset_reason_value_lamp: Optional[int] = betterproto.uint32_field(12, optional=True)


@dataclass(eq=False, repr=False)
class DeviceStateMessage(betterproto.Message):
    device_id: Optional["DeviceId"] = betterproto.enum_field(1, optional=True)
    device_state: Optional["DeviceState2"] = betterproto.enum_field(2, optional=True)
    device_signed_parameter: Optional[int] = betterproto.int32_field(3, optional=True)
    """Adding generic parameters"""

    device_unsigned_parameter: Optional[int] = betterproto.uint32_field(
        4, optional=True
    )
    device_float_parameter: Optional[float] = betterproto.float_field(5, optional=True)


@dataclass(eq=False, repr=False)
class HardwareVerificaionMessage(betterproto.Message):
    product_type: Optional["ProductType"] = betterproto.enum_field(1, optional=True)
    firmware_version: Optional["VersionMessage"] = betterproto.message_field(
        2, optional=True
    )
    message_number: Optional[int] = betterproto.int32_field(3, optional=True)
    total_messages: Optional[int] = betterproto.int32_field(4, optional=True)
    devices: List["DeviceStateMessage"] = betterproto.message_field(5)


@dataclass(eq=False, repr=False)
class DeviceFeatureMessage(betterproto.Message):
    product_type: Optional["ProductType"] = betterproto.enum_field(1, optional=True)
    firmware_version: Optional["VersionMessage"] = betterproto.message_field(
        2, optional=True
    )
    message_number: Optional[int] = betterproto.int32_field(3, optional=True)
    total_messages: Optional[int] = betterproto.int32_field(4, optional=True)
    features: List["FeatureId"] = betterproto.enum_field(5)


@dataclass(eq=False, repr=False)
class PeripherialMessage(betterproto.Message):
    initialized: Optional[bool] = betterproto.bool_field(1, optional=True)
    state: Optional["PeripherialState"] = betterproto.enum_field(2, optional=True)
    info: Optional[str] = betterproto.string_field(3, optional=True)


@dataclass(eq=False, repr=False)
class PeripherialStateMessage(betterproto.Message):
    io_expander: Optional["PeripherialMessage"] = betterproto.message_field(
        1, optional=True
    )
    accelerometer: Optional["PeripherialMessage"] = betterproto.message_field(
        2, optional=True
    )


@dataclass(eq=False, repr=False)
class Epos300ControllerTemperaturesMessage(betterproto.Message):
    ui_pcb_temperature: Optional[float] = betterproto.float_field(1, optional=True)
    power_pcb_temperature: Optional[float] = betterproto.float_field(2, optional=True)


@dataclass(eq=False, repr=False)
class Epos600ControllerTemperaturesMessage(betterproto.Message):
    ui_pcb_temperature: Optional[float] = betterproto.float_field(1, optional=True)
    power_pcb_temperature: Optional[float] = betterproto.float_field(2, optional=True)


@dataclass(eq=False, repr=False)
class Epos300LampheadTemperaturesMessage(betterproto.Message):
    emitter_temperature: Optional[float] = betterproto.float_field(1, optional=True)
    pcb_temperature: Optional[float] = betterproto.float_field(2, optional=True)


@dataclass(eq=False, repr=False)
class Epos600LampheadTemperaturesMessage(betterproto.Message):
    emitter_temperature: Optional[float] = betterproto.float_field(1, optional=True)
    pcb_temperature: Optional[float] = betterproto.float_field(2, optional=True)


@dataclass(eq=False, repr=False)
class PlayTemperaturesMessage(betterproto.Message):
    emitter_temperature: Optional[float] = betterproto.float_field(1, optional=True)
    driver_transistor_temperature: Optional[float] = betterproto.float_field(
        2, optional=True
    )
    battery_temperature: Optional[float] = betterproto.float_field(3, optional=True)


@dataclass(eq=False, repr=False)
class DeviceTemperaturesMessage(betterproto.Message):
    epos300_controller_temperatures_message: "Epos300ControllerTemperaturesMessage" = (
        betterproto.message_field(1, group="message_type")
    )
    play_temperatures_message: "PlayTemperaturesMessage" = betterproto.message_field(
        2, group="message_type"
    )
    epos300_lamphead_temperatures_message: "Epos300LampheadTemperaturesMessage" = (
        betterproto.message_field(3, group="message_type")
    )
    epos600_lamphead_temperatures_message: "Epos600LampheadTemperaturesMessage" = (
        betterproto.message_field(4, group="message_type")
    )
    epos600_controller_temperatures_message: "Epos600ControllerTemperaturesMessage" = (
        betterproto.message_field(5, group="message_type")
    )


@dataclass(eq=False, repr=False)
class FirmwareVersionMessage(betterproto.Message):
    version: Optional[bytes] = betterproto.bytes_field(1, optional=True)


@dataclass(eq=False, repr=False)
class CrmxStateMessage(betterproto.Message):
    module_id: Optional["DeviceId"] = betterproto.enum_field(1, optional=True)
    module_hardware_state: Optional["DeviceState2"] = betterproto.enum_field(
        2, optional=True
    )
    module_software_state: Optional["DeviceState2"] = betterproto.enum_field(
        3, optional=True
    )
    hardware_version: Optional[int] = betterproto.uint32_field(4, optional=True)
    module_firmware_version: Optional["FirmwareVersionMessage"] = (
        betterproto.message_field(5, optional=True)
    )
    stored_firmware_version: Optional["FirmwareVersionMessage"] = (
        betterproto.message_field(6, optional=True)
    )
    image_state: Optional["FirmwareImageState"] = betterproto.enum_field(
        7, optional=True
    )


@dataclass(eq=False, repr=False)
class FirmwareDataMessage(betterproto.Message):
    data_address: Optional[int] = betterproto.uint32_field(1, optional=True)
    data_size: Optional[int] = betterproto.uint32_field(2, optional=True)
    data: Optional[bytes] = betterproto.bytes_field(3, optional=True)


@dataclass(eq=False, repr=False)
class FirmwarePacketMessage(betterproto.Message):
    target_device: Optional["DeviceId"] = betterproto.enum_field(1, optional=True)
    target_firmware: Optional["FirmwareVersionMessage"] = betterproto.message_field(
        2, optional=True
    )
    packet_number: Optional[int] = betterproto.uint32_field(3, optional=True)
    total_packets: Optional[int] = betterproto.uint32_field(4, optional=True)
    image_data: Optional["FirmwareDataMessage"] = betterproto.message_field(
        5, optional=True
    )
    crc: Optional[int] = betterproto.uint32_field(6, optional=True)


@dataclass(eq=False, repr=False)
class SerialNumberMessage(betterproto.Message):
    data: Optional[bytes] = betterproto.bytes_field(1, optional=True)


@dataclass(eq=False, repr=False)
class CalibrationDataChannelBasicMessage(betterproto.Message):
    channel_index: Optional[int] = betterproto.int32_field(1, optional=True)
    x: Optional[float] = betterproto.float_field(2, optional=True)
    y: Optional[float] = betterproto.float_field(3, optional=True)
    ynorm: Optional[float] = betterproto.float_field(4, optional=True)
    lux_measured_during_calibration: Optional[float] = betterproto.float_field(
        5, optional=True
    )
    watt_draw_at_measured_output: Optional[float] = betterproto.float_field(
        6, optional=True
    )
    output_value_when_measured: Optional[float] = betterproto.float_field(
        7, optional=True
    )
    emitter_temperature_when_measured: Optional[float] = betterproto.float_field(
        8, optional=True
    )
    number_of_output_vs_lux_measurements: Optional[int] = betterproto.int32_field(
        9, optional=True
    )
    temperature_compensation_enabled: Optional[bool] = betterproto.bool_field(
        10, optional=True
    )
    x_xy_drift_temperature_compensation_enabled: Optional[bool] = (
        betterproto.bool_field(11, optional=True)
    )
    y_xy_drift_temperature_compensation_enabled: Optional[bool] = (
        betterproto.bool_field(12, optional=True)
    )
    current_per_output: Optional[float] = betterproto.float_field(13, optional=True)
    transistor_temperature_when_measured: Optional[float] = betterproto.float_field(
        14, optional=True
    )
    dac_lux_measured_during_calibration: Optional[float] = betterproto.float_field(
        15, optional=True
    )
    dac_watt_draw_at_measured_output: Optional[float] = betterproto.float_field(
        16, optional=True
    )
    dac_ynorm: Optional[float] = betterproto.float_field(17, optional=True)
    dac_x: Optional[float] = betterproto.float_field(18, optional=True)
    dac_y: Optional[float] = betterproto.float_field(19, optional=True)
    dac_output_value_when_measured: Optional[float] = betterproto.float_field(
        20, optional=True
    )


@dataclass(eq=False, repr=False)
class CalibrationDataLightBasicMessage(betterproto.Message):
    version: Optional[int] = betterproto.int32_field(11, optional=True)
    number_of_channels: Optional[int] = betterproto.int32_field(1, optional=True)
    distance_to_sensor_in_cm: Optional[float] = betterproto.float_field(
        2, optional=True
    )
    white_light_constant_light_level_max_y: Optional[float] = betterproto.float_field(
        3, optional=True
    )
    colored_light_constant_light_level_max_y: Optional[float] = betterproto.float_field(
        4, optional=True
    )
    maximum_watt_draw_for_light: Optional[float] = betterproto.float_field(
        5, optional=True
    )
    index_of_red_channel: Optional[int] = betterproto.int32_field(6, optional=True)
    index_of_green_channel: Optional[int] = betterproto.int32_field(7, optional=True)
    index_of_blue_channel: Optional[int] = betterproto.int32_field(8, optional=True)
    index_of_channel_used_in_optimized_lookup: Optional[int] = betterproto.int32_field(
        9, optional=True
    )
    booster_voltage_div_efficiency: Optional[float] = betterproto.float_field(
        10, optional=True
    )
    idle_wattage: Optional[float] = betterproto.float_field(12, optional=True)


@dataclass(eq=False, repr=False)
class CubicSplineMessage(betterproto.Message):
    cubic_spline_factor_id: Optional["CubicSplineMessageCubicSplineFactorId"] = (
        betterproto.enum_field(1, optional=True)
    )
    offset: Optional[int] = betterproto.uint32_field(2, optional=True)
    data: List[float] = betterproto.float_field(3)


@dataclass(eq=False, repr=False)
class LinearInterpolationMessage(betterproto.Message):
    linear_interpolation_axis_id: Optional[
        "LinearInterpolationMessageLinearInterpolationAxisId"
    ] = betterproto.enum_field(1, optional=True)
    function_index: Optional[int] = betterproto.int32_field(2, optional=True)
    offset: Optional[int] = betterproto.uint32_field(3, optional=True)
    data: List[float] = betterproto.float_field(4)


@dataclass(eq=False, repr=False)
class CalibrationDataLinearInterpolationMessage(betterproto.Message):
    id: Optional["CDataLinearInterpolationId"] = betterproto.enum_field(
        1, optional=True
    )
    channel_index: Optional[int] = betterproto.int32_field(2, optional=True)
    linear_interpolation_message: Optional["LinearInterpolationMessage"] = (
        betterproto.message_field(3, optional=True)
    )


@dataclass(eq=False, repr=False)
class CalibrationDataChannelArrayMessage(betterproto.Message):
    channel_index: Optional[int] = betterproto.int32_field(1, optional=True)
    c_data_channel_array_id: Optional[
        "CalibrationDataChannelArrayMessageCalibrationDataChannelArrayId"
    ] = betterproto.enum_field(2, optional=True)
    array: Optional["ArrayMessage"] = betterproto.message_field(3, optional=True)


@dataclass(eq=False, repr=False)
class ArrayMessage(betterproto.Message):
    offset: Optional[int] = betterproto.uint32_field(1, optional=True)
    data: List[float] = betterproto.float_field(2)


@dataclass(eq=False, repr=False)
class CalibrationDataFlashMessage(betterproto.Message):
    flash_contains_valid_calibration_data: Optional[bool] = betterproto.bool_field(
        1, optional=True
    )
    number_of_channels: Optional[int] = betterproto.int32_field(2, optional=True)


@dataclass(eq=False, repr=False)
class VersionMessage(betterproto.Message):
    major: Optional[int] = betterproto.uint32_field(1, optional=True)
    minor: Optional[int] = betterproto.uint32_field(2, optional=True)
    revision: Optional[int] = betterproto.uint32_field(3, optional=True)
    build: Optional[int] = betterproto.uint32_field(4, optional=True)


@dataclass(eq=False, repr=False)
class ImageInfoMessage(betterproto.Message):
    image_exists: Optional[bool] = betterproto.bool_field(1, optional=True)
    image_slot: Optional[int] = betterproto.int32_field(2, optional=True)
    version: Optional["VersionMessage"] = betterproto.message_field(3, optional=True)
    hash: Optional[bytes] = betterproto.bytes_field(4, optional=True)
    is_pending: Optional[bool] = betterproto.bool_field(5, optional=True)
    is_active: Optional[bool] = betterproto.bool_field(6, optional=True)
    is_confirmed: Optional[bool] = betterproto.bool_field(7, optional=True)


@dataclass(eq=False, repr=False)
class DriverStateMessage(betterproto.Message):
    pcb_temperature_c: Optional[float] = betterproto.float_field(1, optional=True)
    emitter_temperature_c: Optional[float] = betterproto.float_field(2, optional=True)
    is_emitter_enabled: Optional[bool] = betterproto.bool_field(3, optional=True)
    is_emitter_overheated: Optional[bool] = betterproto.bool_field(4, optional=True)
    session_id: Optional[int] = betterproto.int32_field(5, optional=True)
    """
    sessionId is used by the controller to determine if the driver has rebooted
     inbetween two driverstate messages sessionId must always be updated on
     booting
    """

    is_connected: Optional[bool] = betterproto.bool_field(6, optional=True)
    input_voltage: Optional[float] = betterproto.float_field(7, optional=True)
    is_calibration_data_ok: Optional[bool] = betterproto.bool_field(8, optional=True)
    reset_reason_value: Optional[int] = betterproto.uint32_field(9, optional=True)


@dataclass(eq=False, repr=False)
class IntensityMessage(betterproto.Message):
    intensity: Optional[float] = betterproto.float_field(1, optional=True)
    light_output_type: Optional["IntensityMessageLightOutputType"] = (
        betterproto.enum_field(2, optional=True)
    )
    update_light_output: Optional[bool] = betterproto.bool_field(3, optional=True)
    smooth_intensity: Optional[bool] = betterproto.bool_field(4, optional=True)
    """just set new itensity config"""

    smooth_intensity_duration_ms: Optional[int] = betterproto.int32_field(
        5, optional=True
    )
    """intermediate outputs"""


@dataclass(eq=False, repr=False)
class PlayBoostMessage(betterproto.Message):
    power_mode: Optional["PlayBoostMessagePlayPowerMode"] = betterproto.enum_field(
        1, optional=True
    )


@dataclass(eq=False, repr=False)
class FlashEmitterMessage(betterproto.Message):
    intensity: Optional[float] = betterproto.float_field(1, optional=True)
    delay_before_applying_flash_ms: Optional[int] = betterproto.uint32_field(
        2, optional=True
    )
    duration_of_light_on: Optional[int] = betterproto.uint32_field(3, optional=True)
    x: Optional[float] = betterproto.float_field(4, optional=True)
    y: Optional[float] = betterproto.float_field(5, optional=True)


@dataclass(eq=False, repr=False)
class CctMessage(betterproto.Message):
    cct: Optional[int] = betterproto.uint32_field(1, optional=True)
    tint: Optional[float] = betterproto.float_field(2, optional=True)


@dataclass(eq=False, repr=False)
class RgbMessage(betterproto.Message):
    red: Optional[float] = betterproto.float_field(1, optional=True)
    green: Optional[float] = betterproto.float_field(2, optional=True)
    blue: Optional[float] = betterproto.float_field(3, optional=True)
    color_space: Optional["RgbColorSpace"] = betterproto.enum_field(4, optional=True)
    white_point: Optional[int] = betterproto.uint32_field(5, optional=True)


@dataclass(eq=False, repr=False)
class HsiMessage(betterproto.Message):
    hue: Optional[float] = betterproto.float_field(1, optional=True)
    saturation: Optional[float] = betterproto.float_field(2, optional=True)
    intensity: Optional[float] = betterproto.float_field(3, optional=True)
    color_space: Optional["RgbColorSpace"] = betterproto.enum_field(4, optional=True)
    white_point: Optional[int] = betterproto.uint32_field(5, optional=True)


@dataclass(eq=False, repr=False)
class XyMessage(betterproto.Message):
    x: Optional[float] = betterproto.float_field(1, optional=True)
    y: Optional[float] = betterproto.float_field(2, optional=True)


@dataclass(eq=False, repr=False)
class RgbaclMessage(betterproto.Message):
    red: Optional[float] = betterproto.float_field(1, optional=True)
    green: Optional[float] = betterproto.float_field(2, optional=True)
    blue: Optional[float] = betterproto.float_field(3, optional=True)
    amber: Optional[float] = betterproto.float_field(4, optional=True)
    cyan: Optional[float] = betterproto.float_field(5, optional=True)
    lime: Optional[float] = betterproto.float_field(6, optional=True)


@dataclass(eq=False, repr=False)
class GelFileMessage(betterproto.Message):
    brand_name: Optional[str] = betterproto.string_field(1, optional=True)
    category_name: Optional[str] = betterproto.string_field(2, optional=True)
    gel_name: Optional[str] = betterproto.string_field(3, optional=True)
    gel_swatch_number: Optional[str] = betterproto.string_field(4, optional=True)
    index_in_category: Optional[int] = betterproto.uint32_field(5, optional=True)
    lin_interp_ccts: List[float] = betterproto.float_field(6)
    lin_interp_x_coeffs: List[float] = betterproto.float_field(7)
    lin_interp_y_coeffs: List[float] = betterproto.float_field(8)
    display_rgb_red: Optional[int] = betterproto.uint32_field(9, optional=True)
    display_rgb_green: Optional[int] = betterproto.uint32_field(10, optional=True)
    display_rgb_blue: Optional[int] = betterproto.uint32_field(11, optional=True)


@dataclass(eq=False, repr=False)
class GelStateMessage(betterproto.Message):
    brand_name: Optional[str] = betterproto.string_field(1, optional=True)
    category_name: Optional[str] = betterproto.string_field(2, optional=True)
    gel_file_name: Optional[str] = betterproto.string_field(3, optional=True)
    gel_index: Optional[int] = betterproto.uint32_field(4, optional=True)
    category_page: Optional[int] = betterproto.uint32_field(5, optional=True)
    cct: Optional[int] = betterproto.uint32_field(6, optional=True)


@dataclass(eq=False, repr=False)
class GelSetMessage(betterproto.Message):
    gel_brand_category: Optional["GelBrandCategory"] = betterproto.enum_field(
        1, optional=True
    )
    gel_index: Optional[int] = betterproto.uint32_field(2, optional=True)
    cct: Optional[int] = betterproto.uint32_field(3, optional=True)


@dataclass(eq=False, repr=False)
class CrossfadeCcthsiMessage(betterproto.Message):
    crossfade: Optional[float] = betterproto.float_field(1, optional=True)
    cct: Optional["CctMessage"] = betterproto.message_field(2, optional=True)
    hsi: Optional["HsiMessage"] = betterproto.message_field(3, optional=True)


@dataclass(eq=False, repr=False)
class CrossfadeCctrgbMessage(betterproto.Message):
    crossfade: Optional[float] = betterproto.float_field(1, optional=True)
    cct: Optional["CctMessage"] = betterproto.message_field(2, optional=True)
    rgb: Optional["RgbMessage"] = betterproto.message_field(3, optional=True)


@dataclass(eq=False, repr=False)
class CctAndRgbMessage(betterproto.Message):
    cct: Optional["CctMessage"] = betterproto.message_field(1, optional=True)
    """
    This sets a cct with a certain intensity and adds r,g,b leds to that cct
    """

    cct_intensity: Optional[float] = betterproto.float_field(2, optional=True)
    red: Optional[float] = betterproto.float_field(3, optional=True)
    green: Optional[float] = betterproto.float_field(4, optional=True)
    blue: Optional[float] = betterproto.float_field(5, optional=True)


@dataclass(eq=False, repr=False)
class SetEmitterChannelsMessage(betterproto.Message):
    output_value: List[float] = betterproto.float_field(1)
    verify_outputs: Optional[bool] = betterproto.bool_field(2, optional=True)


@dataclass(eq=False, repr=False)
class FanMessage(betterproto.Message):
    id: Optional[int] = betterproto.int32_field(1, optional=True)
    is_on: Optional[bool] = betterproto.bool_field(2, optional=True)
    speed_percent: Optional[float] = betterproto.float_field(3, optional=True)
    speed_rpm: Optional[int] = betterproto.int32_field(4, optional=True)
    min_rpm: Optional[int] = betterproto.int32_field(5, optional=True)
    max_rpm: Optional[int] = betterproto.int32_field(6, optional=True)


@dataclass(eq=False, repr=False)
class FanControllerMessage(betterproto.Message):
    mode: Optional["FanControllerMode"] = betterproto.enum_field(1, optional=True)
    manual_fan_duty_cycle: Optional[float] = betterproto.float_field(2, optional=True)


@dataclass(eq=False, repr=False)
class UploadFirmwareChunkMessage(betterproto.Message):
    address: Optional[int] = betterproto.uint32_field(1, optional=True)
    number_of_bytes: Optional[int] = betterproto.uint32_field(2, optional=True)
    data: List[int] = betterproto.uint32_field(3)


@dataclass(eq=False, repr=False)
class McuMgrMessage(betterproto.Message):
    """Tell Driver to swap images and reboot."""

    message_type: Optional["McuMgrMessageTypes"] = betterproto.enum_field(
        1, optional=True
    )


@dataclass(eq=False, repr=False)
class LightCompensationMessage(betterproto.Message):
    temperature_compensation_state: Optional[bool] = betterproto.bool_field(
        1, optional=True
    )
    nonlinearity_compensation_state: Optional[bool] = betterproto.bool_field(
        2, optional=True
    )
    xy_drift_duty_cycle_compensation_state: Optional[bool] = betterproto.bool_field(
        3, optional=True
    )
    xy_drift_temperature_compensation_state: Optional[bool] = betterproto.bool_field(
        4, optional=True
    )


@dataclass(eq=False, repr=False)
class MaxWattDrawMessage(betterproto.Message):
    maximum_watt_draw: Optional[float] = betterproto.float_field(1, optional=True)


@dataclass(eq=False, repr=False)
class CurrentLightOutputMessage(betterproto.Message):
    max_y: Optional[float] = betterproto.float_field(1, optional=True)
    current_absolute_outputs: List[float] = betterproto.float_field(2)
    current_relative_outputs: List[float] = betterproto.float_field(3)
    x: Optional[float] = betterproto.float_field(4, optional=True)
    y: Optional[float] = betterproto.float_field(5, optional=True)
    intensity_message: Optional["IntensityMessage"] = betterproto.message_field(
        6, optional=True
    )
    current_emitter_temperature: Optional[float] = betterproto.float_field(
        7, optional=True
    )
    current_max_watt_draw_message: Optional["MaxWattDrawMessage"] = (
        betterproto.message_field(8, optional=True)
    )
    current_light_compensation_message: Optional["LightCompensationMessage"] = (
        betterproto.message_field(9, optional=True)
    )
    estimated_watt_draw: Optional[float] = betterproto.float_field(10, optional=True)
    estimated_non_linear_watt_draw: Optional[float] = betterproto.float_field(
        11, optional=True
    )
    dimming_curve: Optional["DimmingCurve"] = betterproto.enum_field(12, optional=True)
    dimming_curved_intensity: Optional[float] = betterproto.float_field(
        13, optional=True
    )


@dataclass(eq=False, repr=False)
class FireEffectParams(betterproto.Message):
    fire_type: Optional["FireEffectParamsFireType"] = betterproto.enum_field(
        1, optional=True
    )
    wind_type: Optional["FireEffectParamsWindType"] = betterproto.enum_field(
        2, optional=True
    )


@dataclass(eq=False, repr=False)
class CctChaseEffectParams(betterproto.Message):
    cct_start: Optional["CctMessage"] = betterproto.message_field(1, optional=True)
    cct_stop: Optional["CctMessage"] = betterproto.message_field(2, optional=True)
    duration_minutes: Optional[float] = betterproto.float_field(3, optional=True)
    duration_seconds: Optional[float] = betterproto.float_field(4, optional=True)
    loop_type: Optional["EffectLoopType"] = betterproto.enum_field(5, optional=True)


@dataclass(eq=False, repr=False)
class ColorChaseEffectParams(betterproto.Message):
    hue1: Optional[float] = betterproto.float_field(1, optional=True)
    hue2: Optional[float] = betterproto.float_field(2, optional=True)
    saturation: Optional[float] = betterproto.float_field(3, optional=True)
    intensity: Optional[float] = betterproto.float_field(4, optional=True)
    color_space: Optional["RgbColorSpace"] = betterproto.enum_field(5, optional=True)
    white_point: Optional[int] = betterproto.uint32_field(6, optional=True)
    duration_minutes: Optional[float] = betterproto.float_field(7, optional=True)
    duration_seconds: Optional[float] = betterproto.float_field(8, optional=True)
    loop_type: Optional["EffectLoopType"] = betterproto.enum_field(9, optional=True)


@dataclass(eq=False, repr=False)
class SirenEffectParams(betterproto.Message):
    color_combo: Optional["SirenColorCombination"] = betterproto.enum_field(
        1, optional=True
    )
    nr_of_flashes_per_color: Optional[int] = betterproto.uint32_field(2, optional=True)
    flash_duration: Optional["SirenFlashDuration"] = betterproto.enum_field(
        3, optional=True
    )
    speed: Optional["SirenSpeed"] = betterproto.enum_field(4, optional=True)


@dataclass(eq=False, repr=False)
class SequencingEffectParams(betterproto.Message):
    step1: Optional["SequencingEffectStep"] = betterproto.message_field(
        1, optional=True
    )
    step2: Optional["SequencingEffectStep"] = betterproto.message_field(
        2, optional=True
    )
    step3: Optional["SequencingEffectStep"] = betterproto.message_field(
        3, optional=True
    )
    step4: Optional["SequencingEffectStep"] = betterproto.message_field(
        4, optional=True
    )
    step5: Optional["SequencingEffectStep"] = betterproto.message_field(
        5, optional=True
    )
    number_of_steps: Optional[int] = betterproto.uint32_field(10, optional=True)
    """The active  number of steps in the sequence"""

    step_randomly: Optional[bool] = betterproto.bool_field(11, optional=True)
    """Whether to choose a random color at each step transition or not"""

    duration_randomization: Optional[float] = betterproto.float_field(13, optional=True)
    fade_duration_randomization: Optional[float] = betterproto.float_field(
        14, optional=True
    )
    """or down"""

    intensity_factor_randomization: Optional[float] = betterproto.float_field(
        15, optional=True
    )
    """or down"""


@dataclass(eq=False, repr=False)
class SequencingEffectStep(betterproto.Message):
    color: Optional["MultiColorCompressedMessage"] = betterproto.message_field(
        1, optional=True
    )
    intensity_factor: Optional[float] = betterproto.float_field(2, optional=True)
    duration_seconds: Optional[float] = betterproto.float_field(3, optional=True)
    fade_duration_seconds: Optional[float] = betterproto.float_field(4, optional=True)


@dataclass(eq=False, repr=False)
class MultiColorCompressedMessage(betterproto.Message):
    cct: "CctMessage" = betterproto.message_field(1, group="color")
    rgb: "RgbMessage" = betterproto.message_field(2, group="color")
    hsi: "HsiMessage" = betterproto.message_field(3, group="color")
    xy: "XyMessage" = betterproto.message_field(4, group="color")


@dataclass(eq=False, repr=False)
class MultiColorMessage(betterproto.Message):
    selected_color_type: Optional["ColorType"] = betterproto.enum_field(
        1, optional=True
    )
    cct: Optional["CctMessage"] = betterproto.message_field(2, optional=True)
    rgb: Optional["RgbMessage"] = betterproto.message_field(3, optional=True)
    hsi: Optional["HsiMessage"] = betterproto.message_field(4, optional=True)
    xy: Optional["XyMessage"] = betterproto.message_field(5, optional=True)


@dataclass(eq=False, repr=False)
class PulseEffectParams(betterproto.Message):
    color: Optional["MultiColorMessage"] = betterproto.message_field(1, optional=True)
    pulses_per_minute: Optional[int] = betterproto.uint32_field(2, optional=True)
    pulse_type: Optional["PulseType"] = betterproto.enum_field(3, optional=True)


@dataclass(eq=False, repr=False)
class StrobeEffectParams(betterproto.Message):
    color: Optional["MultiColorMessage"] = betterproto.message_field(1, optional=True)
    strobes_per_minute: Optional[int] = betterproto.uint32_field(2, optional=True)
    flash_duration: Optional[int] = betterproto.uint32_field(3, optional=True)


@dataclass(eq=False, repr=False)
class DimmingEffectParams(betterproto.Message):
    color: Optional["MultiColorMessage"] = betterproto.message_field(1, optional=True)
    starting_intensity: Optional[float] = betterproto.float_field(2, optional=True)
    stopping_intensity: Optional[float] = betterproto.float_field(3, optional=True)
    dimming_curve: Optional["PulseType"] = betterproto.enum_field(4, optional=True)
    idle_at_starting_intensity_seconds: Optional[float] = betterproto.float_field(
        5, optional=True
    )
    dimming_duration_minutes: Optional[float] = betterproto.float_field(
        6, optional=True
    )
    dimming_duration_seconds: Optional[float] = betterproto.float_field(
        7, optional=True
    )
    loop_type: Optional["EffectLoopType"] = betterproto.enum_field(8, optional=True)


@dataclass(eq=False, repr=False)
class LightningEffectParams(betterproto.Message):
    color: Optional["MultiColorMessage"] = betterproto.message_field(1, optional=True)
    color_deviation: Optional[float] = betterproto.float_field(2, optional=True)
    storm_intensity: Optional[float] = betterproto.float_field(3, optional=True)


@dataclass(eq=False, repr=False)
class LightEffectParamMessage(betterproto.Message):
    fire_params: "FireEffectParams" = betterproto.message_field(1, group="param_type")
    cct_chase_params: "CctChaseEffectParams" = betterproto.message_field(
        2, group="param_type"
    )
    color_chase_params: "ColorChaseEffectParams" = betterproto.message_field(
        3, group="param_type"
    )
    siren_params: "SirenEffectParams" = betterproto.message_field(4, group="param_type")
    pulse_params: "PulseEffectParams" = betterproto.message_field(5, group="param_type")
    strobe_params: "StrobeEffectParams" = betterproto.message_field(
        6, group="param_type"
    )
    lightning_params: "LightningEffectParams" = betterproto.message_field(
        7, group="param_type"
    )
    dimming_params: "DimmingEffectParams" = betterproto.message_field(
        8, group="param_type"
    )
    sequence_params: "SequencingEffectParams" = betterproto.message_field(
        9, group="param_type"
    )


@dataclass(eq=False, repr=False)
class LightEffectMessage(betterproto.Message):
    light_effect: Optional["LightEffectType"] = betterproto.enum_field(1, optional=True)
    control_state: Optional["LightEffectState"] = betterproto.enum_field(
        2, optional=True
    )
    params: Optional["LightEffectParamMessage"] = betterproto.message_field(
        3, optional=True
    )


@dataclass(eq=False, repr=False)
class LightEffectModeStateMessage(betterproto.Message):
    navigation_state: Optional["EffectNavigationState"] = betterproto.enum_field(
        1, optional=True
    )
    selected_effect: Optional["LightEffectType"] = betterproto.enum_field(
        2, optional=True
    )
    control_state: Optional["LightEffectState"] = betterproto.enum_field(
        3, optional=True
    )
    fire_effect_selected_variable: Optional[int] = betterproto.uint32_field(
        7, optional=True
    )
    cct_chase_effect_selected_variable: Optional[int] = betterproto.uint32_field(
        8, optional=True
    )
    color_chase_effect_selected_variable: Optional[int] = betterproto.uint32_field(
        9, optional=True
    )
    siren_effect_selected_variable: Optional[int] = betterproto.uint32_field(
        10, optional=True
    )
    pulse_effect_selected_variable: Optional[int] = betterproto.uint32_field(
        11, optional=True
    )
    strobe_effect_selected_variable: Optional[int] = betterproto.uint32_field(
        12, optional=True
    )
    lightning_effect_selected_variable: Optional[int] = betterproto.uint32_field(
        13, optional=True
    )
    dimming_effect_selected_variable: Optional[int] = betterproto.uint32_field(
        14, optional=True
    )
    sequence_effect_selected_variable: Optional[int] = betterproto.uint32_field(
        15, optional=True
    )


@dataclass(eq=False, repr=False)
class DimmingCurveMessage(betterproto.Message):
    dimming_curve: Optional["DimmingCurve"] = betterproto.enum_field(1, optional=True)


@dataclass(eq=False, repr=False)
class DeviceHwCodeMessage(betterproto.Message):
    hardware_code: Optional[int] = betterproto.uint32_field(1, optional=True)
    hardware_code_analog: Optional[float] = betterproto.float_field(2, optional=True)


@dataclass(eq=False, repr=False)
class NackMessage(betterproto.Message):
    nack_hack_id: Optional[int] = betterproto.uint32_field(1, optional=True)
    reason: Optional[int] = betterproto.int32_field(2, optional=True)


@dataclass(eq=False, repr=False)
class BleTestingMessage(betterproto.Message):
    ble_test_request: Optional["BleTestingMessageBleTestRequest"] = (
        betterproto.enum_field(1, optional=True)
    )
    device_serial_number: Optional["SerialNumberMessage"] = betterproto.message_field(
        2, optional=True
    )
    result_rssi: Optional[int] = betterproto.int32_field(3, optional=True)


@dataclass(eq=False, repr=False)
class RawLedDeltasMessage(betterproto.Message):
    led_deltas_x: List[float] = betterproto.float_field(1)
    led_deltas_y: List[float] = betterproto.float_field(2)
    led_deltas_big_y: List[float] = betterproto.float_field(3)


@dataclass(eq=False, repr=False)
class LightAccessoryMessage(betterproto.Message):
    light_accessory_type: Optional["LightAccessoryType"] = betterproto.enum_field(
        1, optional=True
    )


@dataclass(eq=False, repr=False)
class GetLightPresetByIndexRequest(betterproto.Message):
    """
    This can be used to get all the presets on a light. Start by requesting index
    0 to get the first preset + the count. Then keep requesting higher indexes
    until num_presets is reached
    """

    index: Optional[int] = betterproto.uint32_field(1, optional=True)


@dataclass(eq=False, repr=False)
class GetLightPresetByIndexResponse(betterproto.Message):
    success: Optional[bool] = betterproto.bool_field(1, optional=True)
    does_not_exist: Optional[bool] = betterproto.bool_field(2, optional=True)
    index: Optional[int] = betterproto.uint32_field(3, optional=True)
    num_presets: Optional[int] = betterproto.uint32_field(4, optional=True)
    preset: Optional["LightPresetMessage"] = betterproto.message_field(5, optional=True)


@dataclass(eq=False, repr=False)
class GetLightPresetByIdRequest(betterproto.Message):
    preset_id: Optional[int] = betterproto.uint64_field(1, optional=True)


@dataclass(eq=False, repr=False)
class GetLightPresetByIdResponse(betterproto.Message):
    success: Optional[bool] = betterproto.bool_field(1, optional=True)
    does_not_exist: Optional[bool] = betterproto.bool_field(2, optional=True)
    preset: Optional["LightPresetMessage"] = betterproto.message_field(3, optional=True)


@dataclass(eq=False, repr=False)
class SetLightPresetRequest(betterproto.Message):
    force_set: Optional[bool] = betterproto.bool_field(1, optional=True)
    preset: Optional["LightPresetMessage"] = betterproto.message_field(2, optional=True)


@dataclass(eq=False, repr=False)
class SetLightPresetResponse(betterproto.Message):
    success: Optional[bool] = betterproto.bool_field(1, optional=True)
    already_exists: Optional[bool] = betterproto.bool_field(2, optional=True)
    """
    This can be used to request the user to acknowledge overwriting the preset.
    f.ex: App tries to set a preset, it exists, prompt the user on the app if
    they want to overwrite it or not. If yes, send SetLightPresetRequest again
    with force_set = true
    """

    presets_full: Optional[bool] = betterproto.bool_field(3, optional=True)
    num_presets: Optional[int] = betterproto.uint32_field(4, optional=True)


@dataclass(eq=False, repr=False)
class LightPresetMessage(betterproto.Message):
    version: Optional[int] = betterproto.uint32_field(1, optional=True)
    preset_id: Optional[int] = betterproto.uint64_field(2, optional=True)
    name: Optional[str] = betterproto.string_field(3, optional=True)
    """string (16 characters, remember to pad 0s)"""

    created_on: Optional["ProductType"] = betterproto.enum_field(4, optional=True)
    intensity: Optional["IntensityMessage"] = betterproto.message_field(
        5, optional=True
    )
    cct: "CctMessage" = betterproto.message_field(10, group="mode_message")
    rgb: "RgbMessage" = betterproto.message_field(11, group="mode_message")
    hsi: "HsiMessage" = betterproto.message_field(12, group="mode_message")
    xy: "XyMessage" = betterproto.message_field(13, group="mode_message")
    gel: "GelSetMessage" = betterproto.message_field(14, group="mode_message")
    effect: "LightEffectMessage" = betterproto.message_field(15, group="mode_message")
    light_accessory_type: Optional["LightAccessoryType"] = betterproto.enum_field(
        30, optional=True
    )
    """!ONLY! settings that affect the light output"""

    boost_mode_active: Optional[bool] = betterproto.bool_field(31, optional=True)
    dimming_curve: Optional["DimmingCurve"] = betterproto.enum_field(32, optional=True)
    fan_mode: Optional["FanControllerMode"] = betterproto.enum_field(33, optional=True)


@dataclass(eq=False, repr=False)
class DriverMessage(betterproto.Message):
    relay_to_lamp_head: Optional[bool] = betterproto.bool_field(150, optional=True)
    """
    Epos 300: used to pass a message through the controller to the lamphead
     The controller will send the contained driverMessage to the lamphead, and
     reply with the response.
    """

    expects_response: Optional[bool] = betterproto.bool_field(151, optional=True)
    """
    The sender expects the receiver of the driver message to reply if this is
     true. Reply can be either data + ack or only ack
    """

    intensity_config: Optional["IntensityMessage"] = betterproto.message_field(
        1, optional=True
    )
    request: "RequestMessage" = betterproto.message_field(2, group="message_type")
    cct: "CctMessage" = betterproto.message_field(3, group="message_type")
    rgb: "RgbMessage" = betterproto.message_field(4, group="message_type")
    hsi: "HsiMessage" = betterproto.message_field(5, group="message_type")
    xy: "XyMessage" = betterproto.message_field(6, group="message_type")
    gel: "GelSetMessage" = betterproto.message_field(7, group="message_type")
    effect: "LightEffectMessage" = betterproto.message_field(8, group="message_type")
    crossfade_ccthsi: "CrossfadeCcthsiMessage" = betterproto.message_field(
        9, group="message_type"
    )
    crossfade_cctrgb: "CrossfadeCctrgbMessage" = betterproto.message_field(
        10, group="message_type"
    )
    cct_and_rgb: "CctAndRgbMessage" = betterproto.message_field(
        11, group="message_type"
    )
    rgbacl: "RgbaclMessage" = betterproto.message_field(12, group="message_type")
    command_message: "CommandMessage" = betterproto.message_field(
        15, group="message_type"
    )
    set_emitter_channels: "SetEmitterChannelsMessage" = betterproto.message_field(
        16, group="message_type"
    )
    """-- Less used messages should have tags > 15 -- //"""

    firmware_chunk: "UploadFirmwareChunkMessage" = betterproto.message_field(
        25, group="message_type"
    )
    mcu_mgr: "McuMgrMessage" = betterproto.message_field(26, group="message_type")
    light_compensation_message: "LightCompensationMessage" = betterproto.message_field(
        27, group="message_type"
    )
    max_watt_draw_message: "MaxWattDrawMessage" = betterproto.message_field(
        28, group="message_type"
    )
    dimming_curve_message: "DimmingCurveMessage" = betterproto.message_field(
        29, group="message_type"
    )
    fan_message: "FanMessage" = betterproto.message_field(35, group="message_type")
    fan_controller_message: "FanControllerMessage" = betterproto.message_field(
        36, group="message_type"
    )
    flash_emitter_message: "FlashEmitterMessage" = betterproto.message_field(
        37, group="message_type"
    )
    emitter_output_message: "EmitterOutputMessage" = betterproto.message_field(
        38, group="message_type"
    )
    play_boost_message: "PlayBoostMessage" = betterproto.message_field(
        39, group="message_type"
    )
    light_settings_message: "LightSettingsMessage" = betterproto.message_field(
        40, group="message_type"
    )
    raw_led_deltas_message: "RawLedDeltasMessage" = betterproto.message_field(
        41, group="message_type"
    )
    light_accessory_message: "LightAccessoryMessage" = betterproto.message_field(
        42, group="message_type"
    )
    get_light_preset_by_index_request: "GetLightPresetByIndexRequest" = (
        betterproto.message_field(43, group="message_type")
    )
    get_light_preset_by_id_request: "GetLightPresetByIdRequest" = (
        betterproto.message_field(44, group="message_type")
    )
    set_light_preset_request: "SetLightPresetRequest" = betterproto.message_field(
        45, group="message_type"
    )
    firmware_packet_message: "FirmwarePacketMessage" = betterproto.message_field(
        50, group="message_type"
    )
    c_data_channel_basic_message: "CalibrationDataChannelBasicMessage" = (
        betterproto.message_field(100, group="message_type")
    )
    """Calibration related messages"""

    c_data_light_basic_message: "CalibrationDataLightBasicMessage" = (
        betterproto.message_field(101, group="message_type")
    )
    c_data_channel_array_message: "CalibrationDataChannelArrayMessage" = (
        betterproto.message_field(102, group="message_type")
    )
    c_data_lin_interp_message: "CalibrationDataLinearInterpolationMessage" = (
        betterproto.message_field(103, group="message_type")
    )
    ble_testing_message: "BleTestingMessage" = betterproto.message_field(
        104, group="message_type"
    )


@dataclass(eq=False, repr=False)
class LightSettingsMessage(betterproto.Message):
    dmx_address: Optional[int] = betterproto.int32_field(1, optional=True)
    dmx_mode: Optional["PbDmxMode"] = betterproto.enum_field(2, optional=True)
    dmx_profile: Optional[int] = betterproto.int32_field(3, optional=True)
    dmx_dropout_mode: Optional["PbDmxDropoutMode"] = betterproto.enum_field(
        4, optional=True
    )
    dmx_dropout_time_s: Optional[int] = betterproto.int32_field(5, optional=True)
    dmx_intentisy_smoothing_ms: Optional[int] = betterproto.int32_field(
        6, optional=True
    )
    crmx_enabled: Optional[bool] = betterproto.bool_field(10, optional=True)
    crmx_tx_power: Optional[int] = betterproto.int32_field(11, optional=True)
    crmx_connection_status: Optional["PbLumenConnectionStatus"] = (
        betterproto.enum_field(12, optional=True)
    )
    crmx_is_linked: Optional[bool] = betterproto.bool_field(13, optional=True)
    crmx_link_quality: Optional[int] = betterproto.uint32_field(14, optional=True)
    artnet_sacn_state: Optional["PbArtNetSacnState"] = betterproto.enum_field(
        25, optional=True
    )
    artnet_net: Optional[int] = betterproto.int32_field(26, optional=True)
    artnet_subnet: Optional[int] = betterproto.int32_field(27, optional=True)
    artnet_universe: Optional[int] = betterproto.int32_field(28, optional=True)
    sacn_universe: Optional[int] = betterproto.int32_field(29, optional=True)
    ethernet_ip_mode: Optional["PbEthernetIpMode"] = betterproto.enum_field(
        30, optional=True
    )
    ethernet_ip_address: Optional[int] = betterproto.uint32_field(31, optional=True)
    ethernet_ip_subnet_mask: Optional[int] = betterproto.uint32_field(32, optional=True)
    btle_max_connections: Optional[int] = betterproto.int32_field(40, optional=True)
    charge_on_dc: Optional["PbChargeOnDcSetting"] = betterproto.enum_field(
        50, optional=True
    )
    fan_mode: Optional["FanControllerMode"] = betterproto.enum_field(60, optional=True)
    dimming_curve: Optional["DimmingCurve"] = betterproto.enum_field(61, optional=True)
    boost_mode_active: Optional[bool] = betterproto.bool_field(62, optional=True)
    light_accessory: Optional["LightAccessoryType"] = betterproto.enum_field(
        63, optional=True
    )
    play_orientation_lock: Optional["PbOrientationLockSetting"] = (
        betterproto.enum_field(71, optional=True)
    )
    play_color_space: Optional["RgbColorSpace"] = betterproto.enum_field(
        72, optional=True
    )
    play_white_point: Optional[int] = betterproto.int32_field(73, optional=True)
