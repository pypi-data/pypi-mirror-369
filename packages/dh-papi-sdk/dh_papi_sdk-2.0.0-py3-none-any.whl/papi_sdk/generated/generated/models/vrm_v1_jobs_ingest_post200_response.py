# coding: utf-8

"""
    Salesforce Platform API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class VrmV1JobsIngestPost200Response(BaseModel):
    """
    Create job response
    """ # noqa: E501
    api_version: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The API version that the job was created in.", alias="apiVersion")
    concurrency_mode: Optional[StrictStr] = Field(default=None, description="For future use. How the request was processed. Currently only parallel mode is supported. (When other modes are added, the mode will be chosen automatically by the API and will not be user configurable.) ", alias="concurrencyMode")
    content_url: Optional[StrictStr] = Field(default=None, description="The URL to use for Upload Job Data requests for this job. Only valid if the job is in Open state.", alias="contentUrl")
    created_by_id: Optional[StrictStr] = Field(default=None, description="The ID of the user who created the job.", alias="createdById")
    created_date: Optional[StrictStr] = Field(default=None, description="The date and time in the UTC time zone when the job was created.", alias="createdDate")
    id: Optional[StrictStr] = Field(default=None, description="Unique ID for this job.")
    job_type: Optional[StrictStr] = Field(default=None, description="The jobâ€™s type.", alias="jobType")
    state: Optional[StrictStr] = Field(default=None, description="The current state of processing for the job")
    system_modstamp: Optional[StrictStr] = Field(default=None, description="Date and time in the UTC time zone when the job finished.", alias="systemModstamp")
    object: Optional[StrictStr] = Field(default=None, description="The object type for the data being processed. Use only a single object type per job.")
    operation: Optional[StrictStr] = Field(default=None, description="The processing operation for the job.")
    assignment_rule: Optional[StrictStr] = Field(default=None, description="The ID of an assignment rule to run for a Case or a Lead. The assignment rule can be active or inactive. The ID can be retrieved by using the Lightning Platform SOAP API or the Lightning Platform REST API to query the AssignmentRule object. ", alias="assignmentRule")
    column_delimiter: Optional[StrictStr] = Field(default=None, description="The column delimiter used for CSV job data. The default value is COMMA.", alias="columnDelimiter")
    content_type: Optional[StrictStr] = Field(default=None, description="The content type for the job. The only valid value (and the default) is CSV.", alias="contentType")
    external_id_field_name: Optional[StrictStr] = Field(default=None, description="The external ID field in the object being updated. Only needed for upsert operations. Field values must also exist in CSV job data. Required for upsert operations. ", alias="externalIdFieldName")
    line_ending: Optional[StrictStr] = Field(default=None, description="The line ending used for CSV job data, marking the end of a data row. The default is LF.", alias="lineEnding")
    __properties: ClassVar[List[str]] = ["apiVersion", "concurrencyMode", "contentUrl", "createdById", "createdDate", "id", "jobType", "state", "systemModstamp", "object", "operation", "assignmentRule", "columnDelimiter", "contentType", "externalIdFieldName", "lineEnding"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of VrmV1JobsIngestPost200Response from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of VrmV1JobsIngestPost200Response from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "apiVersion": obj.get("apiVersion"),
            "concurrencyMode": obj.get("concurrencyMode"),
            "contentUrl": obj.get("contentUrl"),
            "createdById": obj.get("createdById"),
            "createdDate": obj.get("createdDate"),
            "id": obj.get("id"),
            "jobType": obj.get("jobType"),
            "state": obj.get("state"),
            "systemModstamp": obj.get("systemModstamp"),
            "object": obj.get("object"),
            "operation": obj.get("operation"),
            "assignmentRule": obj.get("assignmentRule"),
            "columnDelimiter": obj.get("columnDelimiter"),
            "contentType": obj.get("contentType"),
            "externalIdFieldName": obj.get("externalIdFieldName"),
            "lineEnding": obj.get("lineEnding")
        })
        return _obj


