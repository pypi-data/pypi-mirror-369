# coding: utf-8

"""
    Salesforce Platform API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class VrmV1JobsIngestPostRequest(BaseModel):
    """
    VrmV1JobsIngestPostRequest
    """ # noqa: E501
    object: StrictStr = Field(description="The object type for the data being processed. Use only a single object type per job. ")
    operation: StrictStr = Field(description="The processing operation for the job.")
    assignment_rule: Optional[StrictStr] = Field(default=None, description="The ID of an assignment rule to run for a Case or a Lead. The assignment rule can be active or inactive. The ID can be retrieved by using the Lightning Platform SOAP API or the Lightning Platform REST API to query the AssignmentRule object. ", alias="assignmentRule")
    column_delimiter: Optional[StrictStr] = Field(default=None, description="The column delimiter used for CSV job data. The default value is COMMA. ", alias="columnDelimiter")
    content_type: Optional[StrictStr] = Field(default=None, description="The content type for the job. The only valid value (and the default) is CSV.", alias="contentType")
    external_id_field_name: Optional[StrictStr] = Field(default=None, description="The external ID field in the object being updated. Only needed for upsert operations. Field values must also exist in CSV job data. Required for upsert operations. ", alias="externalIdFieldName")
    line_ending: Optional[StrictStr] = Field(default=None, description="The line ending used for CSV job data, marking the end of a data row. The default is LF.", alias="lineEnding")
    __properties: ClassVar[List[str]] = ["object", "operation", "assignmentRule", "columnDelimiter", "contentType", "externalIdFieldName", "lineEnding"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of VrmV1JobsIngestPostRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of VrmV1JobsIngestPostRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "object": obj.get("object"),
            "operation": obj.get("operation"),
            "assignmentRule": obj.get("assignmentRule"),
            "columnDelimiter": obj.get("columnDelimiter"),
            "contentType": obj.get("contentType"),
            "externalIdFieldName": obj.get("externalIdFieldName"),
            "lineEnding": obj.get("lineEnding")
        })
        return _obj


