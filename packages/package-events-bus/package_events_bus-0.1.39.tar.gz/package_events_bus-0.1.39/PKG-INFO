Metadata-Version: 2.3
Name: package-events-bus
Version: 0.1.39
Summary: Una librer√≠a para construir microservicios desacoplados en Python usando AWS EventBridge y SQS, donde cada caso de uso maneja su propia cola y se despacha autom√°ticamente mediante handlers tipados.
License: MIT
Author: Jose Luis Rosales Meza
Author-email: jose.rosales@finkargo.com
Requires-Python: >=3.10,<4.0
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Requires-Dist: boto3 (>=1.38.13,<2.0.0)
Requires-Dist: mangum (>=0.19.0,<0.20.0)
Requires-Dist: pytest (>=8.4.0,<9.0.0)
Requires-Dist: python-dotenv (>=1.1.0,<2.0.0)
Requires-Dist: redis (>=5.0,<6.0)
Description-Content-Type: text/markdown

# üì¶ Package Events Bus

Una librer√≠a para construir servicios desacoplados en Python usando AWS EventBridge y SQS, donde cada caso de uso maneja su propia cola.

---

## ÔøΩ Tabla de Contenidos

- [üì¶ Package Events Bus](#-package-events-bus)
  - [ÔøΩ Tabla de Contenidos](#-tabla-de-contenidos)
  - [üìù Descripci√≥n](#-descripci√≥n)
  - [‚öôÔ∏è Instalaci√≥n](#Ô∏è-instalaci√≥n)
  - [üóÇÔ∏è Estructura del Proyecto](#Ô∏è-estructura-del-proyecto)
  - [üí° ¬øC√≥mo usarlo?](#-c√≥mo-usarlo)
    - [üì§ Publicar eventos](#-publicar-eventos)
    - [üîÑ Cambiar failover y regi√≥n AWS din√°micamente](#-cambiar-failover-y-regi√≥n-aws-din√°micamente)
      - [üõ°Ô∏è Uso de Failover para eventos no publicados](#Ô∏è-uso-de-failover-para-eventos-no-publicados)
    - [üì• Consumir eventos](#-consumir-eventos)
      - [Opci√≥n 1: Consumir eventos con m√∫ltiples colas por caso de uso](#opci√≥n-1-consumir-eventos-con-m√∫ltiples-colas-por-caso-de-uso)
      - [Opci√≥n 2: Consumir eventos usando una sola cola por microservicio](#opci√≥n-2-consumir-eventos-usando-una-sola-cola-por-microservicio)
      - [Opci√≥n 3: Usar Mangum para AWS Lambda (SQS/EventBridge)](#opci√≥n-3-usar-mangum-para-aws-lambda-sqseventbridge)
    - [‚ö° ¬øC√≥mo implementar el dispatcher en FastAPI?](#-c√≥mo-implementar-el-dispatcher-en-fastapi)
      - [Opci√≥n 1: Cola de SQS por caso de uso](#opci√≥n-1-cola-de-sqs-por-caso-de-uso)
      - [Opci√≥n 2: Una cola SQS por microservicio](#opci√≥n-2-una-cola-sqs-por-microservicio)
    - [üõ°Ô∏è Opcional: Configuraci√≥n de Redis para deduplicaci√≥n](#Ô∏è-opcional-configuraci√≥n-de-redis-para-deduplicaci√≥n)
  - [‚öôÔ∏è Variables por Defecto](#Ô∏è-variables-por-defecto)
  - [üè∑Ô∏è Definici√≥n de Topics](#Ô∏è-definici√≥n-de-topics)
  - [üõ†Ô∏è TODO](#Ô∏è-todo)
  - [üìù Buenas Pr√°cticas](#-buenas-pr√°cticas)
  - [üìÑ Licencia](#-licencia)

---

## üìù Descripci√≥n

Esta librer√≠a permite construir microservicios desacoplados en Python, facilitando la publicaci√≥n y consumo de eventos a trav√©s de AWS EventBridge y SQS. Cada caso de uso maneja su propia cola, permitiendo escalabilidad y mantenibilidad.

---

## ‚öôÔ∏è Instalaci√≥n

Instala la librer√≠a usando **pip**:

```bash
pip install package-events-bus
```

O usando **poetry**:

```bash
poetry add package-events-bus
```

---

## üóÇÔ∏è Estructura del Proyecto

```
package_events_bus/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ config.py
‚îú‚îÄ‚îÄ exceptions.py
‚îú‚îÄ‚îÄ .vscode/settings.json
‚îú‚îÄ‚îÄ aws/
‚îÇ   ‚îú‚îÄ‚îÄ event_bridge_publisher.py
‚îÇ   ‚îî‚îÄ‚îÄ sqs_dispatcher.py
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ contracts/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base_event.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deduplication.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ handler.py
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ event_bus_publisher.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ event_serializer.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ redis_deduplication.py
‚îÇ   ‚îî‚îÄ‚îÄ runtime/
‚îÇ       ‚îî‚îÄ‚îÄ event_register.py
```

- **/aws:** Implementaciones espec√≠ficas para servicios de AWS.
  - **event_bridge_publisher.py:** Publica eventos a AWS EventBridge.
  - **sqs_dispatcher.py:** Despacha mensajes de colas SQS y procesa eventos.

---

## üí° ¬øC√≥mo usarlo?

### üì§ Publicar eventos

1. Crea una instancia de `EventBridgePublisher` y llama a `publish` con el evento deseado. Puedes cambiar el mecanismo de failover y la regi√≥n AWS en cualquier momento usando los m√©todos `set_failover` y `set_aws_region`.

```python
from events_bus.aws.event_bridge_publisher import EventBridgePublisher

event_bridge_publisher = EventBridgePublisher(
    bus_name="finkargo-events",
    source="my.service",
)
 
# Cambiar el mecanismo de failover en tiempo de ejecuci√≥n
from events_bus.core.infrastructure.redis_failover import RedisFailover
failover = RedisFailover(url="redis://localhost:6379/0")
event_bridge_publisher.set_failover(failover)

# Cambiar la regi√≥n de AWS en tiempo de ejecuci√≥n
event_bridge_publisher.set_aws_region("us-west-2")
```

2. Define tu evento heredando de `BaseEvent`:
   Reemplaza `DisbursementCreatedEvent` con el nombre de tu evento, recuerda sobreescribir el m√©todo `to_dict` para serializar los atributos del evento que deseas enviar.

```python
from events_bus.core.contracts.base_event import BaseEvent

@dataclass
class DisbursementCreatedEvent(BaseEvent):
    event_name = 'finkargo.portfolio.1.event.disbursement.created'

    def __init__(self, disbursement):
        super().__init__(event_name=self.event_name)
        self.id_disbursement = disbursement.id_disbursement

    def to_dict(self) -> dict:
        return {
            'id_disbursement': self.id_disbursement
        }

    @classmethod
    def from_dict(cls, event_id: str, occurred_on, attributes: dict) -> "DisbursementCreatedEvent":
        return cls(disbursement_id=attributes.get('id_disbursement'))

event_bridge_publisher.publish(event=DisbursementCreatedEvent(instance))

```

---

### üîÑ Cambiar failover y regi√≥n AWS din√°micamente

Puedes modificar el mecanismo de failover y la regi√≥n AWS en cualquier momento despu√©s de crear la instancia:

```python
# Cambiar failover
event_bridge_publisher.set_failover(RedisFailover(url="redis://localhost:6379/0"))

# Cambiar regi√≥n AWS
event_bridge_publisher.set_aws_region("us-west-2")
```

---


#### üõ°Ô∏è Uso de Failover para eventos no publicados

Por defecto, la librer√≠a utiliza un failover local en memoria (`LocalFailover`) para almacenar eventos que no se pueden publicar en AWS. Si deseas un mecanismo persistente, puedes usar `RedisFailover` u otro personalizado.

```python
from events_bus.aws.event_bridge_publisher import EventBridgePublisher
from events_bus.core.infrastructure.redis_failover import RedisFailover

# Configura el failover con Redis (opcional, por defecto es LocalFailover en memoria)
failover = RedisFailover(url="redis://localhost:6379/0")

event_bridge_publisher = EventBridgePublisher(
    bus_name="finkargo-events",
    source="my.service",
    failover=failover  # Si omites este argumento, usar√° LocalFailover por defecto
)

# Publica tu evento normalmente
event_bridge_publisher.publish(event=DisbursementCreatedEvent(instance))

# Para reintentar publicar los eventos almacenados en failover:
event_bridge_publisher.publish_from_failover(total_events=10)
```

- Si ocurre un error al publicar el evento en AWS, este se almacena en el failover configurado (por defecto, local en memoria).
- Puedes reintentar la publicaci√≥n de los eventos almacenados usando `publish_from_failover`.

> Tambi√©n puedes implementar tu propio mecanismo de failover heredando de `BaseFailover`.

---

### üì• Consumir eventos

#### Opci√≥n 1: Consumir eventos con m√∫ltiples colas por caso de uso

1. Hereda de `AsyncHandler` o `SyncHandler` y sobrescribe el m√©todo `handle`.
    El m√©todo `handle` recibe el evento como par√°metro, recuerda que el evento debe heredar de `BaseEvent`,
    y el m√©todo `from_dict` debe estar implementado para poder deserializar el evento.

    Usa `AsyncHandler` para manejar eventos de forma as√≠ncrona y `SyncHandler` para eventos sincr√≥nicos.

```python
from events_bus.core import AsyncHandler

class CustomAsyncHandler(AsyncHandler):
    async def handle(self, event: DisbursementCreatedEvent):
        print(f"Handling event: {event.event_name}")
        print(f"Finished handling event: {event.event_name}")
```

2. Registra el handler en el bus de eventos:
    Usa `EventHandlerRegister` para registrar el handler y la cola SQS asociada, recuerda que el target debe ser configurado previamente en AWS.
    Para mas informaci√≥n sobre la configuraci√≥n de AWS, consulta la [documentaci√≥n oficial](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-targets.html).

```python
from events_bus.core import EventHandlerRegister
from events_bus.aws.sqs_dispatcher import SQSDispatcher

dispatcher = SQSDispatcher()
EventHandlerRegister.register_by_queue(
    queue_url='https://sqs.us-east-1.amazonaws.com/123456789012/my-queue',
    handler=CustomAsyncHandler()
)
```

---

#### Opci√≥n 2: Consumir eventos usando una sola cola por microservicio

Si quieres consumir solo una cola SQS por microservicio (y despachar a los handlers seg√∫n el tipo de evento), registra tus handlers por nombre de evento y usa `start_from_one_queue`:

```python
from events_bus.aws.sqs_dispatcher import SQSDispatcher
from events_bus.core import EventHandlerRegister, AsyncHandler

class CustomAsyncHandler(AsyncHandler):
    async def handle(self, event):
        print(f"Handling event: {event.event_name}")

# Registra el handler para el tipo de evento
EventHandlerRegister.register_handler(
    event_name='finkargo.portfolio.1.event.disbursement.created',
    handler=CustomAsyncHandler()
)

dispatcher = SQSDispatcher()

import asyncio

async def main():
    await dispatcher.start_from_one_queue('https://sqs.us-east-1.amazonaws.com/123456789012/my-queue')

asyncio.run(main())
```

- As√≠ solo consumes una cola por microservicio, y despachas a los handlers seg√∫n el tipo de evento recibido.

---

#### Opci√≥n 3: Usar Mangum para AWS Lambda (SQS/EventBridge)

Si tu microservicio se ejecuta como Lambda y recibe eventos desde SQS o EventBridge, puedes usar la integraci√≥n con Mangum:

```python
from events_bus.aws.mangum import MangumExtended
from events_bus.core import EventHandlerRegister, AsyncHandler

class CustomAsyncHandler(AsyncHandler):
    async def handle(self, event):
        print(f"Handling event: {event.event_name}")

# Registra el handler para el tipo de evento
EventHandlerRegister.register_handler(
    event_name='finkargo.portfolio.1.event.disbursement.created',
    handler=CustomAsyncHandler()
)

app = FastAPI()

handler = MangumExtended(app)
```

- Registra tus handlers usando `EventHandlerRegister.register_handler`.
- Mangum detectar√° autom√°ticamente si el evento proviene de SQS o EventBridge y despachar√° al handler correcto.
- AWS Lambda llamar√° a `handler(event, context)` y la librer√≠a despachar√° el evento al handler correspondiente.

---

### ‚ö° ¬øC√≥mo implementar el dispatcher en FastAPI?

#### Opci√≥n 1: Cola de SQS por caso de uso

Puedes consumir eventos en FastAPI usando m√∫ltiples colas SQS por caso de uso. Registra tus handlers y usa `start` para iniciar el dispatcher.

```python
@asynccontextmanager
async def lifespan(app: FastAPI):
    await dispatcher.start()
    yield
    dispatcher.stop()

app = FastAPI(lifespan=lifespan)

```

#### Opci√≥n 2: Una cola SQS por microservicio
Puedes consumir eventos usando una sola cola SQS por microservicio en FastAPI utilizando el m√©todo `start_from_one_queue` de `SQSDispatcher`. As√≠, tu microservicio solo escucha una cola y despacha a los handlers registrados seg√∫n el tipo de evento recibido.

```python
import asyncio

dispatcher = SQSDispatcher()

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Consumir solo una cola por microservicio
    task = asyncio.create_task(
        dispatcher.start_from_one_queue('https://sqs.us-east-1.amazonaws.com/123456789012/my-queue')
    )
    yield
    dispatcher.stop()
    await task

app = FastAPI(lifespan=lifespan)
```

---

### üõ°Ô∏è Opcional: Configuraci√≥n de Redis para deduplicaci√≥n

```python
from events_bus.core import RedisDeduplication
from events_bus.aws.sqs_dispatcher import SQSDispatcher

deduplication = RedisDeduplication(
    url='redis://localhost:6379/0',
    ttl=3600,
)

dispatcher = SQSDispatcher(deduplication=deduplication)
```

> Si no deseas usar Redis, puedes heredar de `BaseDeduplication` e implementar tu propia l√≥gica.

---

## ‚öôÔ∏è Variables por Defecto

```python
from events_bus import CONFIG
CONFIG.set_envs(os.environ, env_file='.env')
```

Puedes modificar las variables por defecto de la librer√≠a usando un archivo `.env` o configurando las variables de entorno directamente. Las variables configurables son:

| Variable                    | Tipo | Por defecto |Descripci√≥n                                                                 |
|-------------------------------|---------|----------------|-------------------------------------------------------------------------------|
| MAX_NUMBER_OF_MESSAGES         | int     | 5              | N√∫mero m√°ximo de mensajes a recibir por llamada.                              |
| WAIT_TIME_SECONDS              | int     | 10             | Tiempo de espera para recibir mensajes.                                       |
| VISIBILITY_TIMEOUT             | int     | 30             | Tiempo de visibilidad del mensaje en la cola.                                 |
| AWS_CLIENT_URL                 | str     | None           | URL del cliente de AWS (√∫til para LocalStack u otros entornos locales).       |
| AWS_REGION_NAME                | str     | us-east-1      | Regi√≥n de AWS.                                                                |
| SLEEP_BETWEEN_MESSAGES_SECONDS | float   | 0.1            | Tiempo de espera entre mensajes.                                              |
| ERROR_SLEEP_SECONDS            | int     | 5              | Tiempo de espera en caso de error.                                            |

> ‚ÑπÔ∏è **Tip:** Usa `.env` para mantener tu configuraci√≥n fuera del c√≥digo fuente.

---
## üè∑Ô∏è Definici√≥n de Topics

Los topics deben seguir la convenci√≥n:

```
COMPANY.SERVICE.VERSION.MESSAGE_TYPE.RESOURCE_NAME.(EVENT_COMMAND_NAME)
```

- **COMPANY:** Nombre de la empresa (`Finkargo` para internos).
- **SERVICE:** Servicio generador del evento.
- **VERSION:** Versi√≥n del topic.
- **MESSAGE_TYPE:** `command` o `event`.
- **RESOURCE_NAME:** Entidad relacionada.
- **EVENT_COMMAND_NAME:** Verbo en pasado para eventos (`created`), infinitivo para comandos (`create`).

**Regex de validaci√≥n:**

```
TOPIC_REGEX = "^[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+\.\d+\.(command|event)\.[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+$"
```

Basado en: [Topics Definition | AsyncApi](https://github.com/fmvilas/topic-definition)

---

## üõ†Ô∏è TODO

- [ ]  Mejorar el control de excepciones en la publicaci√≥n de eventos.
- [ ]  Agregar m√°s ejemplos de integraci√≥n con otros frameworks.
- [ ]  Documentar casos de uso avanzados.
- [ ]  Implementar m√©tricas y logging para los eventos publicados y consumidos.
- [ ]  A√±adir pruebas unitarias y de integraci√≥n.
- [ ]  Mejorar la documentaci√≥n en ingl√©s y espa√±ol.

---

## üìù Buenas Pr√°cticas

- Usa nombres de eventos claros y consistentes.
- Implementa deduplicaci√≥n para evitar procesar eventos repetidos.
- Mant√©n tus handlers simples y enfocados en una sola responsabilidad.
- Documenta tus eventos y handlers.

---
## üìÑ Licencia

Este proyecto est√° bajo la licencia MIT.

