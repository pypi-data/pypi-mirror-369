# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: service.proto, types.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    AsyncIterable,
    AsyncIterator,
    Dict,
    Iterable,
    List,
    Optional,
    Union,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class OpenStatus(betterproto.Enum):
    """Information about how open the pool is to new delegators."""

    OPEN_STATUS_OPEN_FOR_ALL = 0
    OPEN_STATUS_CLOSED_FOR_NEW = 1
    OPEN_STATUS_CLOSED_FOR_ALL = 2


class ContractVersion(betterproto.Enum):
    """Version of smart contract."""

    V0 = 0
    V1 = 1


class CredentialType(betterproto.Enum):
    """The type of a credential."""

    CREDENTIAL_TYPE_INITIAL = 0
    """An initial credential created by the identity provider."""

    CREDENTIAL_TYPE_NORMAL = 1
    """A normal credential type created by the account."""


class UpdateType(betterproto.Enum):
    """The type of chain update."""

    UPDATE_PROTOCOL = 0
    UPDATE_ELECTION_DIFFICULTY = 1
    UPDATE_EURO_PER_ENERGY = 2
    UPDATE_MICRO_CCD_PER_EURO = 3
    UPDATE_FOUNDATION_ACCOUNT = 4
    UPDATE_MINT_DISTRIBUTION = 5
    UPDATE_TRANSACTION_FEE_DISTRIBUTION = 6
    UPDATE_GAS_REWARDS = 7
    UPDATE_POOL_PARAMETERS = 8
    ADD_ANONYMITY_REVOKER = 9
    ADD_IDENTITY_PROVIDER = 10
    UPDATE_ROOT_KEYS = 11
    UPDATE_LEVEL1_KEYS = 12
    UPDATE_LEVEL2_KEYS = 13
    UPDATE_COOLDOWN_PARAMETERS = 14
    UPDATE_TIME_PARAMETERS = 15
    UPDATE_TIMEOUT_PARAMETERS = 16
    UPDATE_MIN_BLOCK_TIME = 17
    UPDATE_BLOCK_ENERGY_LIMIT = 18
    UPDATE_FINALIZATION_COMMITTEE_PARAMETERS = 19
    UPDATE_VALIDATOR_SCORE_PARAMETERS = 20


class TransactionType(betterproto.Enum):
    """The type of transaction."""

    DEPLOY_MODULE = 0
    INIT_CONTRACT = 1
    UPDATE = 2
    TRANSFER = 3
    ADD_BAKER = 4
    REMOVE_BAKER = 5
    UPDATE_BAKER_STAKE = 6
    UPDATE_BAKER_RESTAKE_EARNINGS = 7
    UPDATE_BAKER_KEYS = 8
    UPDATE_CREDENTIAL_KEYS = 9
    ENCRYPTED_AMOUNT_TRANSFER = 10
    TRANSFER_TO_ENCRYPTED = 11
    TRANSFER_TO_PUBLIC = 12
    TRANSFER_WITH_SCHEDULE = 13
    UPDATE_CREDENTIALS = 14
    REGISTER_DATA = 15
    TRANSFER_WITH_MEMO = 16
    ENCRYPTED_AMOUNT_TRANSFER_WITH_MEMO = 17
    TRANSFER_WITH_SCHEDULE_AND_MEMO = 18
    CONFIGURE_BAKER = 19
    CONFIGURE_DELEGATION = 20


class ProtocolVersion(betterproto.Enum):
    """The different versions of the protocol."""

    PROTOCOL_VERSION_1 = 0
    PROTOCOL_VERSION_2 = 1
    PROTOCOL_VERSION_3 = 2
    PROTOCOL_VERSION_4 = 3
    PROTOCOL_VERSION_5 = 4
    PROTOCOL_VERSION_6 = 5
    PROTOCOL_VERSION_7 = 6
    PROTOCOL_VERSION_8 = 7


class CooldownCooldownStatus(betterproto.Enum):
    """
    The status of a cooldown. When stake is removed from a baker or delegator
    (from protocol version 7) it first enters the pre-pre-cooldown state. The
    next time the stake snaphot is taken (at the epoch transition before a
    payday) it enters the pre-cooldown state. At the subsequent payday, it
    enters the cooldown state. At the payday after the end of the cooldown
    period, the stake is finally released.
    """

    COOLDOWN = 0
    """
    The amount is in cooldown and will expire at the specified time, becoming
    available at the subsequent pay day.
    """

    PRE_COOLDOWN = 1
    """
    The amount will enter cooldown at the next pay day. The specified end time
    is projected to be the end of the cooldown period, but the actual end time
    will be determined at the payday, and may be different if the global
    cooldown period changes.
    """

    PRE_PRE_COOLDOWN = 2
    """
    The amount will enter pre-cooldown at the next snapshot epoch (i.e. the
    epoch transition before a pay day transition). As with pre-cooldown, the
    specified end time is projected, but the actual end time will be determined
    later.
    """


class PeersInfoPeerCatchupStatus(betterproto.Enum):
    UPTODATE = 0
    """
    The peer does not have any data unknown to us. If we receive a message from
    the peer that refers to unknown data (e.g., an unknown block) the peer is
    marked as pending.
    """

    PENDING = 1
    """
    The peer might have some data unknown to us. A peer can be in this state
    either because it sent a message that refers to data unknown to us, or
    before we have established a baseline with it. The latter happens during
    node startup, as well as upon protocol updates until the initial catchup
    handshake completes.
    """

    CATCHINGUP = 2
    """
    The node is currently catching up by requesting blocks from this peer.
    There will be at most one peer with this status at a time. Once the peer
    has responded to the request, its status will be changed to: - 'UPTODATE'
    if the peer has no more data that is not known to us - 'PENDING' if the
    node has more data that is unknown to us.
    """


class NodeInfoBakerConsensusInfoPassiveCommitteeInfo(betterproto.Enum):
    """
    The committee information of a node configured with baker keys but somehow
    the node is _not_ part of the current baking committee.
    """

    NOT_IN_COMMITTEE = 0
    """
    The node is started with baker keys however it is currently not in the
    baking committee. The node is __not__ baking.
    """

    ADDED_BUT_NOT_ACTIVE_IN_COMMITTEE = 1
    """
    The account is registered as a baker but not in the current `Epoch`. The
    node is __not__ baking.
    """

    ADDED_BUT_WRONG_KEYS = 2
    """
    The node has configured invalid baker keys i.e., the configured baker keys
    do not match the current keys on the baker account. The node is __not__
    baking.
    """


@dataclass(eq=False, repr=False)
class Empty(betterproto.Message):
    """A message that contains no information."""

    pass


@dataclass(eq=False, repr=False)
class BlockHash(betterproto.Message):
    """Hash of a block. This is always 32 bytes long."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class Sha256Hash(betterproto.Message):
    """A SHA256 hash. This is always 32 bytes long."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class TransactionHash(betterproto.Message):
    """Hash of a transaction. This is always 32 bytes long."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class StateHash(betterproto.Message):
    """Hash of the state after some block. This is always 32 bytes long."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class AbsoluteBlockHeight(betterproto.Message):
    """
    The absolute height of a block. This is the number of ancestors of a block
    since the genesis block. In particular, the chain genesis block has
    absolute height 0.
    """

    value: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class BlockHeight(betterproto.Message):
    """
    The height of a block relative to the last genesis. This differs from the
    absolute block height in that it counts height from the last protocol
    update.
    """

    value: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class BakerId(betterproto.Message):
    """The ID of a baker, which is the index of its account."""

    value: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class AccountIndex(betterproto.Message):
    """
    Index of the account in the account table. These are assigned sequentially
    in the order of creation of accounts. The first account has index 0.
    """

    value: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class ModuleRef(betterproto.Message):
    """A smart contract module reference. This is always 32 bytes long."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class VersionedModuleSource(betterproto.Message):
    """Source bytes of a versioned smart contract module."""

    v0: "VersionedModuleSourceModuleSourceV0" = betterproto.message_field(
        1, group="module"
    )
    v1: "VersionedModuleSourceModuleSourceV1" = betterproto.message_field(
        2, group="module"
    )


@dataclass(eq=False, repr=False)
class VersionedModuleSourceModuleSourceV0(betterproto.Message):
    """Source bytes of a smart contract v0 module."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class VersionedModuleSourceModuleSourceV1(betterproto.Message):
    """Source bytes of a smart contract v1 module."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class Timestamp(betterproto.Message):
    """Unix timestamp in milliseconds."""

    value: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class Release(betterproto.Message):
    """An individual release of a locked balance."""

    timestamp: "Timestamp" = betterproto.message_field(1)
    """Effective time of the release in milliseconds since unix epoch."""

    amount: "Amount" = betterproto.message_field(2)
    """Amount to be released."""

    transactions: List["TransactionHash"] = betterproto.message_field(3)
    """
    List of transaction hashes that contribute a balance to this release.
    """


@dataclass(eq=False, repr=False)
class NewRelease(betterproto.Message):
    """
    A new individual release. Part of a single transfer with schedule
    transaction.
    """

    timestamp: "Timestamp" = betterproto.message_field(1)
    """Effective time of the release in milliseconds since unix epoch."""

    amount: "Amount" = betterproto.message_field(2)
    """Amount to be released."""


@dataclass(eq=False, repr=False)
class ReleaseSchedule(betterproto.Message):
    """
    State of the account's release schedule. This is the balance of the account
    that is owned by the account, but cannot be used until the release point.
    """

    total: "Amount" = betterproto.message_field(1)
    """Total amount locked in the release schedule."""

    schedules: List["Release"] = betterproto.message_field(2)
    """A list of releases, ordered by increasing timestamp."""


@dataclass(eq=False, repr=False)
class EncryptedAmount(betterproto.Message):
    """
    An encrypted amount, in two chunks in "little endian limbs". That is, the
    first chunk represents the low 32 bits of an amount, and the second chunk
    represents the high 32 bits. The chunks are serialized in order and
    represented as a byte array. Always 192 bytes.
    """

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class EncryptedBalance(betterproto.Message):
    self_amount: "EncryptedAmount" = betterproto.message_field(1)
    """
    Encrypted amount that is a result of this account's actions. In particular
    this list includes the aggregate of - remaining amounts that result when
    transferring to public balance - remaining amounts when transferring to
    another account - encrypted amounts that are transferred from public
    balance When a transfer is made all of these must always be used.
    """

    start_index: int = betterproto.uint64_field(2)
    """
    Starting index for incoming encrypted amounts. If an aggregated amount is
    present then this index is associated with such an amount and the list of
    incoming encrypted amounts starts at the index `start_index + 1`.
    """

    aggregated_amount: Optional["EncryptedAmount"] = betterproto.message_field(
        3, optional=True, group="_aggregated_amount"
    )
    """
    If present, the amount that has resulted from aggregating other amounts If
    this field is present so is `num_aggregated`.
    """

    num_aggregated: Optional[int] = betterproto.uint32_field(
        4, optional=True, group="_num_aggregated"
    )
    """
    The number of aggregated amounts (must be at least 2 if present). This
    field is present if and only if `aggregated_amount` is present.
    """

    incoming_amounts: List["EncryptedAmount"] = betterproto.message_field(5)
    """
    Amounts starting at `start_index` (or at `start_index + 1` if there is an
    aggregated amount present). They are assumed to be numbered sequentially.
    The length of this list is bounded by the maximum number of incoming
    amounts on the accounts, which is currently 32. After that aggregation
    kicks in.
    """


@dataclass(eq=False, repr=False)
class DelegationTarget(betterproto.Message):
    """Entity to which the account delegates a portion of its stake."""

    passive: "Empty" = betterproto.message_field(1, group="target")
    """Delegate passively, i.e., to no specific baker."""

    baker: "BakerId" = betterproto.message_field(2, group="target")
    """Delegate to a specific baker."""


@dataclass(eq=False, repr=False)
class BakerElectionVerifyKey(betterproto.Message):
    """
    Baker's public key used to check whether they won the lottery or not.
    """

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class BakerSignatureVerifyKey(betterproto.Message):
    """
    Baker's public key used to check that they are indeed the ones who produced
    the block.
    """

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class BakerAggregationVerifyKey(betterproto.Message):
    """
    Baker's public key used to check signatures on finalization records. This
    is only used if the baker has sufficient stake to participate in
    finalization.
    """

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class BakerInfo(betterproto.Message):
    """Information about a baker."""

    baker_id: "BakerId" = betterproto.message_field(1)
    """
    Identity of the baker. This is actually the account index of the account
    controlling the baker.
    """

    election_key: "BakerElectionVerifyKey" = betterproto.message_field(2)
    """
    Baker's public key used to check whether they won the lottery or not.
    """

    signature_key: "BakerSignatureVerifyKey" = betterproto.message_field(3)
    """
    Baker's public key used to check that they are indeed the ones who produced
    the block.
    """

    aggregation_key: "BakerAggregationVerifyKey" = betterproto.message_field(4)
    """
    Baker's public key used to check signatures on finalization records. This
    is only used if the baker has sufficient stake to participate in
    finalization.
    """


@dataclass(eq=False, repr=False)
class StakePendingChange(betterproto.Message):
    """Pending change to the stake either of a baker or delegator."""

    reduce: "StakePendingChangeReduce" = betterproto.message_field(1, group="change")
    remove: "Timestamp" = betterproto.message_field(2, group="change")
    """
    Remove the stake. The value is a Unix timestamp of the effective time in
    milliseconds.
    """


@dataclass(eq=False, repr=False)
class StakePendingChangeReduce(betterproto.Message):
    new_stake: "Amount" = betterproto.message_field(1)
    effective_time: "Timestamp" = betterproto.message_field(2)
    """Unix timestamp in milliseconds when the change takes effect."""


@dataclass(eq=False, repr=False)
class AmountFraction(betterproto.Message):
    """A fraction of an amount with a precision of `1/100_000`."""

    parts_per_hundred_thousand: int = betterproto.uint32_field(1)
    """Must not exceed 100000."""


@dataclass(eq=False, repr=False)
class CommissionRates(betterproto.Message):
    """Distribution of the rewards for the particular pool."""

    finalization: "AmountFraction" = betterproto.message_field(1)
    """Fraction of finalization rewards charged by the pool owner."""

    baking: "AmountFraction" = betterproto.message_field(2)
    """Fraction of baking rewards charged by the pool owner."""

    transaction: "AmountFraction" = betterproto.message_field(3)
    """Fraction of transaction rewards charged by the pool owner."""


@dataclass(eq=False, repr=False)
class BakerPoolInfo(betterproto.Message):
    """
    Additional information about a baking pool. This information is added with
    the introduction of delegation.
    """

    open_status: "OpenStatus" = betterproto.enum_field(1)
    """Whether the pool allows delegators."""

    url: str = betterproto.string_field(2)
    """The URL that links to the metadata about the pool."""

    commission_rates: "CommissionRates" = betterproto.message_field(3)
    """The commission rates charged by the pool owner."""


@dataclass(eq=False, repr=False)
class AccountStakingInfo(betterproto.Message):
    """
    Information about the account stake, if the account is either a baker or a
    delegator.
    """

    baker: "AccountStakingInfoBaker" = betterproto.message_field(
        1, group="staking_info"
    )
    """The account is a baker."""

    delegator: "AccountStakingInfoDelegator" = betterproto.message_field(
        2, group="staking_info"
    )
    """The account is a delegator."""


@dataclass(eq=False, repr=False)
class AccountStakingInfoBaker(betterproto.Message):
    staked_amount: "Amount" = betterproto.message_field(1)
    """Amount staked at present."""

    restake_earnings: bool = betterproto.bool_field(2)
    """
    A flag indicating whether rewards paid to the baker are automatically
    restaked or not.
    """

    baker_info: "BakerInfo" = betterproto.message_field(3)
    """Information about the baker that is staking."""

    pending_change: Optional["StakePendingChange"] = betterproto.message_field(
        4, optional=True, group="_pending_change"
    )
    """If present, any pending change to the delegated stake."""

    pool_info: Optional["BakerPoolInfo"] = betterproto.message_field(
        5, optional=True, group="_pool_info"
    )
    """
    Present if the account is currently a baker, i.e., it is in the baking
    committee of the current epoch.
    """

    is_suspended: bool = betterproto.bool_field(6)
    """
    A flag indicating whether the account is currently suspended or not. The
    flag has a meaning from protocol version 8 onwards. In protocol version 8
    it signals whether an account has been suspended and is not participating
    in the consensus algorithm. For protocol version < 8 the flag will always
    be set to false.
    """


@dataclass(eq=False, repr=False)
class AccountStakingInfoDelegator(betterproto.Message):
    staked_amount: "Amount" = betterproto.message_field(1)
    """The amount that the account delegates."""

    restake_earnings: bool = betterproto.bool_field(2)
    """Whether the earnings are automatically added to the staked amount."""

    target: "DelegationTarget" = betterproto.message_field(3)
    """The entity to which the account delegates."""

    pending_change: Optional["StakePendingChange"] = betterproto.message_field(
        4, optional=True, group="_pending_change"
    )
    """If present, any pending change to the delegated stake."""


@dataclass(eq=False, repr=False)
class SequenceNumber(betterproto.Message):
    """
    A sequence number that determines the ordering of transactions from the
    account. The minimum sequence number is 1.
    """

    value: int = betterproto.uint64_field(1)
    """The sequence number."""


@dataclass(eq=False, repr=False)
class UpdateSequenceNumber(betterproto.Message):
    """
    A sequence number that determines the ordering of update transactions.
    Equivalent to `SequenceNumber` for account transactions. Update sequence
    numbers are per update type and the minimum value is 1.
    """

    value: int = betterproto.uint64_field(1)
    """The sequence number."""


@dataclass(eq=False, repr=False)
class Amount(betterproto.Message):
    """An amount of microCCD."""

    value: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class CredentialIndex(betterproto.Message):
    """Index of a credential on an account."""

    value: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class SignatureThreshold(betterproto.Message):
    """The number of signatures required to sign."""

    value: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class AccountThreshold(betterproto.Message):
    """The number of credentials required to sign an account transaction."""

    value: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class EncryptionKey(betterproto.Message):
    """An account encryption key. Always 96 bytes."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class AccountAddress(betterproto.Message):
    """An address of an account. Always 32 bytes."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class Address(betterproto.Message):
    """An address of either a contract or an account."""

    account: "AccountAddress" = betterproto.message_field(1, group="type")
    contract: "ContractAddress" = betterproto.message_field(2, group="type")


@dataclass(eq=False, repr=False)
class AccountVerifyKey(betterproto.Message):
    """A public key used to verify transaction signatures from an account."""

    ed25519_key: bytes = betterproto.bytes_field(1, group="key")


@dataclass(eq=False, repr=False)
class CredentialPublicKeys(betterproto.Message):
    """Public keys of a single credential."""

    keys: Dict[int, "AccountVerifyKey"] = betterproto.map_field(
        1, betterproto.TYPE_UINT32, betterproto.TYPE_MESSAGE
    )
    threshold: "SignatureThreshold" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class CredentialRegistrationId(betterproto.Message):
    """
    A registration ID of a credential, derived from the secret PRF key and a
    nonce. This is always 48 bytes long.
    """

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class IdentityProviderIdentity(betterproto.Message):
    """
    An index of the identity provider that identifies them uniquely in the
    context of a specific chain.
    """

    value: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class YearMonth(betterproto.Message):
    """Representation of the pair of a year and month."""

    year: int = betterproto.uint32_field(1)
    month: int = betterproto.uint32_field(2)


@dataclass(eq=False, repr=False)
class Policy(betterproto.Message):
    """Policy on a credential."""

    created_at: "YearMonth" = betterproto.message_field(1)
    """
    The year and month when the identity object from which the credential is
    derived was created.
    """

    valid_to: "YearMonth" = betterproto.message_field(2)
    """
    The last year and month when the credential is still valid. After this
    expires an account can no longer be created from the credential.
    """

    attributes: Dict[int, bytes] = betterproto.map_field(
        3, betterproto.TYPE_UINT32, betterproto.TYPE_BYTES
    )
    """
    Mapping from attribute tags to attribute values. Attribute tags are always
    representable in a single `u8`, attribute values are never more than 31
    bytes in length.
    """


@dataclass(eq=False, repr=False)
class InitialCredentialValues(betterproto.Message):
    """Values contained in an initial credential."""

    keys: "CredentialPublicKeys" = betterproto.message_field(1)
    """Public keys of the credential."""

    cred_id: "CredentialRegistrationId" = betterproto.message_field(2)
    """Its registration ID."""

    ip_id: "IdentityProviderIdentity" = betterproto.message_field(3)
    """
    The identity provider who signed the identity object from which this
    credential is derived.
    """

    policy: "Policy" = betterproto.message_field(4)
    """Policy of this credential."""


@dataclass(eq=False, repr=False)
class ChainArData(betterproto.Message):
    """
    Data relating to a single anonymity revoker sent by the account holder to
    the chain.
    """

    enc_id_cred_pub_share: bytes = betterproto.bytes_field(1)
    """Share of the encryption of IdCredPub."""


@dataclass(eq=False, repr=False)
class ArThreshold(betterproto.Message):
    """
    The number of anonymity revokers needed to revoke anonymity of a credential
    holder.
    """

    value: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class Commitment(betterproto.Message):
    """
    A single commitment in the G1 group of the BLS curve. This is always 48
    bytes in length.
    """

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class CredentialCommitments(betterproto.Message):
    """Commitments that are part of a normal credential."""

    prf: "Commitment" = betterproto.message_field(1)
    """Commitment to the PRF key."""

    cred_counter: "Commitment" = betterproto.message_field(2)
    """
    Commitment to the counter used to generate the credential registration id.
    """

    max_accounts: "Commitment" = betterproto.message_field(3)
    """
    Commitment to the `max_accounts` value, which determines the maximum number
    of credentials that may be created from the identity object.
    """

    attributes: Dict[int, "Commitment"] = betterproto.map_field(
        4, betterproto.TYPE_UINT32, betterproto.TYPE_MESSAGE
    )
    """
    Commitments to the attributes which have not been revealed in the policy.
    """

    id_cred_sec_sharing_coeff: List["Commitment"] = betterproto.message_field(5)
    """
    List of commitments to the coefficients of the sharing polynomial. This
    polynomial is used in a shared encryption of `id_cred_pub` among the
    anonymity revokers.
    """


@dataclass(eq=False, repr=False)
class NormalCredentialValues(betterproto.Message):
    """Values contained in a normal (non-initial) credential."""

    keys: "CredentialPublicKeys" = betterproto.message_field(1)
    """Public keys of the credential."""

    cred_id: "CredentialRegistrationId" = betterproto.message_field(2)
    """Its registration ID."""

    ip_id: "IdentityProviderIdentity" = betterproto.message_field(3)
    """
    The identity provider who signed the identity object from which this
    credential is derived.
    """

    policy: "Policy" = betterproto.message_field(4)
    """Policy of this credential."""

    ar_threshold: "ArThreshold" = betterproto.message_field(5)
    """
    The number of anonymity revokers that must work together to revoke the
    anonymity of the credential holder.
    """

    ar_data: Dict[int, "ChainArData"] = betterproto.map_field(
        6, betterproto.TYPE_UINT32, betterproto.TYPE_MESSAGE
    )
    """
    Mapping from anonymity revoker identities to revocation data for the given
    anonymity revoker.
    """

    commitments: "CredentialCommitments" = betterproto.message_field(7)
    """Commitments to attributes which have not been revealed."""


@dataclass(eq=False, repr=False)
class AccountCredential(betterproto.Message):
    """Credential that is part of an account."""

    initial: "InitialCredentialValues" = betterproto.message_field(
        1, group="credential_values"
    )
    normal: "NormalCredentialValues" = betterproto.message_field(
        2, group="credential_values"
    )


@dataclass(eq=False, repr=False)
class Cooldown(betterproto.Message):
    end_time: "Timestamp" = betterproto.message_field(1)
    """
    The time in milliseconds since the Unix epoch when the cooldown period
    ends.
    """

    amount: "Amount" = betterproto.message_field(2)
    """
    The amount that is in cooldown and set to be released at the end of the
    cooldown period.
    """

    status: "CooldownCooldownStatus" = betterproto.enum_field(3)
    """The status of the cooldown."""


@dataclass(eq=False, repr=False)
class AccountInfo(betterproto.Message):
    """Information about the account at a particular point in time."""

    sequence_number: "SequenceNumber" = betterproto.message_field(1)
    """
    Next sequence number to be used for transactions signed from this account.
    """

    amount: "Amount" = betterproto.message_field(2)
    """Current (unencrypted) balance of the account."""

    schedule: "ReleaseSchedule" = betterproto.message_field(3)
    """
    Release schedule for any locked up amount. This could be an empty release
    schedule.
    """

    creds: Dict[int, "AccountCredential"] = betterproto.map_field(
        4, betterproto.TYPE_UINT32, betterproto.TYPE_MESSAGE
    )
    """
    Map of all currently active credentials on the account. This includes
    public keys that can sign for the given credentials, as well as any
    revealed attributes. This map always contains a credential with index 0.
    """

    threshold: "AccountThreshold" = betterproto.message_field(5)
    """
    Lower bound on how many credentials must sign any given transaction from
    this account.
    """

    encrypted_balance: "EncryptedBalance" = betterproto.message_field(6)
    """The encrypted balance of the account."""

    encryption_key: "EncryptionKey" = betterproto.message_field(7)
    """The public key for sending encrypted balances to the account."""

    index: "AccountIndex" = betterproto.message_field(8)
    """
    Internal index of the account. Accounts on the chain get sequential
    indices. These should generally not be used outside of the chain, the
    account address is meant to be used to refer to accounts, however the
    account index serves the role of the baker id, if the account is a baker.
    Hence it is exposed here as well.
    """

    stake: Optional["AccountStakingInfo"] = betterproto.message_field(
        9, optional=True, group="_stake"
    )
    """
    Present if the account is a baker or delegator. In that case it is the
    information about the baker or delegator.
    """

    address: "AccountAddress" = betterproto.message_field(10)
    """
    Canonical address of the account. This is derived from the first credential
    that created the account.
    """

    cooldowns: List["Cooldown"] = betterproto.message_field(11)
    """
    The stake on the account that is in cooldown. There can be multiple amounts
    in cooldown that expire at different times. This was introduced in protocol
    version 7, and so is not present in earlier protocol versions.
    """

    available_balance: "Amount" = betterproto.message_field(12)
    """
    The available (unencrypted) balance of the account (i.e. that can be
    transferred or used to pay for transactions). This is the balance minus the
    locked amount. The locked amount is the maximum of the amount in the
    release schedule and the total amount that is actively staked or in
    cooldown (inactive stake). This was introduced in node version 7.0.
    """


@dataclass(eq=False, repr=False)
class BlockHashInput(betterproto.Message):
    """Input to queries which take a block as a parameter."""

    best: "Empty" = betterproto.message_field(1, group="block_hash_input")
    """Query for the best block."""

    last_final: "Empty" = betterproto.message_field(2, group="block_hash_input")
    """Query for the last finalized block."""

    given: "BlockHash" = betterproto.message_field(3, group="block_hash_input")
    """
    Query for the block specified by the hash. This hash should always be 32
    bytes.
    """

    absolute_height: "AbsoluteBlockHeight" = betterproto.message_field(
        4, group="block_hash_input"
    )
    """
    Query for a block at absolute height, if a unique block can be identified
    at that height.
    """

    relative_height: "BlockHashInputRelativeHeight" = betterproto.message_field(
        5, group="block_hash_input"
    )
    """Query for a block at height relative to a genesis index."""


@dataclass(eq=False, repr=False)
class BlockHashInputRelativeHeight(betterproto.Message):
    """Request using a relative block height."""

    genesis_index: "GenesisIndex" = betterproto.message_field(1)
    """Genesis index to start from."""

    height: "BlockHeight" = betterproto.message_field(2)
    """Height starting from the genesis block at the genesis index."""

    restrict: bool = betterproto.bool_field(3)
    """
    Whether to return results only from the specified genesis index (`true`),
    or allow results from more recent genesis indices as well (`false`).
    """


@dataclass(eq=False, repr=False)
class EpochRequest(betterproto.Message):
    """Input to queries which take an epoch as a parameter."""

    relative_epoch: "EpochRequestRelativeEpoch" = betterproto.message_field(
        1, group="epoch_request_input"
    )
    """Query by genesis index and epoch number."""

    block_hash: "BlockHashInput" = betterproto.message_field(
        2, group="epoch_request_input"
    )
    """Query for the epoch of a specified block."""


@dataclass(eq=False, repr=False)
class EpochRequestRelativeEpoch(betterproto.Message):
    """Request an epoch by number at a given genesis index."""

    genesis_index: "GenesisIndex" = betterproto.message_field(1)
    """
    The genesis index to query at. The query is restricted to this genesis
    index, and will not return results for other indices even if the epoch
    number is out of bounds.
    """

    epoch: "Epoch" = betterproto.message_field(2)
    """The epoch number to query at."""


@dataclass(eq=False, repr=False)
class AccountIdentifierInput(betterproto.Message):
    """Input to queries which take an account as a parameter."""

    address: "AccountAddress" = betterproto.message_field(
        1, group="account_identifier_input"
    )
    """Identify the account by the address of the account."""

    cred_id: "CredentialRegistrationId" = betterproto.message_field(
        2, group="account_identifier_input"
    )
    """
    Identify the account by the credential that belongs or has belonged to it.
    """

    account_index: "AccountIndex" = betterproto.message_field(
        3, group="account_identifier_input"
    )
    """Identify the account via its index."""


@dataclass(eq=False, repr=False)
class AccountInfoRequest(betterproto.Message):
    """Request for account information."""

    block_hash: "BlockHashInput" = betterproto.message_field(1)
    """Block in which to query the account information."""

    account_identifier: "AccountIdentifierInput" = betterproto.message_field(2)
    """Specification of the account."""


@dataclass(eq=False, repr=False)
class FinalizedBlockInfo(betterproto.Message):
    """
    Information about a finalized block that is part of the streaming response.
    """

    hash: "BlockHash" = betterproto.message_field(1)
    """Hash of the block."""

    height: "AbsoluteBlockHeight" = betterproto.message_field(2)
    """Absolute height of the block, height 0 is the genesis block."""


@dataclass(eq=False, repr=False)
class AncestorsRequest(betterproto.Message):
    """Request the ancestors for the given block."""

    block_hash: "BlockHashInput" = betterproto.message_field(1)
    """The block to get ancestors of."""

    amount: int = betterproto.uint64_field(2)
    """The maximum number of ancestors returned."""


@dataclass(eq=False, repr=False)
class ModuleSourceRequest(betterproto.Message):
    """Request for getting the source of a smart contract module."""

    block_hash: "BlockHashInput" = betterproto.message_field(1)
    """The block to be used for the query."""

    module_ref: "ModuleRef" = betterproto.message_field(2)
    """The reference of the module."""


@dataclass(eq=False, repr=False)
class ContractAddress(betterproto.Message):
    """Address of a smart contract instance."""

    index: int = betterproto.uint64_field(1)
    """The index of the smart contract."""

    subindex: int = betterproto.uint64_field(2)
    """
    The subindex of the smart contract instance. Currently not used, so it is
    always 0.
    """


@dataclass(eq=False, repr=False)
class InstanceInfoRequest(betterproto.Message):
    """Request for getting information about a smart contract instance."""

    block_hash: "BlockHashInput" = betterproto.message_field(1)
    """The block to be used for the query."""

    address: "ContractAddress" = betterproto.message_field(2)
    """The address of the smart contract instance."""


@dataclass(eq=False, repr=False)
class InstanceInfo(betterproto.Message):
    """Information about a smart contract instance."""

    v0: "InstanceInfoV0" = betterproto.message_field(1, group="version")
    v1: "InstanceInfoV1" = betterproto.message_field(2, group="version")


@dataclass(eq=False, repr=False)
class InstanceInfoV0(betterproto.Message):
    """Version 0 smart contract instance information."""

    model: "ContractStateV0" = betterproto.message_field(1)
    """The state of the instance."""

    owner: "AccountAddress" = betterproto.message_field(2)
    """The account address which deployed the instance."""

    amount: "Amount" = betterproto.message_field(3)
    """The amount of CCD tokens in the balance of the instance."""

    methods: List["ReceiveName"] = betterproto.message_field(4)
    """A list of endpoints exposed by the instance."""

    name: "InitName" = betterproto.message_field(5)
    """The name of the smart contract of the instance."""

    source_module: "ModuleRef" = betterproto.message_field(6)
    """The module reference for the smart contract module of the instance."""


@dataclass(eq=False, repr=False)
class InstanceInfoV1(betterproto.Message):
    """Version 1 smart contract instance information."""

    owner: "AccountAddress" = betterproto.message_field(2)
    """The account address which deployed the instance."""

    amount: "Amount" = betterproto.message_field(3)
    """The amount of CCD tokens in the balance of the instance."""

    methods: List["ReceiveName"] = betterproto.message_field(4)
    """A list of endpoints exposed by the instance."""

    name: "InitName" = betterproto.message_field(5)
    """The name of the smart contract of the instance."""

    source_module: "ModuleRef" = betterproto.message_field(6)
    """The module reference for the smart contract module of the instance."""


@dataclass(eq=False, repr=False)
class InstanceStateKvPair(betterproto.Message):
    """A smart contract instance key-value pair."""

    key: bytes = betterproto.bytes_field(1)
    value: bytes = betterproto.bytes_field(2)


@dataclass(eq=False, repr=False)
class InstanceStateLookupRequest(betterproto.Message):
    """Request for a specific key of a smart contract instance state."""

    block_hash: "BlockHashInput" = betterproto.message_field(1)
    """The block to be used for the query."""

    address: "ContractAddress" = betterproto.message_field(2)
    """The address of the smart contract instance."""

    key: bytes = betterproto.bytes_field(3)
    """
    Key to look up. If the instance is a V0 instance then this will not be
    used.
    """


@dataclass(eq=False, repr=False)
class InstanceStateValueAtKey(betterproto.Message):
    """
    Value at the requested key of a smart contract instance state. For V0
    contracts this will always be the entire state of the contract.
    """

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class ReceiveName(betterproto.Message):
    """
    The receive name of a smart contract function. Expected format:
    `<contract_name>.<func_name>`. It must only consist of atmost 100 ASCII
    alphanumeric or punctuation characters, and must contain a '.'.
    """

    value: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class InitName(betterproto.Message):
    """
    The init name of a smart contract function. Expected format:
    `init_<contract_name>`. It must only consist of atmost 100 ASCII
    alphanumeric or punctuation characters, must not contain a '.' and must
    start with 'init_'.
    """

    value: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class Parameter(betterproto.Message):
    """Parameter to a smart contract initialization or invocation."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class ContractStateV0(betterproto.Message):
    """A smart contract v0 state."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class BlockItemStatus(betterproto.Message):
    """Status of a block item known to the node."""

    received: "Empty" = betterproto.message_field(1, group="status")
    """Block item is received, but not yet in any blocks."""

    committed: "BlockItemStatusCommitted" = betterproto.message_field(2, group="status")
    """
    Block item is committed to one or more blocks. The outcomes are listed for
    each block. Note that in the vast majority of cases the outcome of a
    transaction should not be dependent on the block it is in, but this can in
    principle happen.
    """

    finalized: "BlockItemStatusFinalized" = betterproto.message_field(3, group="status")
    """Block item is finalized in the given block, with the given summary."""


@dataclass(eq=False, repr=False)
class BlockItemStatusCommitted(betterproto.Message):
    outcomes: List["BlockItemSummaryInBlock"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class BlockItemStatusFinalized(betterproto.Message):
    outcome: "BlockItemSummaryInBlock" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class BlockItemSummaryInBlock(betterproto.Message):
    """
    A block item summary together with a block hash. Used in BlockItemStatus.
    """

    block_hash: "BlockHash" = betterproto.message_field(1)
    """The block hash."""

    outcome: "BlockItemSummary" = betterproto.message_field(2)
    """The block item summary."""


@dataclass(eq=False, repr=False)
class Energy(betterproto.Message):
    """
    Energy is used to count exact execution cost. This cost is then converted
    to CCD amounts.
    """

    value: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class Slot(betterproto.Message):
    """A number representing a slot for baking a block."""

    value: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class NextAccountSequenceNumber(betterproto.Message):
    """The response for getNextAccountSequenceNumber."""

    sequence_number: "SequenceNumber" = betterproto.message_field(1)
    """The best guess for the available account sequence number."""

    all_final: bool = betterproto.bool_field(2)
    """
    Whether the guess relies on any non-finalized transactions. If true all of
    the relevant transactions are finalized.
    """


@dataclass(eq=False, repr=False)
class Duration(betterproto.Message):
    """A duration of milliseconds."""

    value: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class RejectReason(betterproto.Message):
    """
    A reason for why a transaction was rejected. Rejected means included in a
    block, but the desired action was not achieved. The only effect of a
    rejected transaction is payment.
    """

    module_not_wf: "Empty" = betterproto.message_field(1, group="reason")
    """Raised while validating a Wasm module that is not well formed."""

    module_hash_already_exists: "ModuleRef" = betterproto.message_field(
        2, group="reason"
    )
    """The smart contract module hash already exists."""

    invalid_account_reference: "AccountAddress" = betterproto.message_field(
        3, group="reason"
    )
    """Account does not exist."""

    invalid_init_method: "RejectReasonInvalidInitMethod" = betterproto.message_field(
        4, group="reason"
    )
    """Reference to a non-existing contract init method."""

    invalid_receive_method: "RejectReasonInvalidReceiveMethod" = (
        betterproto.message_field(5, group="reason")
    )
    """Reference to a non-existing contract receive method."""

    invalid_module_reference: "ModuleRef" = betterproto.message_field(6, group="reason")
    """Reference to a non-existing smart contract module."""

    invalid_contract_address: "ContractAddress" = betterproto.message_field(
        7, group="reason"
    )
    """Contract instance does not exist."""

    runtime_failure: "Empty" = betterproto.message_field(8, group="reason")
    """
    Runtime exception occurred when running either the init or receive method.
    """

    amount_too_large: "RejectReasonAmountTooLarge" = betterproto.message_field(
        9, group="reason"
    )
    """
    When one wishes to transfer an amount from A to B but there are not enough
    funds on account/contract A to make this possible. The data are the from
    address and the amount to transfer.
    """

    serialization_failure: "Empty" = betterproto.message_field(10, group="reason")
    """Serialization of the body failed."""

    out_of_energy: "Empty" = betterproto.message_field(11, group="reason")
    """We ran of out energy to process this transaction."""

    rejected_init: "RejectReasonRejectedInit" = betterproto.message_field(
        12, group="reason"
    )
    """Rejected due to contract logic in init function of a contract."""

    rejected_receive: "RejectReasonRejectedReceive" = betterproto.message_field(
        13, group="reason"
    )
    """Rejected due to contract logic in receive function of a contract."""

    invalid_proof: "Empty" = betterproto.message_field(14, group="reason")
    """Proof that the baker owns relevant private keys is not valid."""

    already_a_baker: "BakerId" = betterproto.message_field(15, group="reason")
    """Tried to add baker for an account that already has a baker."""

    not_a_baker: "AccountAddress" = betterproto.message_field(16, group="reason")
    """Tried to remove a baker for an account that has no baker."""

    insufficient_balance_for_baker_stake: "Empty" = betterproto.message_field(
        17, group="reason"
    )
    """
    The amount on the account was insufficient to cover the proposed stake.
    """

    stake_under_minimum_threshold_for_baking: "Empty" = betterproto.message_field(
        18, group="reason"
    )
    """
    The amount provided is under the threshold required for becoming a baker.
    """

    baker_in_cooldown: "Empty" = betterproto.message_field(19, group="reason")
    """
    The change could not be made because the baker is in cooldown for another
    change.
    """

    duplicate_aggregation_key: "BakerAggregationVerifyKey" = betterproto.message_field(
        20, group="reason"
    )
    """A baker with the given aggregation key already exists."""

    non_existent_credential_id: "Empty" = betterproto.message_field(21, group="reason")
    """Encountered credential ID that does not exist."""

    key_index_already_in_use: "Empty" = betterproto.message_field(22, group="reason")
    """Attempted to add an account key to a key index already in use."""

    invalid_account_threshold: "Empty" = betterproto.message_field(23, group="reason")
    """
    When the account threshold is updated, it must not exceed the amount of
    existing keys.
    """

    invalid_credential_key_sign_threshold: "Empty" = betterproto.message_field(
        24, group="reason"
    )
    """
    When the credential key threshold is updated, it must not exceed the amount
    of existing keys.
    """

    invalid_encrypted_amount_transfer_proof: "Empty" = betterproto.message_field(
        25, group="reason"
    )
    """Proof for an encrypted amount transfer did not validate."""

    invalid_transfer_to_public_proof: "Empty" = betterproto.message_field(
        26, group="reason"
    )
    """Proof for a secret to public transfer did not validate."""

    encrypted_amount_self_transfer: "AccountAddress" = betterproto.message_field(
        27, group="reason"
    )
    """
    Account tried to transfer an encrypted amount to itself, that's not
    allowed.
    """

    invalid_index_on_encrypted_transfer: "Empty" = betterproto.message_field(
        28, group="reason"
    )
    """
    The provided index is below the start index or above `startIndex + length
    incomingAmounts`.
    """

    zero_scheduled_amount: "Empty" = betterproto.message_field(29, group="reason")
    """The transfer with schedule is going to send 0 tokens."""

    non_increasing_schedule: "Empty" = betterproto.message_field(30, group="reason")
    """The transfer with schedule has a non strictly increasing schedule."""

    first_scheduled_release_expired: "Empty" = betterproto.message_field(
        31, group="reason"
    )
    """
    The first scheduled release in a transfer with schedule has already
    expired.
    """

    scheduled_self_transfer: "AccountAddress" = betterproto.message_field(
        32, group="reason"
    )
    """
    Account tried to transfer with schedule to itself, that's not allowed.
    """

    invalid_credentials: "Empty" = betterproto.message_field(33, group="reason")
    """
    At least one of the credentials was either malformed or its proof was
    incorrect.
    """

    duplicate_cred_ids: "RejectReasonDuplicateCredIds" = betterproto.message_field(
        34, group="reason"
    )
    """
    Some of the credential IDs already exist or are duplicated in the
    transaction.
    """

    non_existent_cred_ids: "RejectReasonNonExistentCredIds" = betterproto.message_field(
        35, group="reason"
    )
    """A credential id that was to be removed is not part of the account."""

    remove_first_credential: "Empty" = betterproto.message_field(36, group="reason")
    """Attemp to remove the first credential."""

    credential_holder_did_not_sign: "Empty" = betterproto.message_field(
        37, group="reason"
    )
    """
    The credential holder of the keys to be updated did not sign the
    transaction.
    """

    not_allowed_multiple_credentials: "Empty" = betterproto.message_field(
        38, group="reason"
    )
    """
    Account is not allowed to have multiple credentials because it contains a
    non-zero encrypted transfer.
    """

    not_allowed_to_receive_encrypted: "Empty" = betterproto.message_field(
        39, group="reason"
    )
    """
    The account is not allowed to receive encrypted transfers because it has
    multiple credentials.
    """

    not_allowed_to_handle_encrypted: "Empty" = betterproto.message_field(
        40, group="reason"
    )
    """
    The account is not allowed to send encrypted transfers (or transfer from/to
    public to/from encrypted).
    """

    missing_baker_add_parameters: "Empty" = betterproto.message_field(
        41, group="reason"
    )
    """
    A configure baker transaction is missing one or more arguments in order to
    add a baker.
    """

    finalization_reward_commission_not_in_range: "Empty" = betterproto.message_field(
        42, group="reason"
    )
    """
    Finalization reward commission is not in the valid range for a baker.
    """

    baking_reward_commission_not_in_range: "Empty" = betterproto.message_field(
        43, group="reason"
    )
    """Baking reward commission is not in the valid range for a baker."""

    transaction_fee_commission_not_in_range: "Empty" = betterproto.message_field(
        44, group="reason"
    )
    """Transaction fee commission is not in the valid range for a baker."""

    already_a_delegator: "Empty" = betterproto.message_field(45, group="reason")
    """Tried to add baker for an account that already has a delegator."""

    insufficient_balance_for_delegation_stake: "Empty" = betterproto.message_field(
        46, group="reason"
    )
    """
    The amount on the account was insufficient to cover the proposed stake.
    """

    missing_delegation_add_parameters: "Empty" = betterproto.message_field(
        47, group="reason"
    )
    """
    A configure delegation transaction is missing one or more arguments in
    order to add a delegator.
    """

    insufficient_delegation_stake: "Empty" = betterproto.message_field(
        48, group="reason"
    )
    """Delegation stake when adding a delegator was 0."""

    delegator_in_cooldown: "Empty" = betterproto.message_field(49, group="reason")
    """Account is not a delegation account."""

    not_a_delegator: "AccountAddress" = betterproto.message_field(50, group="reason")
    """Account is not a delegation account."""

    delegation_target_not_a_baker: "BakerId" = betterproto.message_field(
        51, group="reason"
    )
    """Delegation target is not a baker"""

    stake_over_maximum_threshold_for_pool: "Empty" = betterproto.message_field(
        52, group="reason"
    )
    """
    The amount would result in pool capital higher than the maximum threshold.
    """

    pool_would_become_over_delegated: "Empty" = betterproto.message_field(
        53, group="reason"
    )
    """
    The amount would result in pool with a too high fraction of delegated
    capital.
    """

    pool_closed: "Empty" = betterproto.message_field(54, group="reason")
    """The pool is not open to delegators."""


@dataclass(eq=False, repr=False)
class RejectReasonInvalidInitMethod(betterproto.Message):
    module_ref: "ModuleRef" = betterproto.message_field(1)
    init_name: "InitName" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class RejectReasonInvalidReceiveMethod(betterproto.Message):
    module_ref: "ModuleRef" = betterproto.message_field(1)
    receive_name: "ReceiveName" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class RejectReasonAmountTooLarge(betterproto.Message):
    address: "Address" = betterproto.message_field(1)
    amount: "Amount" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class RejectReasonRejectedInit(betterproto.Message):
    reject_reason: int = betterproto.int32_field(1)


@dataclass(eq=False, repr=False)
class RejectReasonRejectedReceive(betterproto.Message):
    reject_reason: int = betterproto.int32_field(1)
    contract_address: "ContractAddress" = betterproto.message_field(2)
    receive_name: "ReceiveName" = betterproto.message_field(3)
    parameter: "Parameter" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class RejectReasonDuplicateCredIds(betterproto.Message):
    ids: List["CredentialRegistrationId"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class RejectReasonNonExistentCredIds(betterproto.Message):
    ids: List["CredentialRegistrationId"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ContractInitializedEvent(betterproto.Message):
    """Data generated as part of initializing a single contract instance."""

    contract_version: "ContractVersion" = betterproto.enum_field(1)
    """Contract version."""

    origin_ref: "ModuleRef" = betterproto.message_field(2)
    """Module with the source code of the contract."""

    address: "ContractAddress" = betterproto.message_field(3)
    """The newly assigned address of the contract."""

    amount: "Amount" = betterproto.message_field(4)
    """The amount the instance was initialized with."""

    init_name: "InitName" = betterproto.message_field(5)
    """The name of the contract."""

    events: List["ContractEvent"] = betterproto.message_field(6)
    """
    Any contract events that might have been genereated by the contract
    initialization.
    """

    parameter: "Parameter" = betterproto.message_field(7)
    """The parameter passed to the initializer."""


@dataclass(eq=False, repr=False)
class ContractEvent(betterproto.Message):
    """An event generated by a smart contract."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class InstanceUpdatedEvent(betterproto.Message):
    """
    Data generated as part of updating a single contract instance. In general a
    single Update transaction will generate one or more of these events,
    together with possibly some transfers.
    """

    contract_version: "ContractVersion" = betterproto.enum_field(1)
    """Contract version."""

    address: "ContractAddress" = betterproto.message_field(2)
    """Address of the affected instance."""

    instigator: "Address" = betterproto.message_field(3)
    """
    The origin of the message to the smart contract. This can be either an
    account or a smart contract.
    """

    amount: "Amount" = betterproto.message_field(4)
    """The amount the method was invoked with."""

    parameter: "Parameter" = betterproto.message_field(5)
    """The parameter passed to the method."""

    receive_name: "ReceiveName" = betterproto.message_field(6)
    """The name of the method that was executed."""

    events: List["ContractEvent"] = betterproto.message_field(7)
    """
    Any contract events that might have been generated by the contract
    execution.
    """


@dataclass(eq=False, repr=False)
class ContractTraceElement(betterproto.Message):
    """
    Effects produced by successful smart contract invocations. A single
    invocation will produce a sequence of these effects.
    """

    updated: "InstanceUpdatedEvent" = betterproto.message_field(1, group="element")
    """A contract instance was updated."""

    transferred: "ContractTraceElementTransferred" = betterproto.message_field(
        2, group="element"
    )
    """A contract transferred an amount to an account."""

    interrupted: "ContractTraceElementInterrupted" = betterproto.message_field(
        3, group="element"
    )
    """
    A contract was interrupted. This occurs when a contract invokes another
    contract or makes a transfer to an account.
    """

    resumed: "ContractTraceElementResumed" = betterproto.message_field(
        4, group="element"
    )
    """A previously interrupted contract was resumed."""

    upgraded: "ContractTraceElementUpgraded" = betterproto.message_field(
        5, group="element"
    )
    """A contract was upgraded."""


@dataclass(eq=False, repr=False)
class ContractTraceElementTransferred(betterproto.Message):
    """A contract transferred an amount to an account."""

    sender: "ContractAddress" = betterproto.message_field(1)
    """Sender contract."""

    amount: "Amount" = betterproto.message_field(2)
    """Amount transferred."""

    receiver: "AccountAddress" = betterproto.message_field(3)
    """Receiver account."""


@dataclass(eq=False, repr=False)
class ContractTraceElementInterrupted(betterproto.Message):
    """
    A contract was interrupted. This occurs when a contract invokes another
    contract or makes a transfer to an account.
    """

    address: "ContractAddress" = betterproto.message_field(1)
    """The contract interrupted."""

    events: List["ContractEvent"] = betterproto.message_field(2)
    """The events generated up until the interruption."""


@dataclass(eq=False, repr=False)
class ContractTraceElementResumed(betterproto.Message):
    """A previously interrupted contract was resumed."""

    address: "ContractAddress" = betterproto.message_field(1)
    """The contract resumed."""

    success: bool = betterproto.bool_field(2)
    """
    Whether the action that caused the interruption (invoke contract or make
    transfer) was successful or not.
    """


@dataclass(eq=False, repr=False)
class ContractTraceElementUpgraded(betterproto.Message):
    """A previously interrupted contract was resumed."""

    address: "ContractAddress" = betterproto.message_field(1)
    """The that was upgraded."""

    from_: "ModuleRef" = betterproto.message_field(2)
    """The module from which the contract was upgraded."""

    to: "ModuleRef" = betterproto.message_field(3)
    """The module to which it was upgraded."""


@dataclass(eq=False, repr=False)
class BakerKeysEvent(betterproto.Message):
    """Result of a successful change of baker keys."""

    baker_id: "BakerId" = betterproto.message_field(1)
    """ID of the baker whose keys were changed."""

    account: "AccountAddress" = betterproto.message_field(2)
    """Account address of the baker."""

    sign_key: "BakerSignatureVerifyKey" = betterproto.message_field(3)
    """The new public key for verifying block signatures."""

    election_key: "BakerElectionVerifyKey" = betterproto.message_field(4)
    """
    The new public key for verifying whether the baker won the block lottery.
    """

    aggregation_key: "BakerAggregationVerifyKey" = betterproto.message_field(5)
    """The new public key for verifying finalization records."""


@dataclass(eq=False, repr=False)
class Memo(betterproto.Message):
    """
    A memo which can be included as part of a transfer. Max size is 256 bytes.
    """

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class BakerStakeUpdatedData(betterproto.Message):
    baker_id: "BakerId" = betterproto.message_field(1)
    """Affected baker."""

    new_stake: "Amount" = betterproto.message_field(2)
    """New stake."""

    increased: bool = betterproto.bool_field(3)
    """
    A boolean which indicates whether it increased (`true`) or decreased
    (`false`).
    """


@dataclass(eq=False, repr=False)
class EncryptedAmountRemovedEvent(betterproto.Message):
    """
    Event generated when one or more encrypted amounts are consumed from the
    account.
    """

    account: "AccountAddress" = betterproto.message_field(1)
    """The affected account."""

    new_amount: "EncryptedAmount" = betterproto.message_field(2)
    """The new self encrypted amount on the affected account."""

    input_amount: "EncryptedAmount" = betterproto.message_field(3)
    """The input encrypted amount that was removed."""

    up_to_index: int = betterproto.uint64_field(4)
    """The index indicating which amounts were used."""


@dataclass(eq=False, repr=False)
class NewEncryptedAmountEvent(betterproto.Message):
    """Event generated when an account receives a new encrypted amount."""

    receiver: "AccountAddress" = betterproto.message_field(1)
    """The account onto which the amount was added."""

    new_index: int = betterproto.uint64_field(2)
    """The index the amount was assigned."""

    encrypted_amount: "EncryptedAmount" = betterproto.message_field(3)
    """The encrypted amount that was added."""


@dataclass(eq=False, repr=False)
class EncryptedSelfAmountAddedEvent(betterproto.Message):
    account: "AccountAddress" = betterproto.message_field(1)
    """The affected account."""

    new_amount: "EncryptedAmount" = betterproto.message_field(2)
    """The new self encrypted amount of the account."""

    amount: "Amount" = betterproto.message_field(3)
    """The amount that was transferred from public to encrypted balance."""


@dataclass(eq=False, repr=False)
class RegisteredData(betterproto.Message):
    """Data registered on the chain with a register data transaction."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class BakerEvent(betterproto.Message):
    """Events that may result from the ConfigureBaker transaction."""

    baker_added: "BakerEventBakerAdded" = betterproto.message_field(1, group="event")
    """A baker was added."""

    baker_removed: "BakerId" = betterproto.message_field(2, group="event")
    """A baker was removed."""

    baker_stake_increased: "BakerEventBakerStakeIncreased" = betterproto.message_field(
        3, group="event"
    )
    """The baker's stake was increased."""

    baker_stake_decreased: "BakerEventBakerStakeDecreased" = betterproto.message_field(
        4, group="event"
    )
    """The baker's stake was decreased."""

    baker_restake_earnings_updated: "BakerEventBakerRestakeEarningsUpdated" = (
        betterproto.message_field(5, group="event")
    )
    """The baker's setting for restaking earnings was updated."""

    baker_keys_updated: "BakerKeysEvent" = betterproto.message_field(6, group="event")
    """Baker keys were updated."""

    baker_set_open_status: "BakerEventBakerSetOpenStatus" = betterproto.message_field(
        7, group="event"
    )
    """The baker's open status was updated."""

    baker_set_metadata_url: "BakerEventBakerSetMetadataUrl" = betterproto.message_field(
        8, group="event"
    )
    """The baker's metadata URL was updated."""

    baker_set_transaction_fee_commission: (
        "BakerEventBakerSetTransactionFeeCommission"
    ) = betterproto.message_field(9, group="event")
    """The baker's transaction fee commission was updated."""

    baker_set_baking_reward_commission: "BakerEventBakerSetBakingRewardCommission" = (
        betterproto.message_field(10, group="event")
    )
    """The baker's baking reward commission was updated."""

    baker_set_finalization_reward_commission: (
        "BakerEventBakerSetFinalizationRewardCommission"
    ) = betterproto.message_field(11, group="event")
    """The baker's finalization reward commission was updated."""

    delegation_removed: "BakerEventDelegationRemoved" = betterproto.message_field(
        12, group="event"
    )
    """An existing delegator was removed."""

    baker_suspended: "BakerEventBakerSuspended" = betterproto.message_field(
        13, group="event"
    )
    """The baker's account has been suspended."""

    baker_resumed: "BakerEventBakerResumed" = betterproto.message_field(
        14, group="event"
    )
    """The baker's account has been suspended."""


@dataclass(eq=False, repr=False)
class BakerEventBakerAdded(betterproto.Message):
    """A baker was added."""

    keys_event: "BakerKeysEvent" = betterproto.message_field(1)
    """The keys with which the baker registered."""

    stake: "Amount" = betterproto.message_field(2)
    """
    The amount the account staked to become a baker. This amount is locked.
    """

    restake_earnings: bool = betterproto.bool_field(3)
    """
    Whether the baker will automatically add earnings to their stake or not.
    """


@dataclass(eq=False, repr=False)
class BakerEventBakerStakeIncreased(betterproto.Message):
    """Baker stake increased."""

    baker_id: "BakerId" = betterproto.message_field(1)
    """Baker's id."""

    new_stake: "Amount" = betterproto.message_field(2)
    """The new stake."""


@dataclass(eq=False, repr=False)
class BakerEventBakerStakeDecreased(betterproto.Message):
    baker_id: "BakerId" = betterproto.message_field(1)
    """Baker's id."""

    new_stake: "Amount" = betterproto.message_field(2)
    """The new stake."""


@dataclass(eq=False, repr=False)
class BakerEventBakerRestakeEarningsUpdated(betterproto.Message):
    baker_id: "BakerId" = betterproto.message_field(1)
    """Baker's id."""

    restake_earnings: bool = betterproto.bool_field(2)
    """The new value of the flag."""


@dataclass(eq=False, repr=False)
class BakerEventBakerSetOpenStatus(betterproto.Message):
    """Updated open status for a baker pool."""

    baker_id: "BakerId" = betterproto.message_field(1)
    """Baker's id."""

    open_status: "OpenStatus" = betterproto.enum_field(2)
    """The new open status."""


@dataclass(eq=False, repr=False)
class BakerEventBakerSetMetadataUrl(betterproto.Message):
    """Updated metadata url for a baker pool."""

    baker_id: "BakerId" = betterproto.message_field(1)
    """Baker's id."""

    url: str = betterproto.string_field(2)
    """The URL."""


@dataclass(eq=False, repr=False)
class BakerEventBakerSetTransactionFeeCommission(betterproto.Message):
    """Updated transaction fee commission for a baker pool."""

    baker_id: "BakerId" = betterproto.message_field(1)
    """Baker's id."""

    transaction_fee_commission: "AmountFraction" = betterproto.message_field(2)
    """The transaction fee commission."""


@dataclass(eq=False, repr=False)
class BakerEventBakerSetBakingRewardCommission(betterproto.Message):
    """Updated baking reward commission for baker pool"""

    baker_id: "BakerId" = betterproto.message_field(1)
    """Baker's id"""

    baking_reward_commission: "AmountFraction" = betterproto.message_field(2)
    """The baking reward commission"""


@dataclass(eq=False, repr=False)
class BakerEventBakerSetFinalizationRewardCommission(betterproto.Message):
    """Updated finalization reward commission for baker pool"""

    baker_id: "BakerId" = betterproto.message_field(1)
    """Baker's id"""

    finalization_reward_commission: "AmountFraction" = betterproto.message_field(2)
    """The finalization reward commission"""


@dataclass(eq=False, repr=False)
class BakerEventDelegationRemoved(betterproto.Message):
    """Removed an existing delegator."""

    delegator_id: "DelegatorId" = betterproto.message_field(1)
    """Delegator's id."""


@dataclass(eq=False, repr=False)
class BakerEventBakerSuspended(betterproto.Message):
    """A baker has been suspended."""

    baker_id: "BakerId" = betterproto.message_field(1)
    """Suspended baker's id"""


@dataclass(eq=False, repr=False)
class BakerEventBakerResumed(betterproto.Message):
    """A baker has been resumed."""

    baker_id: "BakerId" = betterproto.message_field(1)
    """The resumed baker's id"""


@dataclass(eq=False, repr=False)
class DelegatorId(betterproto.Message):
    """The identifier for a delegator."""

    id: "AccountIndex" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DelegationEvent(betterproto.Message):
    delegation_stake_increased: "DelegationEventDelegationStakeIncreased" = (
        betterproto.message_field(1, group="event")
    )
    """The delegator's stake increased."""

    delegation_stake_decreased: "DelegationEventDelegationStakeDecreased" = (
        betterproto.message_field(2, group="event")
    )
    """The delegator's stake decreased."""

    delegation_set_restake_earnings: "DelegationEventDelegationSetRestakeEarnings" = (
        betterproto.message_field(3, group="event")
    )
    """The delegator's restaking setting was updated."""

    delegation_set_delegation_target: "DelegationEventDelegationSetDelegationTarget" = (
        betterproto.message_field(4, group="event")
    )
    """The delegator's delegation target was updated."""

    delegation_added: "DelegatorId" = betterproto.message_field(5, group="event")
    """A delegator was added."""

    delegation_removed: "DelegatorId" = betterproto.message_field(6, group="event")
    """A delegator was removed."""

    baker_removed: "DelegationEventBakerRemoved" = betterproto.message_field(
        7, group="event"
    )
    """An existing baker was removed."""


@dataclass(eq=False, repr=False)
class DelegationEventDelegationStakeIncreased(betterproto.Message):
    delegator_id: "DelegatorId" = betterproto.message_field(1)
    """Delegator's id"""

    new_stake: "Amount" = betterproto.message_field(2)
    """New stake"""


@dataclass(eq=False, repr=False)
class DelegationEventDelegationStakeDecreased(betterproto.Message):
    delegator_id: "DelegatorId" = betterproto.message_field(1)
    """Delegator's id"""

    new_stake: "Amount" = betterproto.message_field(2)
    """New stake"""


@dataclass(eq=False, repr=False)
class DelegationEventDelegationSetRestakeEarnings(betterproto.Message):
    delegator_id: "DelegatorId" = betterproto.message_field(1)
    """Delegator's id"""

    restake_earnings: bool = betterproto.bool_field(2)
    """Whether earnings will be restaked"""


@dataclass(eq=False, repr=False)
class DelegationEventDelegationSetDelegationTarget(betterproto.Message):
    delegator_id: "DelegatorId" = betterproto.message_field(1)
    """Delegator's id"""

    delegation_target: "DelegationTarget" = betterproto.message_field(2)
    """New delegation target"""


@dataclass(eq=False, repr=False)
class DelegationEventBakerRemoved(betterproto.Message):
    baker_id: "BakerId" = betterproto.message_field(1)
    """Baker's id"""


@dataclass(eq=False, repr=False)
class AccountTransactionEffects(betterproto.Message):
    """
    Effects of an account transaction. All variants except `None` correspond to
    a unique transaction that was successful.
    """

    none: "AccountTransactionEffectsNone" = betterproto.message_field(1, group="effect")
    """
    No effects other than payment from this transaction. The rejection reason
    indicates why the transaction failed.
    """

    module_deployed: "ModuleRef" = betterproto.message_field(2, group="effect")
    """A smart contract module with the attached reference was deployed."""

    contract_initialized: "ContractInitializedEvent" = betterproto.message_field(
        3, group="effect"
    )
    """A smart contract was initialized."""

    contract_update_issued: "AccountTransactionEffectsContractUpdateIssued" = (
        betterproto.message_field(4, group="effect")
    )
    """A smart contract instance updated was issued."""

    account_transfer: "AccountTransactionEffectsAccountTransfer" = (
        betterproto.message_field(5, group="effect")
    )
    """A simple account to account transfer occurred."""

    baker_added: "BakerEventBakerAdded" = betterproto.message_field(6, group="effect")
    """A baker was added."""

    baker_removed: "BakerId" = betterproto.message_field(7, group="effect")
    """A baker was removed."""

    baker_stake_updated: "AccountTransactionEffectsBakerStakeUpdated" = (
        betterproto.message_field(8, group="effect")
    )
    """A baker's stake was updated."""

    baker_restake_earnings_updated: "BakerEventBakerRestakeEarningsUpdated" = (
        betterproto.message_field(9, group="effect")
    )
    """A baker's restake earnings setting was updated."""

    baker_keys_updated: "BakerKeysEvent" = betterproto.message_field(10, group="effect")
    """A baker's keys were updated."""

    encrypted_amount_transferred: (
        "AccountTransactionEffectsEncryptedAmountTransferred"
    ) = betterproto.message_field(11, group="effect")
    """An encrypted amount was transferred."""

    transferred_to_encrypted: "EncryptedSelfAmountAddedEvent" = (
        betterproto.message_field(12, group="effect")
    )
    """
    An account transferred part of its public balance to its encrypted balance.
    """

    transferred_to_public: "AccountTransactionEffectsTransferredToPublic" = (
        betterproto.message_field(13, group="effect")
    )
    """
    An account transferred part of its encrypted balance to its public balance.
    """

    transferred_with_schedule: "AccountTransactionEffectsTransferredWithSchedule" = (
        betterproto.message_field(14, group="effect")
    )
    """A transfer with a release schedule was made."""

    credential_keys_updated: "CredentialRegistrationId" = betterproto.message_field(
        15, group="effect"
    )
    """Keys of a specific credential were updated."""

    credentials_updated: "AccountTransactionEffectsCredentialsUpdated" = (
        betterproto.message_field(16, group="effect")
    )
    """Account credentials were updated."""

    data_registered: "RegisteredData" = betterproto.message_field(17, group="effect")
    """Some data was registered on the chain."""

    baker_configured: "AccountTransactionEffectsBakerConfigured" = (
        betterproto.message_field(18, group="effect")
    )
    """
    A baker was configured. The details of what happened are contained in a
    list of BakerEvents.
    """

    delegation_configured: "AccountTransactionEffectsDelegationConfigured" = (
        betterproto.message_field(19, group="effect")
    )
    """
    A delegator was configured. The details of what happened are contained in a
    list of DelegatorEvents.
    """


@dataclass(eq=False, repr=False)
class AccountTransactionEffectsNone(betterproto.Message):
    """
    No effects other than payment from this transaction. The rejection reason
    indicates why the transaction failed.
    """

    transaction_type: Optional["TransactionType"] = betterproto.enum_field(
        1, optional=True, group="_transaction_type"
    )
    """
    Transaction type of a failed transaction, if known. In case of
    serialization failure this will not be set.
    """

    reject_reason: "RejectReason" = betterproto.message_field(2)
    """Reason for rejection of the transaction."""


@dataclass(eq=False, repr=False)
class AccountTransactionEffectsContractUpdateIssued(betterproto.Message):
    """
    A contract update transaction was issued and produced the given trace. This
    is the result of Update transaction.
    """

    effects: List["ContractTraceElement"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class AccountTransactionEffectsAccountTransfer(betterproto.Message):
    """
    A simple account to account transfer occurred. This is the result of a
    successful Transfer transaction.
    """

    amount: "Amount" = betterproto.message_field(1)
    """Amount that was transferred."""

    receiver: "AccountAddress" = betterproto.message_field(2)
    """Receiver account."""

    memo: Optional["Memo"] = betterproto.message_field(3, optional=True, group="_memo")
    """Memo."""


@dataclass(eq=False, repr=False)
class AccountTransactionEffectsBakerStakeUpdated(betterproto.Message):
    """
    An account was deregistered as a baker. This is the result of a successful
    UpdateBakerStake transaction.
    """

    update: Optional["BakerStakeUpdatedData"] = betterproto.message_field(
        1, optional=True, group="_update"
    )
    """
    If the stake was updated (that is, it changed and did not stay the same)
    then this is present, otherwise it is not present.
    """


@dataclass(eq=False, repr=False)
class AccountTransactionEffectsEncryptedAmountTransferred(betterproto.Message):
    """
    An encrypted amount was transferred. This is the result of a successful
    EncryptedAmountTransfer transaction.
    """

    removed: "EncryptedAmountRemovedEvent" = betterproto.message_field(1)
    added: "NewEncryptedAmountEvent" = betterproto.message_field(2)
    memo: Optional["Memo"] = betterproto.message_field(3, optional=True, group="_memo")


@dataclass(eq=False, repr=False)
class AccountTransactionEffectsTransferredToPublic(betterproto.Message):
    """
    An account transferred part of its encrypted balance to its public balance.
    This is the result of a successful TransferToPublic transaction.
    """

    removed: "EncryptedAmountRemovedEvent" = betterproto.message_field(1)
    amount: "Amount" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class AccountTransactionEffectsTransferredWithSchedule(betterproto.Message):
    """
    A transfer with schedule was performed. This is the result of a successful
    TransferWithSchedule transaction.
    """

    receiver: "AccountAddress" = betterproto.message_field(1)
    """Receiver account."""

    amount: List["NewRelease"] = betterproto.message_field(2)
    """The list of releases. Ordered by increasing timestamp."""

    memo: Optional["Memo"] = betterproto.message_field(3, optional=True, group="_memo")
    """Optional memo."""


@dataclass(eq=False, repr=False)
class AccountTransactionEffectsCredentialsUpdated(betterproto.Message):
    """
    Account's credentials were updated. This is the result of a successful
    UpdateCredentials transaction.
    """

    new_cred_ids: List["CredentialRegistrationId"] = betterproto.message_field(1)
    """The credential ids that were added."""

    removed_cred_ids: List["CredentialRegistrationId"] = betterproto.message_field(2)
    """The credentials that were removed."""

    new_threshold: "AccountThreshold" = betterproto.message_field(3)
    """The (possibly) updated account threshold."""


@dataclass(eq=False, repr=False)
class AccountTransactionEffectsBakerConfigured(betterproto.Message):
    """
    A baker was configured. The details of what happened are contained in the
    list of BakerEvents.
    """

    events: List["BakerEvent"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class AccountTransactionEffectsDelegationConfigured(betterproto.Message):
    """
    An account configured delegation. The details of what happened are
    contained in the list of DelegationEvents.
    """

    events: List["DelegationEvent"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ElectionDifficulty(betterproto.Message):
    """Election difficulty parameter."""

    value: "AmountFraction" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class TimeoutParameters(betterproto.Message):
    """
    Parameters that determine timeouts in the consensus protocol used from
    protocol version 6.
    """

    timeout_base: "Duration" = betterproto.message_field(1)
    """The base value for triggering a timeout"""

    timeout_increase: "Ratio" = betterproto.message_field(2)
    """Factor for increasing the timeout. Must be greater than 1."""

    timeout_decrease: "Ratio" = betterproto.message_field(3)
    """Factor for decreasing the timeout. Must be between 0 and 1."""


@dataclass(eq=False, repr=False)
class FinalizationCommitteeParameters(betterproto.Message):
    """Finalization committee parameters used from protocol version 6"""

    minimum_finalizers: int = betterproto.uint32_field(1)
    """
    The minimum size of a finalization committee before
    `finalizer_relative_stake_threshold` takes effect.
    """

    maximum_finalizers: int = betterproto.uint32_field(2)
    """The maximum size of a finalization committee."""

    finalizer_relative_stake_threshold: "AmountFraction" = betterproto.message_field(3)
    """
    The threshold for determining the stake required for being eligible the
    finalization committee. The amount is given by `total stake in pools *
    finalizer_relative_stake_threshold`
    """


@dataclass(eq=False, repr=False)
class ValidatorScoreParameters(betterproto.Message):
    maximum_missed_rounds: int = betterproto.uint64_field(1)
    """
    The maximal number of missed rounds before a validator gets suspended.
    """


@dataclass(eq=False, repr=False)
class ConsensusParametersV1(betterproto.Message):
    """Parameters for the consensus protocol used from protocol version 6."""

    timeout_parameters: "TimeoutParameters" = betterproto.message_field(1)
    """Parameters controlling round timeouts."""

    min_block_time: "Duration" = betterproto.message_field(2)
    """Minimum time interval between blocks."""

    block_energy_limit: "Energy" = betterproto.message_field(3)
    """Maximum energy allowed per block."""


@dataclass(eq=False, repr=False)
class ExchangeRate(betterproto.Message):
    """Represents an exchange rate."""

    value: "Ratio" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Ratio(betterproto.Message):
    """Represents a ratio, i.e., 'numerator / denominator'."""

    numerator: int = betterproto.uint64_field(1)
    """The numerator."""

    denominator: int = betterproto.uint64_field(2)
    """The denominator."""


@dataclass(eq=False, repr=False)
class UpdatePublicKey(betterproto.Message):
    """A public key used for chain updates."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class UpdateKeysThreshold(betterproto.Message):
    """
    The threshold for how many UpdatePublicKeys are need to make a certain
    chain update.
    """

    value: int = betterproto.uint32_field(1)
    """Is ensured to be within between 1 and 2^16."""


@dataclass(eq=False, repr=False)
class UpdateKeysIndex(betterproto.Message):
    """Index of a key in an authorizations update payload."""

    value: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class HigherLevelKeys(betterproto.Message):
    """Represents root or level 1 keys."""

    keys: List["UpdatePublicKey"] = betterproto.message_field(1)
    """The keys."""

    threshold: "UpdateKeysThreshold" = betterproto.message_field(2)
    """The number of keys needed to make a chain update."""


@dataclass(eq=False, repr=False)
class AccessStructure(betterproto.Message):
    """
    An access structure which specifies which UpdatePublicKeys in a
    HigherLevelKeys that are allowed to make chain update of a specific type.
    The threshold defines the minimum number of allowed keys needed to make the
    actual update.
    """

    access_public_keys: List["UpdateKeysIndex"] = betterproto.message_field(1)
    """Unique indexes into the set of keys in AuthorizationV0."""

    access_threshold: "UpdateKeysThreshold" = betterproto.message_field(2)
    """Number of keys requred to authorize an update."""


@dataclass(eq=False, repr=False)
class AuthorizationsV0(betterproto.Message):
    """
    The set of keys authorized for chain updates, together with access
    structures determining which keys are authorized for which update types.
    This is the payload of an update to authorization.
    """

    keys: List["UpdatePublicKey"] = betterproto.message_field(1)
    """The set of keys authorized for chain updates."""

    emergency: "AccessStructure" = betterproto.message_field(2)
    """New emergency keys."""

    protocol: "AccessStructure" = betterproto.message_field(3)
    """New protocol update keys."""

    parameter_consensus: "AccessStructure" = betterproto.message_field(4)
    """
    Access structure for updating the consensus parameters. Previously, this
    was the election difficulty.
    """

    parameter_euro_per_energy: "AccessStructure" = betterproto.message_field(5)
    """Access structure for updating the euro per energy."""

    parameter_micro_ccd_per_euro: "AccessStructure" = betterproto.message_field(6)
    """Access structure for updating the micro CCD per euro."""

    parameter_foundation_account: "AccessStructure" = betterproto.message_field(7)
    """Access structure for updating the foundation account."""

    parameter_mint_distribution: "AccessStructure" = betterproto.message_field(8)
    """Access structure for updating the mint distribution."""

    parameter_transaction_fee_distribution: "AccessStructure" = (
        betterproto.message_field(9)
    )
    """Access structure for updating the transaction fee distribution."""

    parameter_gas_rewards: "AccessStructure" = betterproto.message_field(10)
    """Access structure for updating the gas rewards."""

    pool_parameters: "AccessStructure" = betterproto.message_field(11)
    """
    Access structure for updating the pool parameters. For V0 this is only the
    baker stake threshold, for V1 there are more.
    """

    add_anonymity_revoker: "AccessStructure" = betterproto.message_field(12)
    """Access structure for adding new anonymity revokers."""

    add_identity_provider: "AccessStructure" = betterproto.message_field(13)
    """Access structure for adding new identity providers."""


@dataclass(eq=False, repr=False)
class AuthorizationsV1(betterproto.Message):
    """
    The set of keys authorized for chain updates, together with access
    structures determining which keys are authorized for which update types.
    This is the payload of an update to authorization.
    """

    v0: "AuthorizationsV0" = betterproto.message_field(1)
    parameter_cooldown: "AccessStructure" = betterproto.message_field(2)
    """
    Access structure for updating the cooldown periods related to baking and
    delegation.
    """

    parameter_time: "AccessStructure" = betterproto.message_field(3)
    """Access structure for updating the length of the reward period."""


@dataclass(eq=False, repr=False)
class Description(betterproto.Message):
    """
    Description either of an anonymity revoker or identity provider. Metadata
    that should be visible on the chain.
    """

    name: str = betterproto.string_field(1)
    """The name."""

    url: str = betterproto.string_field(2)
    """
    A link to more information about the anonymity revoker or identity
    provider.
    """

    description: str = betterproto.string_field(3)
    """A free form description of the revoker or provider."""


@dataclass(eq=False, repr=False)
class ArInfo(betterproto.Message):
    """
    Information on a single anonymity revoker help by the identity provider.
    Typically an identity provider will hold more than one.
    """

    identity: "ArInfoArIdentity" = betterproto.message_field(1)
    """Unique identifier of the anonymity revoker."""

    description: "Description" = betterproto.message_field(2)
    """Description of the anonymity revoker."""

    public_key: "ArInfoArPublicKey" = betterproto.message_field(3)
    """Elgamal encryption key of the anonymity revoker."""


@dataclass(eq=False, repr=False)
class ArInfoArIdentity(betterproto.Message):
    """
    Identity of the anonymity revoker on the chain. This defines their
    evaluateion point for secret sharing, and thus it cannot be 0.
    """

    value: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class ArInfoArPublicKey(betterproto.Message):
    """Public key of an anonymity revoker."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class IpIdentity(betterproto.Message):
    """
    A succinct identifier of an identity provider on the chain. In credential
    deployments, and other interactions with the chain this is used to identify
    which identity provider is meant.
    """

    value: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class IpInfo(betterproto.Message):
    """Public information about an identity provider."""

    identity: "IpIdentity" = betterproto.message_field(1)
    """Unique identifier of the identity provider."""

    description: "Description" = betterproto.message_field(2)
    """Description of the identity provider."""

    verify_key: "IpInfoIpVerifyKey" = betterproto.message_field(3)
    """Pointcheval-Sanders public key of the identity provider."""

    cdi_verify_key: "IpInfoIpCdiVerifyKey" = betterproto.message_field(4)
    """Ed25519 public key of the identity provider."""


@dataclass(eq=False, repr=False)
class IpInfoIpVerifyKey(betterproto.Message):
    """Pointcheval-Sanders public key of the identity provider."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class IpInfoIpCdiVerifyKey(betterproto.Message):
    """Ed25519 public key of the identity provider."""

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class DurationSeconds(betterproto.Message):
    """A duration in seconds."""

    value: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class InclusiveRangeAmountFraction(betterproto.Message):
    """Inclusive range of amount fractions."""

    min: "AmountFraction" = betterproto.message_field(1)
    max: "AmountFraction" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class CommissionRanges(betterproto.Message):
    """Ranges of allowed commission values that pools may choose from."""

    finalization: "InclusiveRangeAmountFraction" = betterproto.message_field(1)
    """The range of allowed finalization commissions."""

    baking: "InclusiveRangeAmountFraction" = betterproto.message_field(2)
    """The range of allowed baker commissions."""

    transaction: "InclusiveRangeAmountFraction" = betterproto.message_field(3)
    """The range of allowed transaction commissions."""


@dataclass(eq=False, repr=False)
class CapitalBound(betterproto.Message):
    """
    A bound on the relative share of the total staked capital that a baker can
    have as its stake. This is required to be greater than 0.
    """

    value: "AmountFraction" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class LeverageFactor(betterproto.Message):
    """A leverage factor."""

    value: "Ratio" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Epoch(betterproto.Message):
    """A chain epoch."""

    value: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class Round(betterproto.Message):
    """A round."""

    value: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class RewardPeriodLength(betterproto.Message):
    """
    Length of a reward period in epochs. Must always be a strictly positive
    number.
    """

    value: "Epoch" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class MintRate(betterproto.Message):
    """A minting rate of CCD. The value is `mantissa * 10^(-exponent)`."""

    mantissa: int = betterproto.uint32_field(1)
    exponent: int = betterproto.uint32_field(2)
    """This will never exceed 255 and can thus be stored in a single byte."""


@dataclass(eq=False, repr=False)
class CooldownParametersCpv1(betterproto.Message):
    pool_owner_cooldown: "DurationSeconds" = betterproto.message_field(1)
    """
    Number of seconds that pool owners must cooldown when reducing their equity
    capital or closing the pool.
    """

    delegator_cooldown: "DurationSeconds" = betterproto.message_field(2)
    """
    Number of seconds that a delegator must cooldown when reducing their
    delegated stake.
    """


@dataclass(eq=False, repr=False)
class PoolParametersCpv1(betterproto.Message):
    """Parameters related to staking pools."""

    passive_finalization_commission: "AmountFraction" = betterproto.message_field(1)
    """Fraction of finalization rewards charged by the passive delegation."""

    passive_baking_commission: "AmountFraction" = betterproto.message_field(2)
    """Fraction of baking rewards charged by the passive delegation."""

    passive_transaction_commission: "AmountFraction" = betterproto.message_field(3)
    """Fraction of transaction rewards charged by the L-pool."""

    commission_bounds: "CommissionRanges" = betterproto.message_field(4)
    """Bounds on the commission rates that may be charged by bakers."""

    minimum_equity_capital: "Amount" = betterproto.message_field(5)
    """Minimum equity capital required for a new baker."""

    capital_bound: "CapitalBound" = betterproto.message_field(6)
    """
    Maximum fraction of the total staked capital of that a new baker can have.
    """

    leverage_bound: "LeverageFactor" = betterproto.message_field(7)
    """
    The maximum leverage that a baker can have as a ratio of total stake to
    equity capital.
    """


@dataclass(eq=False, repr=False)
class TimeParametersCpv1(betterproto.Message):
    """
    The time parameters are introduced as of protocol version 4, and consist of
    the reward period length and the mint rate per payday. These are coupled as
    a change to either affects the overall rate of minting.
    """

    reward_period_length: "RewardPeriodLength" = betterproto.message_field(1)
    mint_per_payday: "MintRate" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class MintDistributionCpv1(betterproto.Message):
    """
    Mint distribution payload as it looks in protocol version 4 and onward.
    """

    baking_reward: "AmountFraction" = betterproto.message_field(1)
    finalization_reward: "AmountFraction" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ProtocolUpdate(betterproto.Message):
    message: str = betterproto.string_field(1)
    """A brief message about the update."""

    specification_url: str = betterproto.string_field(2)
    """A URL of a document describing the update."""

    specification_hash: "Sha256Hash" = betterproto.message_field(3)
    """SHA256 hash of the specification document."""

    specification_auxiliary_data: bytes = betterproto.bytes_field(4)
    """
    Auxiliary data whose interpretation is defined by the new specification.
    """


@dataclass(eq=False, repr=False)
class MintDistributionCpv0(betterproto.Message):
    """
    The minting rate and the distribution of newly-minted CCD among bakers,
    finalizers, and the foundation account. It must be the case that
    baking_reward + finalization_reward <= 1. The remaining amount is the
    platform development charge.
    """

    mint_per_slot: "MintRate" = betterproto.message_field(1)
    """Mint rate per slot."""

    baking_reward: "AmountFraction" = betterproto.message_field(2)
    """The fraction of newly created CCD allocated to baker rewards."""

    finalization_reward: "AmountFraction" = betterproto.message_field(3)
    """The fraction of newly created CCD allocated to finalization rewards."""


@dataclass(eq=False, repr=False)
class TransactionFeeDistribution(betterproto.Message):
    """Parameters determining the distribution of transaction fees."""

    baker: "AmountFraction" = betterproto.message_field(1)
    """The fraction allocated to the baker."""

    gas_account: "AmountFraction" = betterproto.message_field(2)
    """The fraction allocated to the GAS account."""


@dataclass(eq=False, repr=False)
class GasRewards(betterproto.Message):
    """Distribution of gas rewards for chain parameters version 0 and 1."""

    baker: "AmountFraction" = betterproto.message_field(1)
    """The fraction paid to the baker."""

    finalization_proof: "AmountFraction" = betterproto.message_field(2)
    """Fraction paid for including a finalization proof in a block."""

    account_creation: "AmountFraction" = betterproto.message_field(3)
    """
    Fraction paid for including each account creation transaction in a block.
    """

    chain_update: "AmountFraction" = betterproto.message_field(4)
    """Fraction paid for including an update transaction in a block."""


@dataclass(eq=False, repr=False)
class GasRewardsCpv2(betterproto.Message):
    """Distribution of gas rewards for chain parameters version 2."""

    baker: "AmountFraction" = betterproto.message_field(1)
    """The fraction paid to the baker."""

    account_creation: "AmountFraction" = betterproto.message_field(3)
    """
    Fraction paid for including each account creation transaction in a block.
    """

    chain_update: "AmountFraction" = betterproto.message_field(4)
    """Fraction paid for including an update transaction in a block."""


@dataclass(eq=False, repr=False)
class BakerStakeThreshold(betterproto.Message):
    """
    Minimum stake needed to become a baker. This only applies to protocol
    version 1-3.
    """

    baker_stake_threshold: "Amount" = betterproto.message_field(1)
    """Minimum threshold required for registering as a baker."""


@dataclass(eq=False, repr=False)
class RootUpdate(betterproto.Message):
    """
    Root updates are the highest kind of key updates. They can update every
    other set of keys, even themselves. They can only be performed by Root
    level keys.
    """

    root_keys_update: "HigherLevelKeys" = betterproto.message_field(
        1, group="update_type"
    )
    """The root keys were updated."""

    level_1_keys_update: "HigherLevelKeys" = betterproto.message_field(
        2, group="update_type"
    )
    """The level 1 keys were updated."""

    level_2_keys_update_v0: "AuthorizationsV0" = betterproto.message_field(
        3, group="update_type"
    )
    """The level 2 keys were updated."""

    level_2_keys_update_v1: "AuthorizationsV1" = betterproto.message_field(
        4, group="update_type"
    )
    """
    The level 2 keys were updated. This is similar to `level_2_keys_update_v0`
    except that a few more keys can be updated.
    """


@dataclass(eq=False, repr=False)
class Level1Update(betterproto.Message):
    """
    Level 1 updates are the intermediate update kind. They can update
    themselves or level 2 keys. They can only be performed by level 1 keys.
    """

    level_1_keys_update: "HigherLevelKeys" = betterproto.message_field(
        1, group="update_type"
    )
    """The level 1 keys were updated."""

    level_2_keys_update_v0: "AuthorizationsV0" = betterproto.message_field(
        2, group="update_type"
    )
    """The level 2 keys were updated."""

    level_2_keys_update_v1: "AuthorizationsV1" = betterproto.message_field(
        3, group="update_type"
    )
    """
    The level 2 keys were updated. This is similar to `level_2_keys_update_v0`
    except that a few more keys can be updated.
    """


@dataclass(eq=False, repr=False)
class UpdatePayload(betterproto.Message):
    """The payload of a chain update."""

    protocol_update: "ProtocolUpdate" = betterproto.message_field(1, group="payload")
    """The protocol version was updated."""

    election_difficulty_update: "ElectionDifficulty" = betterproto.message_field(
        2, group="payload"
    )
    """The election difficulty was updated."""

    euro_per_energy_update: "ExchangeRate" = betterproto.message_field(
        3, group="payload"
    )
    """The euro per energy exchange rate was updated."""

    micro_ccd_per_euro_update: "ExchangeRate" = betterproto.message_field(
        4, group="payload"
    )
    """The microCCD per euro exchange rate was updated."""

    foundation_account_update: "AccountAddress" = betterproto.message_field(
        5, group="payload"
    )
    """The foundation account address was updated."""

    mint_distribution_update: "MintDistributionCpv0" = betterproto.message_field(
        6, group="payload"
    )
    """The mint distribution was updated."""

    transaction_fee_distribution_update: "TransactionFeeDistribution" = (
        betterproto.message_field(7, group="payload")
    )
    """The transaction fee distribtuion was updated."""

    gas_rewards_update: "GasRewards" = betterproto.message_field(8, group="payload")
    """The gas rewards were updated."""

    baker_stake_threshold_update: "BakerStakeThreshold" = betterproto.message_field(
        9, group="payload"
    )
    """The minimum amount of CCD needed to be come a baker was updated."""

    root_update: "RootUpdate" = betterproto.message_field(10, group="payload")
    """The root keys were updated."""

    level_1_update: "Level1Update" = betterproto.message_field(11, group="payload")
    """The level 1 keys were updated."""

    add_anonymity_revoker_update: "ArInfo" = betterproto.message_field(
        12, group="payload"
    )
    """An anonymity revoker was added."""

    add_identity_provider_update: "IpInfo" = betterproto.message_field(
        13, group="payload"
    )
    """An identity provider was added."""

    cooldown_parameters_cpv_1_update: "CooldownParametersCpv1" = (
        betterproto.message_field(14, group="payload")
    )
    """The cooldown parameters were updated."""

    pool_parameters_cpv_1_update: "PoolParametersCpv1" = betterproto.message_field(
        15, group="payload"
    )
    """The pool parameters were updated."""

    time_parameters_cpv_1_update: "TimeParametersCpv1" = betterproto.message_field(
        16, group="payload"
    )
    """The time parameters were updated."""

    mint_distribution_cpv_1_update: "MintDistributionCpv1" = betterproto.message_field(
        17, group="payload"
    )
    """The mint distribution was updated."""

    gas_rewards_cpv_2_update: "GasRewardsCpv2" = betterproto.message_field(
        18, group="payload"
    )
    """The gas rewards were updated (chain parameters version 2)."""

    timeout_parameters_update: "TimeoutParameters" = betterproto.message_field(
        19, group="payload"
    )
    """The consensus timeouts were updated (chain parameters version 2)."""

    min_block_time_update: "Duration" = betterproto.message_field(20, group="payload")
    """
    The minimum time between blocks was updated (chain parameters version 2).
    """

    block_energy_limit_update: "Energy" = betterproto.message_field(21, group="payload")
    """The block energy limit was updated (chain parameters version 2)."""

    finalization_committee_parameters_update: "FinalizationCommitteeParameters" = (
        betterproto.message_field(22, group="payload")
    )
    """Finalization committee parameters (chain parameters version 2)."""

    validator_score_parameters_update: "ValidatorScoreParameters" = (
        betterproto.message_field(23, group="payload")
    )
    """Validator score parameters (chain parameters version 3)"""


@dataclass(eq=False, repr=False)
class AccountTransactionDetails(betterproto.Message):
    """Details about an account transaction."""

    cost: "Amount" = betterproto.message_field(1)
    """The cost of the transaction. Paid by the sender."""

    sender: "AccountAddress" = betterproto.message_field(2)
    """The sender of the transaction."""

    effects: "AccountTransactionEffects" = betterproto.message_field(3)
    """The effects of the transaction."""


@dataclass(eq=False, repr=False)
class AccountCreationDetails(betterproto.Message):
    """
    Details of an account creation. These transactions are free, and we only
    ever get a response for them if the account is created, hence no failure
    cases.
    """

    credential_type: "CredentialType" = betterproto.enum_field(1)
    """Whether this is an initial or normal account."""

    address: "AccountAddress" = betterproto.message_field(2)
    """Address of the newly created account."""

    reg_id: "CredentialRegistrationId" = betterproto.message_field(3)
    """Credential registration ID of the first credential."""


@dataclass(eq=False, repr=False)
class TransactionTime(betterproto.Message):
    """Transaction time specified as seconds since unix epoch."""

    value: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class UpdateDetails(betterproto.Message):
    """
    Details of an update instruction. These are free, and we only ever get a
    response for them if the update is successfully enqueued, hence no failure
    cases.
    """

    effective_time: "TransactionTime" = betterproto.message_field(1)
    """The time at which the update will be effective."""

    payload: "UpdatePayload" = betterproto.message_field(2)
    """The paylaod for the update."""


@dataclass(eq=False, repr=False)
class BlockItemSummary(betterproto.Message):
    """
    Summary of the outcome of a block item in structured form. The summary
    determines which transaction type it was.
    """

    index: "BlockItemSummaryTransactionIndex" = betterproto.message_field(1)
    """Index of the transaction in the block where it is included."""

    energy_cost: "Energy" = betterproto.message_field(2)
    """The amount of NRG the transaction cost."""

    hash: "TransactionHash" = betterproto.message_field(3)
    """Hash of the transaction."""

    account_transaction: "AccountTransactionDetails" = betterproto.message_field(
        4, group="details"
    )
    """Details about an account transaction."""

    account_creation: "AccountCreationDetails" = betterproto.message_field(
        5, group="details"
    )
    """Details about an account creation."""

    update: "UpdateDetails" = betterproto.message_field(6, group="details")
    """Details about a chain update."""


@dataclass(eq=False, repr=False)
class BlockItemSummaryTransactionIndex(betterproto.Message):
    value: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class GenesisIndex(betterproto.Message):
    """
    The number of chain restarts via a protocol update. An effected protocol
    update instruction might not change the protocol version specified in the
    previous field, but it always increments the genesis index.
    """

    value: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class ConsensusInfo(betterproto.Message):
    """The response for GetConsensusInfo."""

    best_block: "BlockHash" = betterproto.message_field(1)
    """Hash of the current best block."""

    genesis_block: "BlockHash" = betterproto.message_field(2)
    """Hash of the (original) genesis block."""

    genesis_time: "Timestamp" = betterproto.message_field(3)
    """Time of the (original) genesis block."""

    slot_duration: Optional["Duration"] = betterproto.message_field(
        4, optional=True, group="_slot_duration"
    )
    """
    (Current) slot duration in milliseconds. Present only in protocol versions
    1-5.
    """

    epoch_duration: "Duration" = betterproto.message_field(5)
    """(Current) epoch duration in milliseconds."""

    last_finalized_block: "BlockHash" = betterproto.message_field(6)
    """Hash of the last finalized block."""

    best_block_height: "AbsoluteBlockHeight" = betterproto.message_field(7)
    """Absolute height of the best block."""

    last_finalized_block_height: "AbsoluteBlockHeight" = betterproto.message_field(8)
    """Absolute height of the last finalized block."""

    blocks_received_count: int = betterproto.uint32_field(9)
    """Total number of blocks received."""

    block_last_received_time: Optional["Timestamp"] = betterproto.message_field(
        10, optional=True, group="_block_last_received_time"
    )
    """The last time a block was received."""

    block_receive_latency_ema: float = betterproto.double_field(11)
    """
    Exponential moving average latency between a block's slot time and received
    time.
    """

    block_receive_latency_emsd: float = betterproto.double_field(12)
    """
    Standard deviation of exponential moving average latency between a block's
    slot time and received time.
    """

    block_receive_period_ema: Optional[float] = betterproto.double_field(
        13, optional=True, group="_block_receive_period_ema"
    )
    """Exponential moving average time between receiving blocks."""

    block_receive_period_emsd: Optional[float] = betterproto.double_field(
        14, optional=True, group="_block_receive_period_emsd"
    )
    """
    Standard deviation of exponential moving average time between receiving
    blocks.
    """

    blocks_verified_count: int = betterproto.uint32_field(15)
    """Total number of blocks received and verified."""

    block_last_arrived_time: Optional["Timestamp"] = betterproto.message_field(
        16, optional=True, group="_block_last_arrived_time"
    )
    """The last time a block was verified (added to the tree)."""

    block_arrive_latency_ema: float = betterproto.double_field(17)
    """
    Exponential moving average latency between a block's slot time and its
    arrival.
    """

    block_arrive_latency_emsd: float = betterproto.double_field(18)
    """
    Standard deviation of exponential moving average latency between a block's
    slot time and its arrival.
    """

    block_arrive_period_ema: Optional[float] = betterproto.double_field(
        19, optional=True, group="_block_arrive_period_ema"
    )
    """Exponential moving average time between block arrivals."""

    block_arrive_period_emsd: Optional[float] = betterproto.double_field(
        20, optional=True, group="_block_arrive_period_emsd"
    )
    """
    Standard deviation of exponential moving average time between block
    arrivals.
    """

    transactions_per_block_ema: float = betterproto.double_field(21)
    """Exponential moving average number of transactions per block."""

    transactions_per_block_emsd: float = betterproto.double_field(22)
    """
    Standard deviation of exponential moving average number of transactions per
    block.
    """

    finalization_count: int = betterproto.uint32_field(23)
    """Number of finalizations."""

    last_finalized_time: Optional["Timestamp"] = betterproto.message_field(
        24, optional=True, group="_last_finalized_time"
    )
    """Time of last verified finalization."""

    finalization_period_ema: Optional[float] = betterproto.double_field(
        25, optional=True, group="_finalization_period_ema"
    )
    """Exponential moving average time between finalizations."""

    finalization_period_emsd: Optional[float] = betterproto.double_field(
        26, optional=True, group="_finalization_period_emsd"
    )
    """
    Standard deviation of exponential moving average time between
    finalizations.
    """

    protocol_version: "ProtocolVersion" = betterproto.enum_field(27)
    """Currently active protocol version."""

    genesis_index: "GenesisIndex" = betterproto.message_field(28)
    """
    The number of chain restarts via a protocol update. A completed protocol
    update instruction might not change the protocol version specified in the
    previous field, but it always increments the genesis index.
    """

    current_era_genesis_block: "BlockHash" = betterproto.message_field(29)
    """
    Block hash of the genesis block of current era, i.e., since the last
    protocol update. Initially this is equal to 'genesis_block'.
    """

    current_era_genesis_time: "Timestamp" = betterproto.message_field(30)
    """Time when the current era started."""

    current_timeout_duration: Optional["Duration"] = betterproto.message_field(
        31, optional=True, group="_current_timeout_duration"
    )
    """
    The current duration to wait before a round times out. Present from
    protocol version 6.
    """

    current_round: Optional["Round"] = betterproto.message_field(
        32, optional=True, group="_current_round"
    )
    """The current round. Present from protocol version 6."""

    current_epoch: Optional["Epoch"] = betterproto.message_field(
        33, optional=True, group="_current_epoch"
    )
    """The current epoch. Present from protocol version 6."""

    trigger_block_time: Optional["Timestamp"] = betterproto.message_field(
        34, optional=True, group="_trigger_block_time"
    )
    """
    The first block in the epoch with timestamp at least this is considered to
    be the trigger block for the epoch transition. Present from protocol
    version 6.
    """


@dataclass(eq=False, repr=False)
class ArrivedBlockInfo(betterproto.Message):
    """
    Information about an arrived block that is part of the streaming response.
    """

    hash: "BlockHash" = betterproto.message_field(1)
    """Hash of the block."""

    height: "AbsoluteBlockHeight" = betterproto.message_field(2)
    """Absolute height of the block, height 0 is the genesis block."""


@dataclass(eq=False, repr=False)
class CryptographicParameters(betterproto.Message):
    """The response for GetCryptographicParameters."""

    genesis_string: str = betterproto.string_field(1)
    """
    A free-form string used to distinguish between different chains even if
    they share other parameters.
    """

    bulletproof_generators: bytes = betterproto.bytes_field(2)
    """
    Generators for the bulletproofs. It is a serialized list of 256 group
    elements in the G1 group of the BLS12-381 curve.
    """

    on_chain_commitment_key: bytes = betterproto.bytes_field(3)
    """
    A shared commitment key known to the chain and the account holder (and
    therefore it is public). The account holder uses this commitment key to
    generate commitments to values in the attribute list. It is a serialized
    pair of group elements  in the G1 group of the BLS12-381 curve.
    """


@dataclass(eq=False, repr=False)
class BlockInfo(betterproto.Message):
    """The response for GetBlockInfo."""

    hash: "BlockHash" = betterproto.message_field(1)
    """Hash of the block."""

    height: "AbsoluteBlockHeight" = betterproto.message_field(2)
    """Absolute height of the block, height 0 is the genesis block."""

    parent_block: "BlockHash" = betterproto.message_field(3)
    """
    The parent block hash. For a re-genesis block, this will be the terminal
    block of the previous chain. For the initial genesis block, this will be
    the hash of the block itself.
    """

    last_finalized_block: "BlockHash" = betterproto.message_field(4)
    """The last finalized block when this block was baked."""

    genesis_index: "GenesisIndex" = betterproto.message_field(5)
    """
    The genesis index for this block. This counts the number of protocol
    updates that have preceded this block, and defines the era of the block.
    """

    era_block_height: "BlockHeight" = betterproto.message_field(6)
    """
    The height of this block relative to the (re)genesis block of its era.
    """

    receive_time: "Timestamp" = betterproto.message_field(7)
    """The time the block was received."""

    arrive_time: "Timestamp" = betterproto.message_field(8)
    """The time the block was verified."""

    slot_number: Optional["Slot"] = betterproto.message_field(
        9, optional=True, group="_slot_number"
    )
    """
    The slot number in which the block was baked. Present in protocol versions
    1-5.
    """

    slot_time: "Timestamp" = betterproto.message_field(10)
    """The time of the slot in which the block was baked."""

    baker: Optional["BakerId"] = betterproto.message_field(
        11, optional=True, group="_baker"
    )
    """
    The baker id of account baking this block. Not provided for a genesis
    block.
    """

    finalized: bool = betterproto.bool_field(12)
    """Whether the block is finalized."""

    transaction_count: int = betterproto.uint32_field(13)
    """The number of transactions in the block."""

    transactions_energy_cost: "Energy" = betterproto.message_field(14)
    """The energy cost of the transactions in the block."""

    transactions_size: int = betterproto.uint32_field(15)
    """The total byte size of all transactions in the block."""

    state_hash: "StateHash" = betterproto.message_field(16)
    """The hash of the block state after this block."""

    protocol_version: "ProtocolVersion" = betterproto.enum_field(17)
    """Protocol version to which the block belongs."""

    round: Optional["Round"] = betterproto.message_field(
        18, optional=True, group="_round"
    )
    """Block round. Present from protocol version 6."""

    epoch: Optional["Epoch"] = betterproto.message_field(
        19, optional=True, group="_epoch"
    )
    """Block epoch. Present from protocol version 6."""


@dataclass(eq=False, repr=False)
class PoolInfoRequest(betterproto.Message):
    """Request for GetPoolInfo."""

    block_hash: "BlockHashInput" = betterproto.message_field(1)
    """Block in which to query the pool information."""

    baker: "BakerId" = betterproto.message_field(2)
    """The 'BakerId' of the pool owner."""


@dataclass(eq=False, repr=False)
class PoolPendingChange(betterproto.Message):
    """A pending change to a baker pool."""

    reduce: "PoolPendingChangeReduce" = betterproto.message_field(1, group="change")
    remove: "PoolPendingChangeRemove" = betterproto.message_field(2, group="change")


@dataclass(eq=False, repr=False)
class PoolPendingChangeReduce(betterproto.Message):
    """A reduction in baker equity capital is pending."""

    reduced_equity_capital: "Amount" = betterproto.message_field(1)
    """New baker equity capital."""

    effective_time: "Timestamp" = betterproto.message_field(2)
    """Timestamp when the change takes effect."""


@dataclass(eq=False, repr=False)
class PoolPendingChangeRemove(betterproto.Message):
    """Removal of the pool is pending."""

    effective_time: "Timestamp" = betterproto.message_field(1)
    """Timestamp when the change takes effect."""


@dataclass(eq=False, repr=False)
class PoolCurrentPaydayInfo(betterproto.Message):
    """Information about a baker pool in the current reward period."""

    blocks_baked: int = betterproto.uint64_field(1)
    """The number of blocks baked in the current reward period."""

    finalization_live: bool = betterproto.bool_field(2)
    """
    Whether the baker has contributed a finalization proof in the current
    reward period.
    """

    transaction_fees_earned: "Amount" = betterproto.message_field(3)
    """
    The transaction fees accruing to the pool in the current reward period.
    """

    effective_stake: "Amount" = betterproto.message_field(4)
    """The effective stake of the baker in the current reward period."""

    lottery_power: float = betterproto.double_field(5)
    """The lottery power of the baker in the current reward period."""

    baker_equity_capital: "Amount" = betterproto.message_field(6)
    """
    The effective equity capital of the baker for the current reward period.
    """

    delegated_capital: "Amount" = betterproto.message_field(7)
    """
    The effective delegated capital to the pool for the current reward period.
    """

    commission_rates: "CommissionRates" = betterproto.message_field(8)
    """The commission rates that apply for the current reward period."""

    is_primed_for_suspension: Optional[bool] = betterproto.bool_field(
        9, optional=True, group="_is_primed_for_suspension"
    )
    """
    A flag indicating whether the pool owner is primed for suspension. Absent
    if the protocol version does not support validator suspension.
    """

    missed_rounds: Optional[int] = betterproto.uint64_field(
        10, optional=True, group="_missed_rounds"
    )
    """
    The number of missed rounds in the current reward period. Absent if the
    protocol version does not support validator suspension.
    """


@dataclass(eq=False, repr=False)
class PoolInfoResponse(betterproto.Message):
    """
    Type for the response of GetPoolInfo. Contains information about a given
    pool at the end of a given block. From protocol version 7, pool removal has
    immediate effect, however, the pool may still be present for the current
    (and possibly next) reward period. In this case, the `current_payday_info`
    field will be set, but the `equity_capital`, `delegated_capital`,
    `delegated_capital_cap` and, `pool_info` fields will all be absent. The
    `equity_pending_change` field will also be absent, as stake changes are
    immediate.
    """

    baker: "BakerId" = betterproto.message_field(1)
    """The 'BakerId' of the pool owner."""

    address: "AccountAddress" = betterproto.message_field(2)
    """The account address of the pool owner."""

    equity_capital: Optional["Amount"] = betterproto.message_field(
        3, optional=True, group="_equity_capital"
    )
    """
    The equity capital provided by the pool owner. Absent if the pool is
    removed.
    """

    delegated_capital: Optional["Amount"] = betterproto.message_field(
        4, optional=True, group="_delegated_capital"
    )
    """
    The capital delegated to the pool by other accounts. Absent if the pool is
    removed.
    """

    delegated_capital_cap: Optional["Amount"] = betterproto.message_field(
        5, optional=True, group="_delegated_capital_cap"
    )
    """
    The maximum amount that may be delegated to the pool, accounting for
    leverage and stake limits. Absent if the pool is removed.
    """

    pool_info: Optional["BakerPoolInfo"] = betterproto.message_field(
        6, optional=True, group="_pool_info"
    )
    """
    The pool info associated with the pool: open status, metadata URL and
    commission rates. Absent if the pool is removed.
    """

    equity_pending_change: Optional["PoolPendingChange"] = betterproto.message_field(
        7, optional=True, group="_equity_pending_change"
    )
    """
    Any pending change to the equity capital. This is not used from protocol
    version 7 onwards, as stake changes are immediate.
    """

    current_payday_info: Optional["PoolCurrentPaydayInfo"] = betterproto.message_field(
        8, optional=True, group="_current_payday_info"
    )
    """Information of the pool in the current reward period."""

    all_pool_total_capital: "Amount" = betterproto.message_field(9)
    """Total capital staked across all pools, including passive delegation."""

    is_suspended: Optional[bool] = betterproto.bool_field(
        10, optional=True, group="_is_suspended"
    )
    """
    A flag indicating whether the pool owner is suspended. Absent if the
    protocol version does not support validator suspension or the pool is
    removed.
    """


@dataclass(eq=False, repr=False)
class PassiveDelegationInfo(betterproto.Message):
    """
    Type for the response of GetPassiveDelegationInfo. Contains information
    about passive delegators at the end of a given block.
    """

    delegated_capital: "Amount" = betterproto.message_field(1)
    """The total capital delegated passively."""

    commission_rates: "CommissionRates" = betterproto.message_field(2)
    """The passive delegation commission rates."""

    current_payday_transaction_fees_earned: "Amount" = betterproto.message_field(3)
    """
    The transaction fees accruing to the passive delegators in the current
    reward period.
    """

    current_payday_delegated_capital: "Amount" = betterproto.message_field(4)
    """
    The effective delegated capital of passive delegators for the current
    reward period.
    """

    all_pool_total_capital: "Amount" = betterproto.message_field(5)
    """Total capital staked across all pools, including passive delegation."""


@dataclass(eq=False, repr=False)
class BlocksAtHeightRequest(betterproto.Message):
    """Request for GetBlocksAtHeight."""

    absolute: "BlocksAtHeightRequestAbsolute" = betterproto.message_field(
        1, group="blocks_at_height"
    )
    relative: "BlocksAtHeightRequestRelative" = betterproto.message_field(
        2, group="blocks_at_height"
    )


@dataclass(eq=False, repr=False)
class BlocksAtHeightRequestAbsolute(betterproto.Message):
    """Request using an absolute block height."""

    height: "AbsoluteBlockHeight" = betterproto.message_field(1)
    """The absolute block height."""


@dataclass(eq=False, repr=False)
class BlocksAtHeightRequestRelative(betterproto.Message):
    """Request using a relative block height."""

    genesis_index: "GenesisIndex" = betterproto.message_field(1)
    """Genesis index to start from."""

    height: "BlockHeight" = betterproto.message_field(2)
    """Height starting from the genesis block at the genesis index."""

    restrict: bool = betterproto.bool_field(3)
    """
    Whether to return results only from the specified genesis index (`true`),
    or allow results from more recent genesis indices as well (`false`).
    """


@dataclass(eq=False, repr=False)
class BlocksAtHeightResponse(betterproto.Message):
    """Response for GetBlocksAtHeight."""

    blocks: List["BlockHash"] = betterproto.message_field(1)
    """Live blocks at the given height."""


@dataclass(eq=False, repr=False)
class TokenomicsInfo(betterproto.Message):
    """
    Type for the response of GetTokenomicsInfo. Contains information related to
    tokenomics at the end of a given block.
    """

    v0: "TokenomicsInfoV0" = betterproto.message_field(1, group="tokenomics")
    v1: "TokenomicsInfoV1" = betterproto.message_field(2, group="tokenomics")


@dataclass(eq=False, repr=False)
class TokenomicsInfoV0(betterproto.Message):
    """Version 0 tokenomics."""

    total_amount: "Amount" = betterproto.message_field(1)
    """The total CCD in existence."""

    total_encrypted_amount: "Amount" = betterproto.message_field(2)
    """The total CCD in encrypted balances."""

    baking_reward_account: "Amount" = betterproto.message_field(3)
    """The amount in the baking reward account."""

    finalization_reward_account: "Amount" = betterproto.message_field(4)
    """The amount in the finalization reward account."""

    gas_account: "Amount" = betterproto.message_field(5)
    """The amount in the GAS account."""

    protocol_version: "ProtocolVersion" = betterproto.enum_field(6)
    """The protocol version."""


@dataclass(eq=False, repr=False)
class TokenomicsInfoV1(betterproto.Message):
    """Version 1 tokenomics."""

    total_amount: "Amount" = betterproto.message_field(1)
    """The total CCD in existence."""

    total_encrypted_amount: "Amount" = betterproto.message_field(2)
    """The total CCD in encrypted balances."""

    baking_reward_account: "Amount" = betterproto.message_field(3)
    """The amount in the baking reward account."""

    finalization_reward_account: "Amount" = betterproto.message_field(4)
    """The amount in the finalization reward account."""

    gas_account: "Amount" = betterproto.message_field(5)
    """The amount in the GAS account."""

    foundation_transaction_rewards: "Amount" = betterproto.message_field(6)
    """
    The transaction reward fraction accruing to the foundation (to be paid at
    next payday).
    """

    next_payday_time: "Timestamp" = betterproto.message_field(7)
    """The time of the next payday."""

    next_payday_mint_rate: "MintRate" = betterproto.message_field(8)
    """
    The rate at which CCD will be minted (as a proportion of the total supply)
    at the next payday.
    """

    total_staked_capital: "Amount" = betterproto.message_field(9)
    """The total capital put up as stake by bakers and delegators."""

    protocol_version: "ProtocolVersion" = betterproto.enum_field(10)
    """The protocol version."""


@dataclass(eq=False, repr=False)
class InvokeInstanceRequest(betterproto.Message):
    """Request for InvokeInstance."""

    block_hash: "BlockHashInput" = betterproto.message_field(1)
    """
    Block to invoke the contract. The invocation will be at the end of the
    given block.
    """

    invoker: Optional["Address"] = betterproto.message_field(
        2, optional=True, group="_invoker"
    )
    """
    Invoker of the contract. If this is not supplied then the contract will be
    invoked by an account with address 0, no credentials and sufficient amount
    of CCD to cover the transfer amount. If given, the relevant address (either
    account or contract) must exist in the blockstate.
    """

    instance: "ContractAddress" = betterproto.message_field(3)
    """Address of the contract instance to invoke."""

    amount: "Amount" = betterproto.message_field(4)
    """Amount to invoke the smart contract instance with."""

    entrypoint: "ReceiveName" = betterproto.message_field(5)
    """The entrypoint of the smart contract instance to invoke."""

    parameter: "Parameter" = betterproto.message_field(6)
    """The parameter bytes to include in the invocation of the entrypoint."""

    energy: "Energy" = betterproto.message_field(7)
    """
    And what amount of energy to allow for execution. This cannot exceed
    `100_000_000_000`, but in practice it should be much less. The maximum
    block energy is typically in the range of a few million.
    """


@dataclass(eq=False, repr=False)
class InvokeInstanceResponse(betterproto.Message):
    """Response type for InvokeInstance."""

    success: "InvokeInstanceResponseSuccess" = betterproto.message_field(
        1, group="result"
    )
    failure: "InvokeInstanceResponseFailure" = betterproto.message_field(
        2, group="result"
    )


@dataclass(eq=False, repr=False)
class InvokeInstanceResponseFailure(betterproto.Message):
    """Contract execution failed."""

    return_value: Optional[bytes] = betterproto.bytes_field(
        1, optional=True, group="_return_value"
    )
    """
    If invoking a V0 contract this is not provided, otherwise it is potentially
    return value produced by the call unless the call failed with out of energy
    or runtime error. If the V1 contract terminated with a logic error then the
    return value is present.
    """

    used_energy: "Energy" = betterproto.message_field(2)
    """Energy used by the execution."""

    reason: "RejectReason" = betterproto.message_field(3)
    """Contract execution failed for the given reason."""


@dataclass(eq=False, repr=False)
class InvokeInstanceResponseSuccess(betterproto.Message):
    """Contract execution succeeded."""

    return_value: Optional[bytes] = betterproto.bytes_field(
        1, optional=True, group="_return_value"
    )
    """
    If invoking a V0 contract this is absent. Otherwise it is the return value
    produced by the contract.
    """

    used_energy: "Energy" = betterproto.message_field(2)
    """Energy used by the execution."""

    effects: List["ContractTraceElement"] = betterproto.message_field(3)
    """Effects produced by contract execution."""


@dataclass(eq=False, repr=False)
class GetPoolDelegatorsRequest(betterproto.Message):
    """Request for GetPoolDelegators and GetPoolDelegatorsRewardPeriod."""

    block_hash: "BlockHashInput" = betterproto.message_field(1)
    """Block in which to query the delegators."""

    baker: "BakerId" = betterproto.message_field(2)
    """The 'BakerId' of the pool owner."""


@dataclass(eq=False, repr=False)
class DelegatorInfo(betterproto.Message):
    """Stream item for GetPoolDelegators and GetPassiveDelegators."""

    account: "AccountAddress" = betterproto.message_field(1)
    """The delegator account address."""

    stake: "Amount" = betterproto.message_field(2)
    """The amount of stake currently staked to the pool."""

    pending_change: Optional["StakePendingChange"] = betterproto.message_field(
        3, optional=True, group="_pending_change"
    )
    """Pending change to the current stake of the delegator."""


@dataclass(eq=False, repr=False)
class DelegatorRewardPeriodInfo(betterproto.Message):
    """
    Stream item for GetPoolDelegatorsRewardPeriod and
    GetPassiveDelegatorsRewardPeriod.
    """

    account: "AccountAddress" = betterproto.message_field(1)
    """The delegator account address."""

    stake: "Amount" = betterproto.message_field(2)
    """The amount of stake currently staked to the pool."""


@dataclass(eq=False, repr=False)
class Branch(betterproto.Message):
    """Response type for GetBranches."""

    block_hash: "BlockHash" = betterproto.message_field(1)
    """The hash of the block."""

    children: List["Branch"] = betterproto.message_field(2)
    """Further blocks branching of this block."""


@dataclass(eq=False, repr=False)
class LeadershipElectionNonce(betterproto.Message):
    """
    The leadership election nonce is an unpredictable value updated once an
    epoch to make sure that bakers cannot predict too far in the future when
    they will win the right to bake blocks.
    """

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class ElectionInfo(betterproto.Message):
    """
    Response type for GetElectionInfo. Contains information related to baker
    election for a perticular block.
    """

    election_difficulty: Optional["ElectionDifficulty"] = betterproto.message_field(
        1, optional=True, group="_election_difficulty"
    )
    """
    Baking lottery election difficulty. Present only in protocol versions 1-5.
    """

    election_nonce: "LeadershipElectionNonce" = betterproto.message_field(2)
    """Current leadership election nonce for the lottery."""

    baker_election_info: List["ElectionInfoBaker"] = betterproto.message_field(3)
    """List of the currently eligible bakers."""


@dataclass(eq=False, repr=False)
class ElectionInfoBaker(betterproto.Message):
    baker: "BakerId" = betterproto.message_field(1)
    """The ID of the baker."""

    account: "AccountAddress" = betterproto.message_field(2)
    """The account address of the baker."""

    lottery_power: float = betterproto.double_field(3)
    """
    The lottery power of the baker, rounded to the nearest representable
    "double".
    """


@dataclass(eq=False, repr=False)
class BlockSpecialEvent(betterproto.Message):
    """
    A protocol generated event that is not directly caused by a transaction.
    This includes minting new CCD, rewarding different bakers and delegators,
    etc.
    """

    baking_rewards: "BlockSpecialEventBakingRewards" = betterproto.message_field(
        1, group="event"
    )
    mint: "BlockSpecialEventMint" = betterproto.message_field(2, group="event")
    finalization_rewards: "BlockSpecialEventFinalizationRewards" = (
        betterproto.message_field(3, group="event")
    )
    block_reward: "BlockSpecialEventBlockReward" = betterproto.message_field(
        4, group="event"
    )
    payday_foundation_reward: "BlockSpecialEventPaydayFoundationReward" = (
        betterproto.message_field(5, group="event")
    )
    payday_account_reward: "BlockSpecialEventPaydayAccountReward" = (
        betterproto.message_field(6, group="event")
    )
    block_accrue_reward: "BlockSpecialEventBlockAccrueReward" = (
        betterproto.message_field(7, group="event")
    )
    payday_pool_reward: "BlockSpecialEventPaydayPoolReward" = betterproto.message_field(
        8, group="event"
    )
    validator_suspended: "BlockSpecialEventValidatorSuspended" = (
        betterproto.message_field(9, group="event")
    )
    validator_primed_for_suspension: "BlockSpecialEventValidatorPrimedForSuspension" = (
        betterproto.message_field(10, group="event")
    )


@dataclass(eq=False, repr=False)
class BlockSpecialEventAccountAmounts(betterproto.Message):
    """A representation of a mapping from an account address to an amount."""

    entries: List["BlockSpecialEventAccountAmountsEntry"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class BlockSpecialEventAccountAmountsEntry(betterproto.Message):
    """The entry for the map."""

    account: "AccountAddress" = betterproto.message_field(1)
    """The key type"""

    amount: "Amount" = betterproto.message_field(2)
    """The value type"""


@dataclass(eq=False, repr=False)
class BlockSpecialEventBakingRewards(betterproto.Message):
    """
    Payment to each baker of a previous epoch, in proportion to the number of
    blocks they contributed.
    """

    baker_rewards: "BlockSpecialEventAccountAmounts" = betterproto.message_field(1)
    """The amount awarded to each baker."""

    remainder: "Amount" = betterproto.message_field(2)
    """The remaining balance of the baker reward account."""


@dataclass(eq=False, repr=False)
class BlockSpecialEventMint(betterproto.Message):
    """Minting of new CCD."""

    mint_baking_reward: "Amount" = betterproto.message_field(1)
    """The amount allocated to the banking reward account."""

    mint_finalization_reward: "Amount" = betterproto.message_field(2)
    """The amount allocated to the finalization reward account."""

    mint_platform_development_charge: "Amount" = betterproto.message_field(3)
    """The amount allocated as the platform development charge."""

    foundation_account: "AccountAddress" = betterproto.message_field(4)
    """The account to which the platform development charge is paid."""


@dataclass(eq=False, repr=False)
class BlockSpecialEventFinalizationRewards(betterproto.Message):
    """
    Payment to each finalizer on inclusion of a finalization record in a block.
    """

    finalization_rewards: "BlockSpecialEventAccountAmounts" = betterproto.message_field(
        1
    )
    """The amount awarded to each finalizer."""

    remainder: "Amount" = betterproto.message_field(2)
    """The remaining balance of the finalization reward account."""


@dataclass(eq=False, repr=False)
class BlockSpecialEventBlockReward(betterproto.Message):
    """
    Disbursement of fees from a block between the GAS account, the baker, and
    the foundation. It should always be that: ```transaction_fees +
    old_gas_account = new_gas_account + baker_reward + foundation_charge```
    """

    transaction_fees: "Amount" = betterproto.message_field(1)
    """The total fees paid for transactions in the block."""

    old_gas_account: "Amount" = betterproto.message_field(2)
    """The old balance of the GAS account."""

    new_gas_account: "Amount" = betterproto.message_field(3)
    """The new balance of the GAS account."""

    baker_reward: "Amount" = betterproto.message_field(4)
    """The amount awarded to the baker."""

    foundation_charge: "Amount" = betterproto.message_field(5)
    """The amount awarded to the foundation."""

    baker: "AccountAddress" = betterproto.message_field(6)
    """The baker of the block, who receives the award."""

    foundation_account: "AccountAddress" = betterproto.message_field(7)
    """The foundation account."""


@dataclass(eq=False, repr=False)
class BlockSpecialEventPaydayFoundationReward(betterproto.Message):
    """Foundation tax."""

    foundation_account: "AccountAddress" = betterproto.message_field(1)
    """The account that got rewarded."""

    development_charge: "Amount" = betterproto.message_field(2)
    """The transaction fee reward at payday to the account."""


@dataclass(eq=False, repr=False)
class BlockSpecialEventPaydayAccountReward(betterproto.Message):
    """Reward payment to the given account."""

    account: "AccountAddress" = betterproto.message_field(1)
    """The account that got rewarded."""

    transaction_fees: "Amount" = betterproto.message_field(2)
    """The transaction fee reward at payday to the account."""

    baker_reward: "Amount" = betterproto.message_field(3)
    """The baking reward at payday to the account."""

    finalization_reward: "Amount" = betterproto.message_field(4)
    """The finalization reward at payday to the account."""


@dataclass(eq=False, repr=False)
class BlockSpecialEventBlockAccrueReward(betterproto.Message):
    """Amounts accrued to accounts for each baked block."""

    transaction_fees: "Amount" = betterproto.message_field(1)
    """The total fees paid for transactions in the block."""

    old_gas_account: "Amount" = betterproto.message_field(2)
    """The old balance of the GAS account."""

    new_gas_account: "Amount" = betterproto.message_field(3)
    """The new balance of the GAS account."""

    baker_reward: "Amount" = betterproto.message_field(4)
    """The amount awarded to the baker."""

    passive_reward: "Amount" = betterproto.message_field(5)
    """The amount awarded to the passive delegators."""

    foundation_charge: "Amount" = betterproto.message_field(6)
    """The amount awarded to the foundation."""

    baker: "BakerId" = betterproto.message_field(7)
    """The baker of the block, who will receive the award."""


@dataclass(eq=False, repr=False)
class BlockSpecialEventPaydayPoolReward(betterproto.Message):
    """Payment distributed to a pool or passive delegators."""

    pool_owner: Optional["BakerId"] = betterproto.message_field(
        1, optional=True, group="_pool_owner"
    )
    """The pool owner (passive delegators when not present)."""

    transaction_fees: "Amount" = betterproto.message_field(2)
    """Accrued transaction fees for pool."""

    baker_reward: "Amount" = betterproto.message_field(3)
    """Accrued baking rewards for pool."""

    finalization_reward: "Amount" = betterproto.message_field(4)
    """Accrued finalization rewards for pool."""


@dataclass(eq=False, repr=False)
class BlockSpecialEventValidatorSuspended(betterproto.Message):
    """
    The id of a validator that got suspended due to too many missed rounds.
    """

    baker_id: "BakerId" = betterproto.message_field(1)
    """The id of the suspended validator."""

    account: "AccountAddress" = betterproto.message_field(2)
    """The account of the suspended validator."""


@dataclass(eq=False, repr=False)
class BlockSpecialEventValidatorPrimedForSuspension(betterproto.Message):
    """
    The id of a validator that is primed for suspension at the next snapshot
    epoch due to too many missed rounds.
    """

    baker_id: "BakerId" = betterproto.message_field(1)
    """The id of the primed validator."""

    account: "AccountAddress" = betterproto.message_field(2)
    """The account of the primed validator."""


@dataclass(eq=False, repr=False)
class PendingUpdate(betterproto.Message):
    """A pending update."""

    effective_time: "TransactionTime" = betterproto.message_field(1)
    """The effective time of the update."""

    root_keys: "HigherLevelKeys" = betterproto.message_field(2, group="effect")
    """Updates to the root keys."""

    level1_keys: "HigherLevelKeys" = betterproto.message_field(3, group="effect")
    """Updates to the level 1 keys."""

    level2_keys_cpv_0: "AuthorizationsV0" = betterproto.message_field(4, group="effect")
    """Updates to the level 2 keys."""

    level2_keys_cpv_1: "AuthorizationsV1" = betterproto.message_field(5, group="effect")
    """Updates to the level 2 keys."""

    protocol: "ProtocolUpdate" = betterproto.message_field(6, group="effect")
    """Protocol updates."""

    election_difficulty: "ElectionDifficulty" = betterproto.message_field(
        7, group="effect"
    )
    """Updates to the election difficulty parameter."""

    euro_per_energy: "ExchangeRate" = betterproto.message_field(8, group="effect")
    """Updates to the euro:energy exchange rate."""

    micro_ccd_per_euro: "ExchangeRate" = betterproto.message_field(9, group="effect")
    """Updates to the CCD:EUR exchange rate."""

    foundation_account: "AccountAddress" = betterproto.message_field(10, group="effect")
    """Updates to the foundation account."""

    mint_distribution_cpv_0: "MintDistributionCpv0" = betterproto.message_field(
        11, group="effect"
    )
    """
    Updates to the mint distribution. Is only relevant prior to protocol
    version 4.
    """

    mint_distribution_cpv_1: "MintDistributionCpv1" = betterproto.message_field(
        12, group="effect"
    )
    """The mint distribution was updated. Introduced in protocol version 4."""

    transaction_fee_distribution: "TransactionFeeDistribution" = (
        betterproto.message_field(13, group="effect")
    )
    """Updates to the transaction fee distribution."""

    gas_rewards: "GasRewards" = betterproto.message_field(14, group="effect")
    """Updates to the GAS rewards."""

    pool_parameters_cpv_0: "BakerStakeThreshold" = betterproto.message_field(
        15, group="effect"
    )
    """
    Updates baker stake threshold. Is only relevant prior to protocol version
    4.
    """

    pool_parameters_cpv_1: "PoolParametersCpv1" = betterproto.message_field(
        16, group="effect"
    )
    """Updates pool parameters. Introduced in protocol version 4."""

    add_anonymity_revoker: "ArInfo" = betterproto.message_field(17, group="effect")
    """Adds a new anonymity revoker."""

    add_identity_provider: "IpInfo" = betterproto.message_field(18, group="effect")
    """Adds a new identity provider."""

    cooldown_parameters: "CooldownParametersCpv1" = betterproto.message_field(
        19, group="effect"
    )
    """
    Updates to cooldown parameters for chain parameters version 1 introduced in
    protocol version 4.
    """

    time_parameters: "TimeParametersCpv1" = betterproto.message_field(
        20, group="effect"
    )
    """
    Updates to time parameters for chain parameters version 1 introduced in
    protocol version 4.
    """

    gas_rewards_cpv_2: "GasRewardsCpv2" = betterproto.message_field(21, group="effect")
    """
    Updates to the GAS rewards effective from protocol version 6 (chain
    parameters version 2).
    """

    timeout_parameters: "TimeoutParameters" = betterproto.message_field(
        22, group="effect"
    )
    """Updates to the consensus timeouts for chain parameters version 2."""

    min_block_time: "Duration" = betterproto.message_field(23, group="effect")
    """
    Updates to the the minimum time between blocks for chain parameters version
    2.
    """

    block_energy_limit: "Energy" = betterproto.message_field(24, group="effect")
    """Updates to the block energy limit for chain parameters version 2."""

    finalization_committee_parameters: "FinalizationCommitteeParameters" = (
        betterproto.message_field(25, group="effect")
    )
    """
    Updates to the finalization committee for for chain parameters version 2.
    """

    validator_score_parameters: "ValidatorScoreParameters" = betterproto.message_field(
        26, group="effect"
    )
    """
    Updates to the validator score parameters for chain parameters version 3.
    """


@dataclass(eq=False, repr=False)
class NextUpdateSequenceNumbers(betterproto.Message):
    """The response for `GetNextUpdateSequenceNumbers`."""

    root_keys: "SequenceNumber" = betterproto.message_field(1)
    """Updates to the root keys."""

    level1_keys: "SequenceNumber" = betterproto.message_field(2)
    """Updates to the level 1 keys."""

    level2_keys: "SequenceNumber" = betterproto.message_field(3)
    """Updates to the level 2 keys."""

    protocol: "SequenceNumber" = betterproto.message_field(4)
    """Protocol updates."""

    election_difficulty: "SequenceNumber" = betterproto.message_field(5)
    """Updates to the election difficulty parameter."""

    euro_per_energy: "SequenceNumber" = betterproto.message_field(6)
    """Updates to the euro:energy exchange rate."""

    micro_ccd_per_euro: "SequenceNumber" = betterproto.message_field(7)
    """Updates to the CCD:EUR exchange rate."""

    foundation_account: "SequenceNumber" = betterproto.message_field(8)
    """Updates to the foundation account."""

    mint_distribution: "SequenceNumber" = betterproto.message_field(9)
    """Updates to the mint distribution."""

    transaction_fee_distribution: "SequenceNumber" = betterproto.message_field(10)
    """Updates to the transaction fee distribution."""

    gas_rewards: "SequenceNumber" = betterproto.message_field(11)
    """Updates to the GAS rewards."""

    pool_parameters: "SequenceNumber" = betterproto.message_field(12)
    """Updates pool parameters."""

    add_anonymity_revoker: "SequenceNumber" = betterproto.message_field(13)
    """Adds a new anonymity revoker."""

    add_identity_provider: "SequenceNumber" = betterproto.message_field(14)
    """Adds a new identity provider."""

    cooldown_parameters: "SequenceNumber" = betterproto.message_field(15)
    """
    Updates to cooldown parameters for chain parameters version 1 introduced in
    protocol version 4.
    """

    time_parameters: "SequenceNumber" = betterproto.message_field(16)
    """
    Updates to time parameters for chain parameters version 1 introduced in
    protocol version 4.
    """

    timeout_parameters: "SequenceNumber" = betterproto.message_field(17)
    """Updates to the timeout parameters"""

    min_block_time: "SequenceNumber" = betterproto.message_field(18)
    """
    Updates to the the minimum time between blocks for chain parameters version
    2.
    """

    block_energy_limit: "SequenceNumber" = betterproto.message_field(19)
    """Updates to the block energy limit for chain parameters version 2."""

    finalization_committee_parameters: "SequenceNumber" = betterproto.message_field(20)
    """Updates to the finalization committee parameters"""

    validator_score_parameters: "SequenceNumber" = betterproto.message_field(21)
    """
    Updates to the validator score parameters for chain parameters version 3.
    """


@dataclass(eq=False, repr=False)
class IpAddress(betterproto.Message):
    """A request to send a new block item to the chain. An IP address"""

    value: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class Port(betterproto.Message):
    """
    A port Valid port numbers are expected thus the value is expected to be in
    the range (0..u16::MAX).
    """

    value: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class IpSocketAddress(betterproto.Message):
    """A socket address consisting of an IP + port."""

    ip: "IpAddress" = betterproto.message_field(1)
    port: "Port" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class PeerId(betterproto.Message):
    """
    A peer id An identifier that the peer wants to be be recoknized by. The
    underlying value is simply a u64. Note. There is no authenticity of the
    peer id and as such it is only used for logging purposes.
    """

    value: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class BannedPeer(betterproto.Message):
    """A banned peer"""

    ip_address: "IpAddress" = betterproto.message_field(1)
    """The IP address of the banned peer."""


@dataclass(eq=False, repr=False)
class BannedPeers(betterproto.Message):
    """The banned peers given by their IP addresses."""

    peers: List["BannedPeer"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class PeerToBan(betterproto.Message):
    """
    A peer to ban specified by its IP. Note. This will ban all peers located
    behind the specified IP even though they are using different ports.
    """

    ip_address: "IpAddress" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class DumpRequest(betterproto.Message):
    """Request to enable dumping of network packages."""

    file: str = betterproto.string_field(1)
    """Which file to dump the packages into. Requires a valid path."""

    raw: bool = betterproto.bool_field(2)
    """Whether the node should dump raw packages."""


@dataclass(eq=False, repr=False)
class PeersInfo(betterproto.Message):
    """Peers and their associated network related statistics"""

    peers: List["PeersInfoPeer"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class PeersInfoPeer(betterproto.Message):
    """A peer that the node is connected to."""

    peer_id: "PeerId" = betterproto.message_field(1)
    """The identifier of the peer that it wishes to be identified by."""

    socket_address: "IpSocketAddress" = betterproto.message_field(2)
    """The port of the peer."""

    network_stats: "PeersInfoPeerNetworkStats" = betterproto.message_field(3)
    """Network related statistics for the peer."""

    bootstrapper: "Empty" = betterproto.message_field(4, group="consensus_info")
    """
    The peer is of type `Bootstrapper` is not participating in consensus and
    thus has no catchup status.
    """

    node_catchup_status: "PeersInfoPeerCatchupStatus" = betterproto.enum_field(
        5, group="consensus_info"
    )
    """The peer is a regular node and have an associated catchup status."""


@dataclass(eq=False, repr=False)
class PeersInfoPeerNetworkStats(betterproto.Message):
    """Network statistics for the peer"""

    packets_sent: int = betterproto.uint64_field(2)
    """
    The number of messages sent to the peer. Packets are blocks, transactions,
    catchup messages, finalization records and network messages such as pings
    and peer requests.
    """

    packets_received: int = betterproto.uint64_field(3)
    """
    The number of messages received from the peer. Packets are blocks,
    transactions, catchup messages, finalization records and network messages
    such as pings and peer requests.
    """

    latency: int = betterproto.uint64_field(4)
    """The connection latency (i.e., ping time) in milliseconds."""


@dataclass(eq=False, repr=False)
class NodeInfo(betterproto.Message):
    """
    Node info response Contains various information of the enquired node.
    """

    peer_version: str = betterproto.string_field(1)
    """The version of the node."""

    local_time: "Timestamp" = betterproto.message_field(3)
    """local time of the node."""

    peer_uptime: "Duration" = betterproto.message_field(4)
    """Number of milliseconds that the node has been alive."""

    network_info: "NodeInfoNetworkInfo" = betterproto.message_field(5)
    """Information related to the p2p protocol."""

    bootstrapper: "Empty" = betterproto.message_field(6, group="details")
    """The node is a bootstrapper and is not running consensus."""

    node: "NodeInfoNode" = betterproto.message_field(7, group="details")
    """The node is a regular node and runs the consensus protocol."""


@dataclass(eq=False, repr=False)
class NodeInfoNetworkInfo(betterproto.Message):
    """Network related information of the node."""

    node_id: "PeerId" = betterproto.message_field(1)
    """The node id."""

    peer_total_sent: int = betterproto.uint64_field(2)
    """Total number of packets sent by the node."""

    peer_total_received: int = betterproto.uint64_field(3)
    """Total number of packets received by the node."""

    avg_bps_in: int = betterproto.uint64_field(4)
    """Average outbound throughput in bytes per second."""

    avg_bps_out: int = betterproto.uint64_field(5)
    """Average inbound throughput in bytes per second."""


@dataclass(eq=False, repr=False)
class NodeInfoBakerConsensusInfo(betterproto.Message):
    """Consensus info for a node configured with baker keys."""

    baker_id: "BakerId" = betterproto.message_field(1)
    passive_committee_info: "NodeInfoBakerConsensusInfoPassiveCommitteeInfo" = (
        betterproto.enum_field(2, group="status")
    )
    """The node is currently not baking."""

    active_baker_committee_info: (
        "NodeInfoBakerConsensusInfoActiveBakerCommitteeInfo"
    ) = betterproto.message_field(3, group="status")
    """
    The node is configured with baker keys and is member of the baking
    committee.
    """

    active_finalizer_committee_info: (
        "NodeInfoBakerConsensusInfoActiveFinalizerCommitteeInfo"
    ) = betterproto.message_field(4, group="status")
    """
    The node is configured with baker keys and is member of the baking and
    finalization committees.
    """


@dataclass(eq=False, repr=False)
class NodeInfoBakerConsensusInfoActiveBakerCommitteeInfo(betterproto.Message):
    """
    Tagging message type for a node that is configured with baker keys and
    active in the current baking committee
    """

    pass


@dataclass(eq=False, repr=False)
class NodeInfoBakerConsensusInfoActiveFinalizerCommitteeInfo(betterproto.Message):
    """
    Tagging message type for a node that is configured with baker keys and
    active in the current finalizer committee (and also baking committee).
    """

    pass


@dataclass(eq=False, repr=False)
class NodeInfoNode(betterproto.Message):
    """The node is a regular node."""

    not_running: "Empty" = betterproto.message_field(1, group="consensus_status")
    """
    The node is not running consensus. This is the case only when the node is
    not supporting the protocol on the chain. The node does not process blocks.
    """

    passive: "Empty" = betterproto.message_field(2, group="consensus_status")
    """
    Consensus info for a node that is not configured with baker keys. The node
    is only processing blocks and relaying blocks and transactions and
    responding to catchup messages.
    """

    active: "NodeInfoBakerConsensusInfo" = betterproto.message_field(
        3, group="consensus_status"
    )
    """
    The node is configured with baker credentials and consensus is running.
    """


@dataclass(eq=False, repr=False)
class SendBlockItemRequest(betterproto.Message):
    account_transaction: "AccountTransaction" = betterproto.message_field(
        1, group="block_item"
    )
    """
    Account transactions are messages which are signed and paid for by an
    account.
    """

    credential_deployment: "CredentialDeployment" = betterproto.message_field(
        2, group="block_item"
    )
    """
    Credential deployments create new accounts. They are not paid for directly
    by the sender. Instead, bakers are rewarded by the protocol for including
    them.
    """

    update_instruction: "UpdateInstruction" = betterproto.message_field(
        3, group="block_item"
    )
    """
    Update instructions are messages which can update the chain parameters.
    Including which keys are allowed to make future update instructions.
    """


@dataclass(eq=False, repr=False)
class CredentialDeployment(betterproto.Message):
    """
    Credential deployments create new accounts. They are not paid for directly
    by the sender. Instead, bakers are rewarded by the protocol for including
    them.
    """

    message_expiry: "TransactionTime" = betterproto.message_field(1)
    raw_payload: bytes = betterproto.bytes_field(2, group="payload")
    """
    A raw payload, which is just the encoded payload. A typed variant might be
    added in the future.
    """


@dataclass(eq=False, repr=False)
class Signature(betterproto.Message):
    """
    A single signature. Used when sending block items to a node with
    `SendBlockItem`.
    """

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class SignatureMap(betterproto.Message):
    """
    A signature on an update instruction. The type `UpdateKeysIndex` is not
    used directly, as messages cannot be keys in maps.
    """

    signatures: Dict[int, "Signature"] = betterproto.map_field(
        1, betterproto.TYPE_UINT32, betterproto.TYPE_MESSAGE
    )


@dataclass(eq=False, repr=False)
class AccountSignatureMap(betterproto.Message):
    """
    Wrapper for a map from indexes to signatures. Needed because protobuf
    doesn't allow nested maps directly. The keys in the SignatureMap must not
    exceed 2^8.
    """

    signatures: Dict[int, "Signature"] = betterproto.map_field(
        1, betterproto.TYPE_UINT32, betterproto.TYPE_MESSAGE
    )


@dataclass(eq=False, repr=False)
class AccountTransactionSignature(betterproto.Message):
    signatures: Dict[int, "AccountSignatureMap"] = betterproto.map_field(
        1, betterproto.TYPE_UINT32, betterproto.TYPE_MESSAGE
    )
    """
    A map from `CredentialIndex` to `SignatureMap`s. The type `CredentialIndex`
    is not used directly, as messages cannot be keys in maps. The map cannot
    contain more than 2^8 signatures.
    """


@dataclass(eq=False, repr=False)
class AccountTransactionHeader(betterproto.Message):
    """
    Header of an account transaction that contains basic data to check whether
    the sender and the transaction are valid. The header is shared by all
    transaction types.
    """

    sender: "AccountAddress" = betterproto.message_field(1)
    """Sender of the transaction."""

    sequence_number: "SequenceNumber" = betterproto.message_field(2)
    """Sequence number of the transaction."""

    energy_amount: "Energy" = betterproto.message_field(3)
    """Maximum amount of energy the transaction can take to execute."""

    expiry: "TransactionTime" = betterproto.message_field(5)
    """Latest time the transaction can included in a block."""


@dataclass(eq=False, repr=False)
class InitContractPayload(betterproto.Message):
    """Data required to initialize a new contract instance."""

    amount: "Amount" = betterproto.message_field(1)
    """Amount of CCD to send to the instance."""

    module_ref: "ModuleRef" = betterproto.message_field(2)
    """Reference to the module from which the instance will be created."""

    init_name: "InitName" = betterproto.message_field(3)
    """
    Name of the contract to initialize. This is expected to be in the format
    `init_name`.
    """

    parameter: "Parameter" = betterproto.message_field(4)
    """Parameter to call the `init` of the contract with."""


@dataclass(eq=False, repr=False)
class UpdateContractPayload(betterproto.Message):
    """Data required to update a contract instance."""

    amount: "Amount" = betterproto.message_field(1)
    """Amount of CCD to send to the instance."""

    address: "ContractAddress" = betterproto.message_field(2)
    """Address of the instance to update."""

    receive_name: "ReceiveName" = betterproto.message_field(3)
    """
    Name of the entrypoint to call to update the instance. This is expected to
    be in the format `contractName.entrypointName`.
    """

    parameter: "Parameter" = betterproto.message_field(4)
    """Parameter to pass to the entrypoint."""


@dataclass(eq=False, repr=False)
class TransferPayload(betterproto.Message):
    """Payload of a transfer between two accounts."""

    amount: "Amount" = betterproto.message_field(1)
    """Amount of CCD to send."""

    receiver: "AccountAddress" = betterproto.message_field(2)
    """Receiver address."""


@dataclass(eq=False, repr=False)
class TransferWithMemoPayload(betterproto.Message):
    """Payload of a transfer between two accounts with a memo."""

    amount: "Amount" = betterproto.message_field(1)
    """Amount of CCD to send."""

    receiver: "AccountAddress" = betterproto.message_field(2)
    """Receiver address."""

    memo: "Memo" = betterproto.message_field(3)
    """Memo to include with the transfer."""


@dataclass(eq=False, repr=False)
class AccountTransactionPayload(betterproto.Message):
    """The payload for an account transaction."""

    raw_payload: bytes = betterproto.bytes_field(1, group="payload")
    """
    A pre-serialized payload in the binary serialization format defined by the
    protocol.
    """

    deploy_module: "VersionedModuleSource" = betterproto.message_field(
        2, group="payload"
    )
    """A transfer between two accounts. With an optional memo."""

    init_contract: "InitContractPayload" = betterproto.message_field(3, group="payload")
    update_contract: "UpdateContractPayload" = betterproto.message_field(
        4, group="payload"
    )
    transfer: "TransferPayload" = betterproto.message_field(5, group="payload")
    transfer_with_memo: "TransferWithMemoPayload" = betterproto.message_field(
        6, group="payload"
    )
    register_data: "RegisteredData" = betterproto.message_field(7, group="payload")


@dataclass(eq=False, repr=False)
class PreAccountTransaction(betterproto.Message):
    """
    An unsigned account transaction. This is used with the
    `GetTransactionSignHash` endpoint to obtain the message to sign.
    """

    header: "AccountTransactionHeader" = betterproto.message_field(1)
    payload: "AccountTransactionPayload" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class AccountTransaction(betterproto.Message):
    """
    Account transactions are messages which are signed and paid for by the
    sender account.
    """

    signature: "AccountTransactionSignature" = betterproto.message_field(1)
    header: "AccountTransactionHeader" = betterproto.message_field(2)
    payload: "AccountTransactionPayload" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class UpdateInstructionHeader(betterproto.Message):
    sequence_number: "UpdateSequenceNumber" = betterproto.message_field(1)
    effective_time: "TransactionTime" = betterproto.message_field(2)
    timeout: "TransactionTime" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class UpdateInstructionPayload(betterproto.Message):
    """The payload for an UpdateInstruction."""

    raw_payload: bytes = betterproto.bytes_field(3, group="payload")
    """
    A raw payload encoded according to the format defined by the protocol.
    """


@dataclass(eq=False, repr=False)
class UpdateInstruction(betterproto.Message):
    signatures: "SignatureMap" = betterproto.message_field(1)
    """
    A map from `UpdateKeysIndex` to `Signature`. Keys must not exceed 2^16.
    """

    header: "UpdateInstructionHeader" = betterproto.message_field(2)
    payload: "UpdateInstructionPayload" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class AccountTransactionSignHash(betterproto.Message):
    """
    Signature on an account transaction is defined to be the signature on the
    hash of the `PreAccountTransaction`.
    """

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class CredentialsPerBlockLimit(betterproto.Message):
    """
    The number of credential deployments allowed in a block. This in effect
    determines the number of accounts that can be created in a block.
    """

    value: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class ChainParametersV0(betterproto.Message):
    """Updatable chain parameters that apply to protocol versions 1-3."""

    election_difficulty: "ElectionDifficulty" = betterproto.message_field(1)
    """Election difficulty for consensus lottery."""

    euro_per_energy: "ExchangeRate" = betterproto.message_field(2)
    """Euro per energy exchange rate."""

    micro_ccd_per_euro: "ExchangeRate" = betterproto.message_field(3)
    """Micro CCD per euro exchange rate."""

    baker_cooldown_epochs: "Epoch" = betterproto.message_field(4)
    """
    Extra number of epochs before reduction in stake, or baker deregistration
    is completed.
    """

    account_creation_limit: "CredentialsPerBlockLimit" = betterproto.message_field(5)
    """The limit for the number of account creations in a block."""

    mint_distribution: "MintDistributionCpv0" = betterproto.message_field(6)
    """Current mint distribution"""

    transaction_fee_distribution: "TransactionFeeDistribution" = (
        betterproto.message_field(7)
    )
    """Current transaction fee distribution."""

    gas_rewards: "GasRewards" = betterproto.message_field(8)
    """Current gas reward parameters."""

    foundation_account: "AccountAddress" = betterproto.message_field(9)
    """The foundation account."""

    minimum_threshold_for_baking: "Amount" = betterproto.message_field(10)
    """Minimum threshold for becoming a baker."""

    root_keys: "HigherLevelKeys" = betterproto.message_field(11)
    """Keys allowed to do root updates."""

    level1_keys: "HigherLevelKeys" = betterproto.message_field(12)
    """Keys allowed to do level1 updates;"""

    level2_keys: "AuthorizationsV0" = betterproto.message_field(13)
    """Keys allowed to do parameter updates."""


@dataclass(eq=False, repr=False)
class ChainParametersV1(betterproto.Message):
    """Updatable chain parameters that apply to protocol versions 4-5."""

    election_difficulty: "ElectionDifficulty" = betterproto.message_field(1)
    """Election difficulty for consensus lottery."""

    euro_per_energy: "ExchangeRate" = betterproto.message_field(2)
    """Euro per energy exchange rate."""

    micro_ccd_per_euro: "ExchangeRate" = betterproto.message_field(3)
    """Micro CCD per euro exchange rate."""

    cooldown_parameters: "CooldownParametersCpv1" = betterproto.message_field(4)
    """
    Extra number of epochs before reduction in stake, or baker deregistration
    is completed.
    """

    time_parameters: "TimeParametersCpv1" = betterproto.message_field(5)
    """
    Current time parameters. The time parameters indicates the mint rate and
    the reward period length, i.e. the time between paydays.
    """

    account_creation_limit: "CredentialsPerBlockLimit" = betterproto.message_field(6)
    """The limit for the number of account creations in a block."""

    mint_distribution: "MintDistributionCpv1" = betterproto.message_field(7)
    """Current mint distribution"""

    transaction_fee_distribution: "TransactionFeeDistribution" = (
        betterproto.message_field(8)
    )
    """Current transaction fee distribution."""

    gas_rewards: "GasRewards" = betterproto.message_field(9)
    """Current gas reward parameters."""

    foundation_account: "AccountAddress" = betterproto.message_field(10)
    """The foundation account."""

    pool_parameters: "PoolParametersCpv1" = betterproto.message_field(11)
    """Parameters governing baking pools and their commissions."""

    root_keys: "HigherLevelKeys" = betterproto.message_field(12)
    """Keys allowed to do root updates."""

    level1_keys: "HigherLevelKeys" = betterproto.message_field(13)
    """Keys allowed to do level1 updates;"""

    level2_keys: "AuthorizationsV1" = betterproto.message_field(14)
    """Keys allowed to do parameter updates."""


@dataclass(eq=False, repr=False)
class ChainParametersV2(betterproto.Message):
    """Updatable chain parameters that apply to protocol versions 6."""

    consensus_parameters: "ConsensusParametersV1" = betterproto.message_field(1)
    """Consensus parameters."""

    euro_per_energy: "ExchangeRate" = betterproto.message_field(2)
    """Euro per energy exchange rate."""

    micro_ccd_per_euro: "ExchangeRate" = betterproto.message_field(3)
    """Micro CCD per euro exchange rate."""

    cooldown_parameters: "CooldownParametersCpv1" = betterproto.message_field(4)
    """
    Extra number of epochs before reduction in stake, or baker deregistration
    is completed.
    """

    time_parameters: "TimeParametersCpv1" = betterproto.message_field(5)
    """
    Current time parameters. The time parameters indicates the mint rate and
    the reward period length, i.e. the time between paydays.
    """

    account_creation_limit: "CredentialsPerBlockLimit" = betterproto.message_field(6)
    """The limit for the number of account creations in a block."""

    mint_distribution: "MintDistributionCpv1" = betterproto.message_field(7)
    """Current mint distribution"""

    transaction_fee_distribution: "TransactionFeeDistribution" = (
        betterproto.message_field(8)
    )
    """Current transaction fee distribution."""

    gas_rewards: "GasRewardsCpv2" = betterproto.message_field(9)
    """Current gas reward parameters."""

    foundation_account: "AccountAddress" = betterproto.message_field(10)
    """The foundation account."""

    pool_parameters: "PoolParametersCpv1" = betterproto.message_field(11)
    """Parameters governing baking pools and their commissions."""

    root_keys: "HigherLevelKeys" = betterproto.message_field(12)
    """Keys allowed to do root updates."""

    level1_keys: "HigherLevelKeys" = betterproto.message_field(13)
    """Keys allowed to do level1 updates;"""

    level2_keys: "AuthorizationsV1" = betterproto.message_field(14)
    """Keys allowed to do parameter updates."""

    finalization_committee_parameters: "FinalizationCommitteeParameters" = (
        betterproto.message_field(15)
    )
    """Finalization committee parameters"""


@dataclass(eq=False, repr=False)
class ChainParametersV3(betterproto.Message):
    """Updatable chain parameters that apply to protocol versions 8."""

    consensus_parameters: "ConsensusParametersV1" = betterproto.message_field(1)
    """Consensus parameters."""

    euro_per_energy: "ExchangeRate" = betterproto.message_field(2)
    """Euro per energy exchange rate."""

    micro_ccd_per_euro: "ExchangeRate" = betterproto.message_field(3)
    """Micro CCD per euro exchange rate."""

    cooldown_parameters: "CooldownParametersCpv1" = betterproto.message_field(4)
    """
    Extra number of epochs before reduction in stake, or baker deregistration
    is completed.
    """

    time_parameters: "TimeParametersCpv1" = betterproto.message_field(5)
    """
    Current time parameters. The time parameters indicates the mint rate and
    the reward period length, i.e. the time between paydays.
    """

    account_creation_limit: "CredentialsPerBlockLimit" = betterproto.message_field(6)
    """The limit for the number of account creations in a block."""

    mint_distribution: "MintDistributionCpv1" = betterproto.message_field(7)
    """Current mint distribution"""

    transaction_fee_distribution: "TransactionFeeDistribution" = (
        betterproto.message_field(8)
    )
    """Current transaction fee distribution."""

    gas_rewards: "GasRewardsCpv2" = betterproto.message_field(9)
    """Current gas reward parameters."""

    foundation_account: "AccountAddress" = betterproto.message_field(10)
    """The foundation account."""

    pool_parameters: "PoolParametersCpv1" = betterproto.message_field(11)
    """Parameters governing baking pools and their commissions."""

    root_keys: "HigherLevelKeys" = betterproto.message_field(12)
    """Keys allowed to do root updates."""

    level1_keys: "HigherLevelKeys" = betterproto.message_field(13)
    """Keys allowed to do level1 updates;"""

    level2_keys: "AuthorizationsV1" = betterproto.message_field(14)
    """Keys allowed to do parameter updates."""

    finalization_committee_parameters: "FinalizationCommitteeParameters" = (
        betterproto.message_field(15)
    )
    """Finalization committee parameters"""

    validator_score_parameters: "ValidatorScoreParameters" = betterproto.message_field(
        16
    )
    """Validator score parameters"""


@dataclass(eq=False, repr=False)
class ChainParameters(betterproto.Message):
    """Chain parameters."""

    v0: "ChainParametersV0" = betterproto.message_field(1, group="parameters")
    """
    Chain parameters that apply when the block is a protocol version 1-3 block.
    """

    v1: "ChainParametersV1" = betterproto.message_field(2, group="parameters")
    """
    Chain parameters that apply when the block is a protocol version 4-5 block.
    """

    v2: "ChainParametersV2" = betterproto.message_field(3, group="parameters")
    """
    Chain parameters that apply when the block is a protocol version 6-7 block.
    """

    v3: "ChainParametersV3" = betterproto.message_field(4, group="parameters")
    """
    Chain parameters that apply when the block is a protocol version 8- block.
    """


@dataclass(eq=False, repr=False)
class FinalizationSummaryParty(betterproto.Message):
    """Details about a finalizer for the finalization round."""

    baker: "BakerId" = betterproto.message_field(1)
    """Baker ID. Every finalizer is in particular a baker."""

    weight: int = betterproto.uint64_field(2)
    """
    The weight of the finalizer in the committee. This is an "absolute" weight.
    """

    signed: bool = betterproto.bool_field(3)
    """
    Whether the finalizer's signature was present on the particular
    finalization record.
    """


@dataclass(eq=False, repr=False)
class FinalizationIndex(betterproto.Message):
    """
    Index of the finalization round. This increases on each successfully
    completed finalization.
    """

    value: int = betterproto.uint64_field(1)


@dataclass(eq=False, repr=False)
class FinalizationSummary(betterproto.Message):
    """Details about a finalization record included in a block."""

    block: "BlockHash" = betterproto.message_field(1)
    """Block that was finalized by the finalization record."""

    index: "FinalizationIndex" = betterproto.message_field(2)
    """Index of the finalization round that finalized the block."""

    delay: "BlockHeight" = betterproto.message_field(3)
    """Finalization delay used for the finalization round."""

    finalizers: List["FinalizationSummaryParty"] = betterproto.message_field(4)
    """
    List of all finalizers with information about whether they signed the
    finalization record or not.
    """


@dataclass(eq=False, repr=False)
class BlockFinalizationSummary(betterproto.Message):
    """Finalization summary that may or may not be part of the block."""

    none: "Empty" = betterproto.message_field(1, group="summary")
    """There is no finalization data in the block."""

    record: "FinalizationSummary" = betterproto.message_field(2, group="summary")
    """There is a single finalization record with the block."""


@dataclass(eq=False, repr=False)
class BlockItem(betterproto.Message):
    hash: "TransactionHash" = betterproto.message_field(1)
    """The hash of the block item that identifies it to the chain."""

    account_transaction: "AccountTransaction" = betterproto.message_field(
        2, group="block_item"
    )
    """
    Account transactions are messages which are signed and paid for by an
    account.
    """

    credential_deployment: "CredentialDeployment" = betterproto.message_field(
        3, group="block_item"
    )
    """
    Credential deployments create new accounts. They are not paid for directly
    by the sender. Instead, bakers are rewarded by the protocol for including
    them.
    """

    update_instruction: "UpdateInstruction" = betterproto.message_field(
        4, group="block_item"
    )
    """
    Update instructions are messages which can update the chain parameters.
    Including which keys are allowed to make future update instructions.
    """


@dataclass(eq=False, repr=False)
class BakerRewardPeriodInfo(betterproto.Message):
    """
    Information about a particular baker with respect to the current reward
    period.
    """

    baker: "BakerInfo" = betterproto.message_field(1)
    """The baker id and public keys for the baker."""

    effective_stake: "Amount" = betterproto.message_field(2)
    """
    The effective stake of the baker for the consensus protocol. The returned
    amount accounts for delegation, capital bounds and leverage bounds.
    """

    commission_rates: "CommissionRates" = betterproto.message_field(3)
    """
    The effective commission rate for the baker that applies for the reward
    period.
    """

    equity_capital: "Amount" = betterproto.message_field(4)
    """The amount staked by the baker itself."""

    delegated_capital: "Amount" = betterproto.message_field(5)
    """The total amount of capital delegated to this baker pool."""

    is_finalizer: bool = betterproto.bool_field(6)
    """Whether the baker is a finalizer or not."""


@dataclass(eq=False, repr=False)
class QuorumSignature(betterproto.Message):
    """The signature of a 'QuorumCertificate' or 'QuorumMessage'."""

    value: bytes = betterproto.bytes_field(1)
    """
    The bytes representing the raw aggregate signature. The bytes have a fixed
    length of 48 bytes.
    """


@dataclass(eq=False, repr=False)
class QuorumCertificate(betterproto.Message):
    """
    A quorum certificate is the certificate that the finalization comittee
    issues in order to certify a block. A block must be certified before it
    will be part of the authorative part of the chain.
    """

    block_hash: "BlockHash" = betterproto.message_field(1)
    """The hash of the block that the quorum certificate refers to."""

    round: "Round" = betterproto.message_field(2)
    """The round of the block."""

    epoch: "Epoch" = betterproto.message_field(3)
    """The epoch of the block."""

    aggregate_signature: "QuorumSignature" = betterproto.message_field(4)
    """The aggregated signature by the finalization committee on the block."""

    signatories: List["BakerId"] = betterproto.message_field(5)
    """
    A list of the finalizers that formed the quorum certificate i.e., the ones
    who have contributed to the 'aggregate_siganture'. The finalizers are
    identified by their baker id as this is stable across protocols and epochs.
    """


@dataclass(eq=False, repr=False)
class FinalizerRound(betterproto.Message):
    """
    The finalizer round is a map from a 'Round' to the list of finalizers
    (identified by their 'BakerId') that signed off the round.
    """

    round: "Round" = betterproto.message_field(1)
    """The round that was signed off."""

    finalizers: List["BakerId"] = betterproto.message_field(2)
    """
    The finalizers (identified by their 'BakerId' that signed off the in
    'round'.
    """


@dataclass(eq=False, repr=False)
class TimeoutSignature(betterproto.Message):
    """The signature of a 'TimeoutCertificate'."""

    value: bytes = betterproto.bytes_field(1)
    """
    The bytes representing the raw aggregate signature. The bytes have a fixed
    length of 48 bytes.
    """


@dataclass(eq=False, repr=False)
class TimeoutCertificate(betterproto.Message):
    """
    A timeout certificate is the certificate that the finalization committee
    issues when a round times out, thus making it possible for the protocol to
    proceed to the next round.
    """

    round: "Round" = betterproto.message_field(1)
    """The round that timed out."""

    min_epoch: "Epoch" = betterproto.message_field(2)
    """
    The minimum epoch of which signatures are included in the
    'aggregate_signature'.
    """

    qc_rounds_first_epoch: List["FinalizerRound"] = betterproto.message_field(3)
    """
    The rounds of which finalizers have their best QCs in the 'min_epoch'.
    """

    qc_rounds_second_epoch: List["FinalizerRound"] = betterproto.message_field(4)
    """
    The rounds of which finalizers have their best QCs in the epoch 'min_epoch'
    + 1.
    """

    aggregate_signature: "TimeoutSignature" = betterproto.message_field(5)
    """
    The aggregated signature by the finalization committee that witnessed the
    'round' timed out.
    """


@dataclass(eq=False, repr=False)
class SuccessorProof(betterproto.Message):
    """
    A proof that establishes that the successor block of a
    'EpochFinalizationEntry' is the immediate successor of the finalized block.
    """

    value: bytes = betterproto.bytes_field(1)
    """
    The proof represented as raw bytes. The bytes have a fixed length of 32
    bytes.
    """


@dataclass(eq=False, repr=False)
class EpochFinalizationEntry(betterproto.Message):
    """
    The epoch finalization entry is the proof that makes the protocol able to
    advance to a new epoch. I.e. the 'EpochFinalizationEntry' is present if and
    only if the block is the first block of a new 'Epoch'.
    """

    finalized_qc: "QuorumCertificate" = betterproto.message_field(1)
    """The quorum certificate for the finalized block."""

    successor_qc: "QuorumCertificate" = betterproto.message_field(2)
    """
    The quorum certificate for the block that finalizes the block that
    'finalized_qc' points to.
    """

    successor_proof: "SuccessorProof" = betterproto.message_field(3)
    """
    A proof that the successor block is an immediate successor of the finalized
    block.
    """


@dataclass(eq=False, repr=False)
class BlockCertificates(betterproto.Message):
    """Certificates for a block for protocols supporting ConcordiumBFT."""

    quorum_certificate: Optional["QuorumCertificate"] = betterproto.message_field(
        1, optional=True, group="_quorum_certificate"
    )
    """
    The quorum certificate. Is present if and only if the block is not a
    genesis block.
    """

    timeout_certificate: Optional["TimeoutCertificate"] = betterproto.message_field(
        2, optional=True, group="_timeout_certificate"
    )
    """
    The timeout certificate. Is present only if the round prior to the round of
    the block timed out.
    """

    epoch_finalization_entry: Optional["EpochFinalizationEntry"] = (
        betterproto.message_field(3, optional=True, group="_epoch_finalization_entry")
    )
    """
    The epoch finalization entry. Is present only if the block initiates a new
    epoch.
    """


@dataclass(eq=False, repr=False)
class WinningBaker(betterproto.Message):
    """
    Details of which baker won the lottery in a given round in consensus
    version 1.
    """

    round: "Round" = betterproto.message_field(1)
    """The round number."""

    winner: "BakerId" = betterproto.message_field(2)
    """The baker that won the round."""

    present: bool = betterproto.bool_field(3)
    """
    True if the baker produced a block in this round on the finalized chain,
    and False otherwise.
    """


@dataclass(eq=False, repr=False)
class DryRunRequest(betterproto.Message):
    """
    An operation to dry run.  The first operation in a dry-run sequence should
    be `load_block_state`: any other operation will be met with `NoState` until
    a state is successfully loaded.
    """

    load_block_state: "BlockHashInput" = betterproto.message_field(1, group="request")
    """
    Load the state of the specified block to use for subsequent requests. The
    state is taken at the end of execution of the block, and the block’s
    timestamp is used as the current timestamp. The energy cost for this
    operation is 2000.
    """

    state_query: "DryRunStateQuery" = betterproto.message_field(2, group="request")
    """Run a query on the state."""

    state_operation: "DryRunStateOperation" = betterproto.message_field(
        3, group="request"
    )
    """Run a (non-transaction) operation to modify the state."""


@dataclass(eq=False, repr=False)
class DryRunStateQuery(betterproto.Message):
    """
    Run a query as part of a dry run. Queries do not update the block state.
    """

    get_account_info: "AccountIdentifierInput" = betterproto.message_field(
        1, group="query"
    )
    """
    Look up information on a particular account. The energy cost for this query
    is 200.
    """

    get_instance_info: "ContractAddress" = betterproto.message_field(2, group="query")
    """
    Look up information about a particular smart contract. The energy cost for
    this query is 200.
    """

    invoke_instance: "DryRunInvokeInstance" = betterproto.message_field(
        3, group="query"
    )
    """
    Invoke an entrypoint on a smart contract instance. No changes made to the
    state are retained at the completion of the operation. The energy cost for
    this query is 200 plus the energy used by the smart contract execution.
    """


@dataclass(eq=False, repr=False)
class DryRunInvokeInstance(betterproto.Message):
    """Invoke an entrypoint on a smart contract instance."""

    invoker: Optional["Address"] = betterproto.message_field(
        1, optional=True, group="_invoker"
    )
    """
    Invoker of the contract. If this is not supplied then the contract will be
    invoked by an account with address 0, no credentials and sufficient amount
    of CCD to cover the transfer amount. If given, the relevant address (either
    account or contract) must exist in the blockstate.
    """

    instance: "ContractAddress" = betterproto.message_field(2)
    """Address of the contract instance to invoke."""

    amount: "Amount" = betterproto.message_field(3)
    """Amount to invoke the smart contract instance with."""

    entrypoint: "ReceiveName" = betterproto.message_field(4)
    """The entrypoint of the smart contract instance to invoke."""

    parameter: "Parameter" = betterproto.message_field(5)
    """The parameter bytes to include in the invocation of the entrypoint."""

    energy: "Energy" = betterproto.message_field(6)
    """
    The maximum energy to allow for the invocation. Note that the node imposes
    an energy quota that is enforced in addition to this limit.
    """


@dataclass(eq=False, repr=False)
class DryRunStateOperation(betterproto.Message):
    """An operation that can update the state as part of a dry run."""

    set_timestamp: "Timestamp" = betterproto.message_field(1, group="operation")
    """
    Sets the current block time to the given timestamp for the purposes of
    future transactions. The energy cost of this operation is 50.
    """

    mint_to_account: "DryRunMintToAccount" = betterproto.message_field(
        2, group="operation"
    )
    """
    Add a specified amount of newly-minted CCDs to a specified account. The
    amount cannot cause the total circulating supply to overflow. The energy
    cost of this operation is 400.
    """

    run_transaction: "DryRunTransaction" = betterproto.message_field(
        3, group="operation"
    )
    """
    Dry run a transaction, updating the state if it succeeds. The energy cost
    of this operation is 400 plus the energy used by executing the transaction.
    """


@dataclass(eq=False, repr=False)
class DryRunMintToAccount(betterproto.Message):
    """
    Mint a specified amount and credit it to the specified account as part of a
    dry run.
    """

    account: "AccountAddress" = betterproto.message_field(1)
    """The account to mint to."""

    amount: "Amount" = betterproto.message_field(2)
    """The amount to mint and credit to the account."""


@dataclass(eq=False, repr=False)
class DryRunTransaction(betterproto.Message):
    """Dry run an account transaction"""

    sender: "AccountAddress" = betterproto.message_field(1)
    """The account to use as the sender of the transaction."""

    energy_amount: "Energy" = betterproto.message_field(2)
    """The energy limit set for executing the transaction."""

    payload: "AccountTransactionPayload" = betterproto.message_field(3)
    """The payload of the transaction."""

    signatures: List["DryRunSignature"] = betterproto.message_field(4)
    """
    Which credentials and keys should be treated as having signed the
    transaction. If none is given, then the transaction is treated as having
    one signature for credential 0, key 0. Therefore, this is only required
    when the transaction is from a multi-signature account. There are two
    reasons why you might want to specify signatures:   * The cost of the
    transaction depends on the number of signatures, so if you want to     get
    the correct cost for a multi-signature transaction, then specifying the
    signatures     supports this.   * When changing account keys on a multi-
    credential account, the transaction must be signed     by the credential
    whose keys are being changed. Note that the signature thresholds are not
    checked as part of the dry run. Duplicated signatures are only counted
    once.
    """


@dataclass(eq=False, repr=False)
class DryRunSignature(betterproto.Message):
    """
    A dry run signature is a pair of a credential index and key index,
    identifying the credential and key that is presumed to have signed the
    transaction. No actual cryptographic signature is included.
    """

    credential: int = betterproto.uint32_field(1)
    """Credential index. Must not exceed 255."""

    key: int = betterproto.uint32_field(2)
    """Key index. Must not exceed 255."""


@dataclass(eq=False, repr=False)
class DryRunResponse(betterproto.Message):
    """A response to a `DryRunRequest`."""

    error: "DryRunErrorResponse" = betterproto.message_field(1, group="response")
    """
    The request produced an error. The request otherwise has no effect on the
    state.
    """

    success: "DryRunSuccessResponse" = betterproto.message_field(2, group="response")
    """The request was successful."""

    quota_remaining: "Energy" = betterproto.message_field(3)
    """The remaining available energy quota after the dry run operation."""


@dataclass(eq=False, repr=False)
class DryRunErrorResponse(betterproto.Message):
    no_state: "DryRunErrorResponseNoState" = betterproto.message_field(1, group="error")
    """
    The current block state is undefined. It should be initialized with a
    'load_block_state' request before any other operations.
    """

    block_not_found: "DryRunErrorResponseBlockNotFound" = betterproto.message_field(
        2, group="error"
    )
    """
    The requested block was not found, so its state could not be loaded.
    Response to 'load_block_state'.
    """

    account_not_found: "DryRunErrorResponseAccountNotFound" = betterproto.message_field(
        3, group="error"
    )
    """
    The specified account was not found. Response to 'get_account_info',
    'mint_to_account' and 'run_transaction'.
    """

    instance_not_found: "DryRunErrorResponseInstanceNotFound" = (
        betterproto.message_field(4, group="error")
    )
    """
    The specified instance was not found. Response to 'get_instance_info'.
    """

    amount_over_limit: "DryRunErrorResponseAmountOverLimit" = betterproto.message_field(
        5, group="error"
    )
    """
    The amount to mint would overflow the total CCD supply. Response to
    'mint_to_account'.
    """

    balance_insufficient: "DryRunErrorResponseBalanceInsufficient" = (
        betterproto.message_field(6, group="error")
    )
    """
    The balance of the sender account is not sufficient to pay for the
    operation. Response to 'run_transaction'.
    """

    energy_insufficient: "DryRunErrorResponseEnergyInsufficient" = (
        betterproto.message_field(8, group="error")
    )
    """
    The energy supplied for the transaction was not sufficient to perform the
    basic checks. Response to 'run_transaction'.
    """

    invoke_failed: "DryRunErrorResponseInvokeFailure" = betterproto.message_field(
        9, group="error"
    )
    """The contract invocation failed. Response to 'invoke_instance'."""


@dataclass(eq=False, repr=False)
class DryRunErrorResponseNoState(betterproto.Message):
    """
    The current block state is undefined. It should be initialized with a
    'load_block_state' request before any other operations.
    """

    pass


@dataclass(eq=False, repr=False)
class DryRunErrorResponseBlockNotFound(betterproto.Message):
    """The requested block was not found, so its state could not be loaded."""

    pass


@dataclass(eq=False, repr=False)
class DryRunErrorResponseAccountNotFound(betterproto.Message):
    """The specified account was not found."""

    pass


@dataclass(eq=False, repr=False)
class DryRunErrorResponseInstanceNotFound(betterproto.Message):
    """The specified instance was not found."""

    pass


@dataclass(eq=False, repr=False)
class DryRunErrorResponseAmountOverLimit(betterproto.Message):
    """
    The amount that was requested to be minted would overflow the total supply.
    """

    amount_limit: "Amount" = betterproto.message_field(1)
    """
    The maximum amount that can be minted without overflowing the supply.
    """


@dataclass(eq=False, repr=False)
class DryRunErrorResponseBalanceInsufficient(betterproto.Message):
    """
    The sender account for the transaction has insufficient balance to pay the
    preliminary fees for the transaction to be included in a block.
    """

    required_amount: "Amount" = betterproto.message_field(1)
    """The minimum balance required to perform the operation."""

    available_amount: "Amount" = betterproto.message_field(2)
    """
    The currently-available balance on the account to pay for the operation.
    """


@dataclass(eq=False, repr=False)
class DryRunErrorResponseEnergyInsufficient(betterproto.Message):
    """
    The energy made available for the transaction is insufficient to cover the
    basic processing required to include a transaction in a block.
    """

    energy_required: "Energy" = betterproto.message_field(1)
    """
    The minimum energy required for the transaction to be included in the
    chain. Note that, even if the energy supplied for the transaction is enough
    to prevent a `EnergyInsufficient`, the transaction can still be rejected
    for having insufficient energy. In that case, a `TransactionExecuted`
    response will be produced, but indicate the transaction was rejected.
    """


@dataclass(eq=False, repr=False)
class DryRunErrorResponseInvokeFailure(betterproto.Message):
    """Invoking the smart contract instance failed."""

    return_value: Optional[bytes] = betterproto.bytes_field(
        1, optional=True, group="_return_value"
    )
    """
    If invoking a V0 contract this is not provided, otherwise it is potentially
    return value produced by the call unless the call failed with out of energy
    or runtime error. If the V1 contract terminated with a logic error then the
    return value is present.
    """

    used_energy: "Energy" = betterproto.message_field(2)
    """Energy used by the execution."""

    reason: "RejectReason" = betterproto.message_field(3)
    """Contract execution failed for the given reason."""


@dataclass(eq=False, repr=False)
class DryRunSuccessResponse(betterproto.Message):
    """The dry run operation completed successfully."""

    block_state_loaded: "DryRunSuccessResponseBlockStateLoaded" = (
        betterproto.message_field(1, group="response")
    )
    """
    The state from the specified block was successfully loaded. Response to
    'load_block_state'.
    """

    account_info: "AccountInfo" = betterproto.message_field(2, group="response")
    """Details of the requested account. Response to 'get_account_info'."""

    instance_info: "InstanceInfo" = betterproto.message_field(3, group="response")
    """
    Details of the requested smart contract instance. Response to
    'get_instance_info'.
    """

    invoke_succeeded: "DryRunSuccessResponseInvokeSuccess" = betterproto.message_field(
        4, group="response"
    )
    """The smart contract instance was invoked successfully."""

    timestamp_set: "DryRunSuccessResponseTimestampSet" = betterproto.message_field(
        5, group="response"
    )
    """
    The current timestamp was set successfully. Response to 'set_timestamp'.
    """

    minted_to_account: "DryRunSuccessResponseMintedToAccount" = (
        betterproto.message_field(6, group="response")
    )
    """
    The specified amount was minted and credited to the account. Response to
    'mint_to_account'.
    """

    transaction_executed: "DryRunSuccessResponseTransactionExecuted" = (
        betterproto.message_field(7, group="response")
    )
    """
    The specified transaction was executed. Note that the transaction could
    still have been rejected. Response to 'run_transaction'.
    """


@dataclass(eq=False, repr=False)
class DryRunSuccessResponseBlockStateLoaded(betterproto.Message):
    """The block state at the specified block was successfully loaded."""

    current_timestamp: "Timestamp" = betterproto.message_field(1)
    """The timestamp of the block, taken to be the current timestamp."""

    block_hash: "BlockHash" = betterproto.message_field(2)
    """The hash of the block that was loaded."""

    protocol_version: "ProtocolVersion" = betterproto.enum_field(3)
    """
    The protocol version at the specified block. The behavior of operations can
    vary across protocol versions.
    """


@dataclass(eq=False, repr=False)
class DryRunSuccessResponseTimestampSet(betterproto.Message):
    """The current apparent timestamp was updated to the specified value."""

    pass


@dataclass(eq=False, repr=False)
class DryRunSuccessResponseMintedToAccount(betterproto.Message):
    """The specified amount was minted to the specified account."""

    pass


@dataclass(eq=False, repr=False)
class DryRunSuccessResponseTransactionExecuted(betterproto.Message):
    """The transaction was executed."""

    energy_cost: "Energy" = betterproto.message_field(1)
    """The amount of energy actually expended in executing the transaction."""

    details: "AccountTransactionDetails" = betterproto.message_field(2)
    """The details of the outcome of the transaction."""

    return_value: Optional[bytes] = betterproto.bytes_field(
        3, optional=True, group="_return_value"
    )
    """
    If this is an invocation of a V1 contract that produced a return value,
    this is that value. Otherwise it is absent.
    """


@dataclass(eq=False, repr=False)
class DryRunSuccessResponseInvokeSuccess(betterproto.Message):
    """The smart contract instance was invoked successfully."""

    return_value: Optional[bytes] = betterproto.bytes_field(
        1, optional=True, group="_return_value"
    )
    """
    If invoking a V0 contract this is absent. Otherwise it is the return value
    produced by the contract.
    """

    used_energy: "Energy" = betterproto.message_field(2)
    """Energy used by the execution."""

    effects: List["ContractTraceElement"] = betterproto.message_field(3)
    """Effects produced by contract execution."""


@dataclass(eq=False, repr=False)
class FinalizerIndex(betterproto.Message):
    """The index of a particular finalizer in the finalization committee."""

    value: int = betterproto.uint32_field(1)


@dataclass(eq=False, repr=False)
class QuorumMessage(betterproto.Message):
    """
    The message that is multicast by a finalizer when validating and signing a
    block.
    """

    signature: "QuorumSignature" = betterproto.message_field(1)
    """Signature on the relevant quorum signature message."""

    block: "BlockHash" = betterproto.message_field(2)
    """Hash of the block that is signed."""

    finalizer: "FinalizerIndex" = betterproto.message_field(3)
    """Index of the finalizer signing the message."""

    round: "Round" = betterproto.message_field(4)
    """Round of the block."""

    epoch: "Epoch" = betterproto.message_field(5)
    """Epoch of the block."""


@dataclass(eq=False, repr=False)
class RawQuorumCertificate(betterproto.Message):
    block_hash: "BlockHash" = betterproto.message_field(1)
    """The hash of the block that the quorum certificate refers to."""

    round: "Round" = betterproto.message_field(2)
    """The round of the block."""

    epoch: "Epoch" = betterproto.message_field(3)
    """The epoch of the block."""

    aggregate_signature: "QuorumSignature" = betterproto.message_field(4)
    """The aggregated signature by the finalization committee on the block."""

    signatories: List["FinalizerIndex"] = betterproto.message_field(5)
    """
    A list of the finalizers that formed the quorum certificate i.e., the ones
    who have contributed to the 'aggregate_signature'. The finalizers are
    identified by their finalizer index, which refers to the finalization
    committee for the epoch.
    """


@dataclass(eq=False, repr=False)
class BlockSignature(betterproto.Message):
    """
    A (non-aggregate) signature of a validator. This is used to sign blocks
    produced by the validator as well as some finalization messages.
    """

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class TimeoutMessage(betterproto.Message):
    """A timeout message including the sender's signature."""

    finalizer: "FinalizerIndex" = betterproto.message_field(1)
    """Index of the finalizer signing the message."""

    round: "Round" = betterproto.message_field(2)
    """Round which timed out."""

    epoch: "Epoch" = betterproto.message_field(3)
    """
    Current epoch number of the finalizer sending the timeout message. This can
    be different from the epoch of the quorum certificate.
    """

    quorum_certificate: "RawQuorumCertificate" = betterproto.message_field(4)
    """
    Highest quorum certificate known to the finalizer at the time of timeout.
    """

    signature: "TimeoutSignature" = betterproto.message_field(5)
    """Signature on the appropriate timeout signature message."""

    message_signature: "BlockSignature" = betterproto.message_field(6)
    """Signature of the finalizer on the timeout message as a whole."""


@dataclass(eq=False, repr=False)
class RawFinalizerRound(betterproto.Message):
    round: "Round" = betterproto.message_field(1)
    """The round that was signed off."""

    finalizers: List["FinalizerIndex"] = betterproto.message_field(2)
    """
    The finalizers (identified by their 'FinalizerIndex') that signed off in
    'round'.
    """


@dataclass(eq=False, repr=False)
class RawTimeoutCertificate(betterproto.Message):
    """
    A timeout certificate is the certificate that the finalization committee
    issues when a round times out, thus making it possible for the protocol to
    proceed to the next round.
    """

    round: "Round" = betterproto.message_field(1)
    """The round that timed out."""

    min_epoch: "Epoch" = betterproto.message_field(2)
    """
    The minimum epoch of which signatures are included in the
    'aggregate_signature'.
    """

    qc_rounds_first_epoch: List["RawFinalizerRound"] = betterproto.message_field(3)
    """
    The rounds of which finalizers have their best QCs in the 'min_epoch'.
    """

    qc_rounds_second_epoch: List["RawFinalizerRound"] = betterproto.message_field(4)
    """
    The rounds of which finalizers have their best QCs in the epoch 'min_epoch'
    + 1.
    """

    aggregate_signature: "TimeoutSignature" = betterproto.message_field(5)
    """
    The aggregated signature by the finalization committee that witnessed the
    'round' timed out.
    """


@dataclass(eq=False, repr=False)
class PersistentRoundStatus(betterproto.Message):
    last_signed_quorum_message: Optional["QuorumMessage"] = betterproto.message_field(
        1, optional=True, group="_last_signed_quorum_message"
    )
    """The last signed quorum message by the node."""

    last_signed_timeout_message: Optional["TimeoutMessage"] = betterproto.message_field(
        2, optional=True, group="_last_signed_timeout_message"
    )
    """The last signed timeout message by the node."""

    last_baked_round: "Round" = betterproto.message_field(3)
    """The last round the node baked in."""

    latest_timeout: Optional["RawTimeoutCertificate"] = betterproto.message_field(
        4, optional=True, group="_latest_timeout"
    )
    """
    The latest timeout certificate seen by the node. May be absent if the node
    has seen a quorum certificate for a more recent round.
    """


@dataclass(eq=False, repr=False)
class RoundTimeout(betterproto.Message):
    timeout_certificate: "RawTimeoutCertificate" = betterproto.message_field(1)
    """Timeout certificate for the round that timed out."""

    quorum_certificate: "RawQuorumCertificate" = betterproto.message_field(2)
    """The highest known quorum certificate when the round timed out."""


@dataclass(eq=False, repr=False)
class RawFinalizationEntry(betterproto.Message):
    finalized_qc: "RawQuorumCertificate" = betterproto.message_field(1)
    """The quorum certificate for the finalized block."""

    successor_qc: "RawQuorumCertificate" = betterproto.message_field(2)
    """
    The quorum certificate for the block that finalizes the block that
    'finalized_qc' points to.
    """

    successor_proof: "SuccessorProof" = betterproto.message_field(3)
    """
    A proof that the successor block is an immediate successor of the finalized
    block.
    """


@dataclass(eq=False, repr=False)
class RoundStatus(betterproto.Message):
    """The current round status."""

    current_round: "Round" = betterproto.message_field(1)
    """
    The current round from the perspective of the node. This should always be
    higher than the round of the highest certified block. If the previous round
    did not timeout, it should be one more than the round of the
    `highest_certified_block`. Otherwise, it should be one more than the round
    of the `previous_round_timeout`.
    """

    highest_certified_block: "RawQuorumCertificate" = betterproto.message_field(2)
    """The quorum certificate for the highest certified block."""

    previous_round_timeout: Optional["RoundTimeout"] = betterproto.message_field(
        3, optional=True, group="_previous_round_timeout"
    )
    """
    If the last round timed out, this is the timeout certificate for that round
    and the highest quorum certificate at the time the round timed out.
    """

    round_eligible_to_bake: bool = betterproto.bool_field(4)
    """
    Flag indicating whether the node should attempt to bake in the current
    round. This is set to true when the round is advanced, and set to false
    once the node has attempted to bake for the round.
    """

    current_epoch: "Epoch" = betterproto.message_field(5)
    """
    The current epoch. This should either be the same as the epoch of the last
    finalized block (if its timestamp is before the trigger block time) or the
    next epoch from the last finalized block (if its timestamp is at least the
    trigger block time).
    """

    last_epoch_finalization_entry: Optional["RawFinalizationEntry"] = (
        betterproto.message_field(
            6, optional=True, group="_last_epoch_finalization_entry"
        )
    )
    """
    If present, an epoch finalization entry for the epoch before
    `current_epoch`. An entry must be present if the current epoch is greater
    than the epoch of the last finalized block.
    """

    current_timeout: "Duration" = betterproto.message_field(7)
    """The current duration the node will wait before a round times out."""


@dataclass(eq=False, repr=False)
class BlockTableSummary(betterproto.Message):
    dead_block_cache_size: int = betterproto.uint64_field(1)
    """The number of blocks in the dead block cache."""

    live_blocks: List["BlockHash"] = betterproto.message_field(2)
    """The blocks that are currently live (not dead and not finalized)."""


@dataclass(eq=False, repr=False)
class BranchBlocks(betterproto.Message):
    """A list of block hashes at a particular branch height."""

    blocks_at_branch_height: List["BlockHash"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class RoundExistingBlock(betterproto.Message):
    round: "Round" = betterproto.message_field(1)
    """The round for which the node saw a block."""

    baker: "BakerId" = betterproto.message_field(2)
    """The baker that baked the block."""

    block: "BlockHash" = betterproto.message_field(3)
    """The hash of the block."""


@dataclass(eq=False, repr=False)
class RoundExistingQc(betterproto.Message):
    round: "Round" = betterproto.message_field(1)
    """The round for which a QC was seen."""

    epoch: "Epoch" = betterproto.message_field(2)
    """The epoch of the QC."""


@dataclass(eq=False, repr=False)
class FullBakerInfo(betterproto.Message):
    """The keys an stake of a specific baker."""

    baker_identity: "BakerId" = betterproto.message_field(1)
    """The baker's identity."""

    election_verify_key: "BakerElectionVerifyKey" = betterproto.message_field(2)
    """The baker's election verify key."""

    signature_verify_key: "BakerSignatureVerifyKey" = betterproto.message_field(3)
    """The baker's signature verify key."""

    aggregation_verify_key: "BakerAggregationVerifyKey" = betterproto.message_field(4)
    """The baker's aggregation verify key."""

    stake: "Amount" = betterproto.message_field(5)
    """The stake of the baker."""


@dataclass(eq=False, repr=False)
class FinalizationCommitteeHash(betterproto.Message):
    """
    The hash of the finalization committee, derived from the weights and
    aggregation keys of the finalizers.
    """

    value: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class BakersAndFinalizers(betterproto.Message):
    bakers: List["FullBakerInfo"] = betterproto.message_field(1)
    """The set of bakers."""

    finalizers: List["BakerId"] = betterproto.message_field(2)
    """
    The IDs of the bakers that are finalizers. The order determines the
    finalizer index.
    """

    baker_total_stake: "Amount" = betterproto.message_field(3)
    """The total effective stake of the bakers."""

    finalizer_total_stake: "Amount" = betterproto.message_field(4)
    """The total effective stake of the finalizers."""

    finalization_committee_hash: "FinalizationCommitteeHash" = (
        betterproto.message_field(5)
    )
    """The hash of the finalization committee."""


@dataclass(eq=False, repr=False)
class EpochBakers(betterproto.Message):
    previous_epoch_bakers: "BakersAndFinalizers" = betterproto.message_field(1)
    """
    The bakers and finalizers for the previous epoch. If the current epoch is
    0, then this is the same as the bakers for the current epoch.
    """

    current_epoch_bakers: Optional["BakersAndFinalizers"] = betterproto.message_field(
        2, optional=True, group="_current_epoch_bakers"
    )
    """
    The bakers and finalizers for the current epoch. If this is absent, it
    should be treated as the same as the bakers for the previous epoch.
    """

    next_epoch_bakers: Optional["BakersAndFinalizers"] = betterproto.message_field(
        3, optional=True, group="_next_epoch_bakers"
    )
    """
    The bakers and finalizers for the next epoch. If this is absent, it should
    be treated as the same as the bakers for the current epoch.
    """

    next_payday: "Epoch" = betterproto.message_field(4)
    """The first epoch of the next payday."""


@dataclass(eq=False, repr=False)
class TimeoutMessages(betterproto.Message):
    first_epoch: "Epoch" = betterproto.message_field(1)
    """The first epoch for which timeout messages are present."""

    first_epoch_timeouts: List["TimeoutMessage"] = betterproto.message_field(2)
    """
    The timeout messages for the first epoch. There should always be at least
    one.
    """

    second_epoch_timeouts: List["TimeoutMessage"] = betterproto.message_field(3)
    """The timeout messages for `first_epoch + 1`."""


@dataclass(eq=False, repr=False)
class AggregatedSignatures(betterproto.Message):
    signed_block: "BlockHash" = betterproto.message_field(1)
    """The block hash for which the signatures are aggregated."""

    signature_weight: "Amount" = betterproto.message_field(2)
    """The total weight of the finalizers that signed the block."""

    aggregate_signature: "QuorumSignature" = betterproto.message_field(3)
    """The aggregate signature of the finalizers."""

    signatories: List["FinalizerIndex"] = betterproto.message_field(4)
    """The set of finalizers that have signed."""


@dataclass(eq=False, repr=False)
class QuorumMessages(betterproto.Message):
    quorum_messages: List["QuorumMessage"] = betterproto.message_field(1)
    """The collected quorum messages for the current round."""

    aggregated_signatures: List["AggregatedSignatures"] = betterproto.message_field(2)
    """The current aggregate of the valid quorum messages."""


@dataclass(eq=False, repr=False)
class ConsensusDetailedStatusQuery(betterproto.Message):
    genesis_index: Optional["GenesisIndex"] = betterproto.message_field(
        1, optional=True, group="_genesis_index"
    )
    """
    If specified, this determines the genesis index to get status for. If not
    specified, the status is returned for the latest genesis index.
    """


@dataclass(eq=False, repr=False)
class ConsensusDetailedStatus(betterproto.Message):
    genesis_block: "BlockHash" = betterproto.message_field(1)
    """The hash of the genesis block."""

    persistent_round_status: "PersistentRoundStatus" = betterproto.message_field(2)
    """The persisted elements of the round status."""

    round_status: "RoundStatus" = betterproto.message_field(3)
    """The status of the current round."""

    non_finalized_transaction_count: int = betterproto.uint64_field(4)
    """The number of non-finalized transactions."""

    transaction_table_purge_counter: int = betterproto.int64_field(5)
    """The purge counter for the transaction table."""

    block_table: "BlockTableSummary" = betterproto.message_field(6)
    """Summary of the block table."""

    branches: List["BranchBlocks"] = betterproto.message_field(7)
    """The live blocks organized by height after the last finalized block."""

    round_existing_blocks: List["RoundExistingBlock"] = betterproto.message_field(8)
    """
    Which bakers the node has seen legally-signed blocks with live parents from
    in non-finalized rounds.
    """

    round_existing_qcs: List["RoundExistingQc"] = betterproto.message_field(9)
    """
    Which non-finalized rounds the node has seen quorum certificates for.
    """

    genesis_block_height: "AbsoluteBlockHeight" = betterproto.message_field(10)
    """The absolute block height of the genesis block of the era."""

    last_finalized_block: "BlockHash" = betterproto.message_field(11)
    """The hash of the last finalized block."""

    last_finalized_block_height: "BlockHeight" = betterproto.message_field(12)
    """The height of the last finalized block."""

    latest_finalization_entry: Optional["RawFinalizationEntry"] = (
        betterproto.message_field(13, optional=True, group="_latest_finalization_entry")
    )
    """
    Unless the last finalized block is the genesis block, this should be a
    finalization entry for the last finalized block. As this includes a quorum
    certificate for the last finalized block, that can be used to determine the
    epoch and round of the last finalized block.
    """

    epoch_bakers: "EpochBakers" = betterproto.message_field(14)
    """
    The bakers and finalizers for the previous, current and next epoch,
    relative to the last finalized block.
    """

    timeout_messages: Optional["TimeoutMessages"] = betterproto.message_field(
        15, optional=True, group="_timeout_messages"
    )
    """The timeout messages collected by the node for the current round."""

    terminal_block: Optional["BlockHash"] = betterproto.message_field(
        16, optional=True, group="_terminal_block"
    )
    """
    If a protocol update has occurred, this is the hash of the terminal block.
    """


@dataclass(eq=False, repr=False)
class AccountPending(betterproto.Message):
    """
    Indicates that an account is pending -- either a scheduled release or a
    cooldown -- and when the first release or cooldown will elapse.
    """

    account_index: "AccountIndex" = betterproto.message_field(1)
    first_timestamp: "Timestamp" = betterproto.message_field(2)


class QueriesStub(betterproto.ServiceStub):
    async def get_blocks(
        self,
        empty: "Empty",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ArrivedBlockInfo"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetBlocks",
            empty,
            ArrivedBlockInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_finalized_blocks(
        self,
        empty: "Empty",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["FinalizedBlockInfo"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetFinalizedBlocks",
            empty,
            FinalizedBlockInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_account_info(
        self,
        account_info_request: "AccountInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AccountInfo":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetAccountInfo",
            account_info_request,
            AccountInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_account_list(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["AccountAddress"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetAccountList",
            block_hash_input,
            AccountAddress,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_module_list(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ModuleRef"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetModuleList",
            block_hash_input,
            ModuleRef,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_ancestors(
        self,
        ancestors_request: "AncestorsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["BlockHash"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetAncestors",
            ancestors_request,
            BlockHash,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_module_source(
        self,
        module_source_request: "ModuleSourceRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "VersionedModuleSource":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetModuleSource",
            module_source_request,
            VersionedModuleSource,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_instance_list(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ContractAddress"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetInstanceList",
            block_hash_input,
            ContractAddress,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_instance_info(
        self,
        instance_info_request: "InstanceInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InstanceInfo":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetInstanceInfo",
            instance_info_request,
            InstanceInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_instance_state(
        self,
        instance_info_request: "InstanceInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["InstanceStateKvPair"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetInstanceState",
            instance_info_request,
            InstanceStateKvPair,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def instance_state_lookup(
        self,
        instance_state_lookup_request: "InstanceStateLookupRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InstanceStateValueAtKey":
        return await self._unary_unary(
            "/concordium.v2.Queries/InstanceStateLookup",
            instance_state_lookup_request,
            InstanceStateValueAtKey,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_next_account_sequence_number(
        self,
        account_address: "AccountAddress",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "NextAccountSequenceNumber":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetNextAccountSequenceNumber",
            account_address,
            NextAccountSequenceNumber,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_consensus_info(
        self,
        empty: "Empty",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ConsensusInfo":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetConsensusInfo",
            empty,
            ConsensusInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_block_item_status(
        self,
        transaction_hash: "TransactionHash",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BlockItemStatus":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetBlockItemStatus",
            transaction_hash,
            BlockItemStatus,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_cryptographic_parameters(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CryptographicParameters":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetCryptographicParameters",
            block_hash_input,
            CryptographicParameters,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_block_info(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BlockInfo":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetBlockInfo",
            block_hash_input,
            BlockInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_baker_list(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["BakerId"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetBakerList",
            block_hash_input,
            BakerId,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_pool_info(
        self,
        pool_info_request: "PoolInfoRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "PoolInfoResponse":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetPoolInfo",
            pool_info_request,
            PoolInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_passive_delegation_info(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "PassiveDelegationInfo":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetPassiveDelegationInfo",
            block_hash_input,
            PassiveDelegationInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_blocks_at_height(
        self,
        blocks_at_height_request: "BlocksAtHeightRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BlocksAtHeightResponse":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetBlocksAtHeight",
            blocks_at_height_request,
            BlocksAtHeightResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_tokenomics_info(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TokenomicsInfo":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetTokenomicsInfo",
            block_hash_input,
            TokenomicsInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def invoke_instance(
        self,
        invoke_instance_request: "InvokeInstanceRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "InvokeInstanceResponse":
        return await self._unary_unary(
            "/concordium.v2.Queries/InvokeInstance",
            invoke_instance_request,
            InvokeInstanceResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_pool_delegators(
        self,
        get_pool_delegators_request: "GetPoolDelegatorsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DelegatorInfo"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetPoolDelegators",
            get_pool_delegators_request,
            DelegatorInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_pool_delegators_reward_period(
        self,
        get_pool_delegators_request: "GetPoolDelegatorsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DelegatorRewardPeriodInfo"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetPoolDelegatorsRewardPeriod",
            get_pool_delegators_request,
            DelegatorRewardPeriodInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_passive_delegators(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DelegatorInfo"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetPassiveDelegators",
            block_hash_input,
            DelegatorInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_passive_delegators_reward_period(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DelegatorRewardPeriodInfo"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetPassiveDelegatorsRewardPeriod",
            block_hash_input,
            DelegatorRewardPeriodInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_branches(
        self,
        empty: "Empty",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "Branch":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetBranches",
            empty,
            Branch,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_election_info(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ElectionInfo":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetElectionInfo",
            block_hash_input,
            ElectionInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_identity_providers(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["IpInfo"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetIdentityProviders",
            block_hash_input,
            IpInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_anonymity_revokers(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["ArInfo"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetAnonymityRevokers",
            block_hash_input,
            ArInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_account_non_finalized_transactions(
        self,
        account_address: "AccountAddress",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["TransactionHash"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetAccountNonFinalizedTransactions",
            account_address,
            TransactionHash,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_block_transaction_events(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["BlockItemSummary"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetBlockTransactionEvents",
            block_hash_input,
            BlockItemSummary,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_block_special_events(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["BlockSpecialEvent"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetBlockSpecialEvents",
            block_hash_input,
            BlockSpecialEvent,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_block_pending_updates(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["PendingUpdate"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetBlockPendingUpdates",
            block_hash_input,
            PendingUpdate,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_next_update_sequence_numbers(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "NextUpdateSequenceNumbers":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetNextUpdateSequenceNumbers",
            block_hash_input,
            NextUpdateSequenceNumbers,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_scheduled_release_accounts(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["AccountPending"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetScheduledReleaseAccounts",
            block_hash_input,
            AccountPending,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_cooldown_accounts(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["AccountPending"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetCooldownAccounts",
            block_hash_input,
            AccountPending,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_pre_cooldown_accounts(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["AccountIndex"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetPreCooldownAccounts",
            block_hash_input,
            AccountIndex,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_pre_pre_cooldown_accounts(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["AccountIndex"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetPrePreCooldownAccounts",
            block_hash_input,
            AccountIndex,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_baker_earliest_win_time(
        self,
        baker_id: "BakerId",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "Timestamp":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetBakerEarliestWinTime",
            baker_id,
            Timestamp,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def shutdown(
        self,
        empty: "Empty",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "Empty":
        return await self._unary_unary(
            "/concordium.v2.Queries/Shutdown",
            empty,
            Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def peer_connect(
        self,
        ip_socket_address: "IpSocketAddress",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "Empty":
        return await self._unary_unary(
            "/concordium.v2.Queries/PeerConnect",
            ip_socket_address,
            Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def peer_disconnect(
        self,
        ip_socket_address: "IpSocketAddress",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "Empty":
        return await self._unary_unary(
            "/concordium.v2.Queries/PeerDisconnect",
            ip_socket_address,
            Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_banned_peers(
        self,
        empty: "Empty",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BannedPeers":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetBannedPeers",
            empty,
            BannedPeers,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def ban_peer(
        self,
        peer_to_ban: "PeerToBan",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "Empty":
        return await self._unary_unary(
            "/concordium.v2.Queries/BanPeer",
            peer_to_ban,
            Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def unban_peer(
        self,
        banned_peer: "BannedPeer",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "Empty":
        return await self._unary_unary(
            "/concordium.v2.Queries/UnbanPeer",
            banned_peer,
            Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def dump_start(
        self,
        dump_request: "DumpRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "Empty":
        return await self._unary_unary(
            "/concordium.v2.Queries/DumpStart",
            dump_request,
            Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def dump_stop(
        self,
        empty: "Empty",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "Empty":
        return await self._unary_unary(
            "/concordium.v2.Queries/DumpStop",
            empty,
            Empty,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_peers_info(
        self,
        empty: "Empty",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "PeersInfo":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetPeersInfo",
            empty,
            PeersInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_node_info(
        self,
        empty: "Empty",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "NodeInfo":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetNodeInfo",
            empty,
            NodeInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def send_block_item(
        self,
        send_block_item_request: "SendBlockItemRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "TransactionHash":
        return await self._unary_unary(
            "/concordium.v2.Queries/SendBlockItem",
            send_block_item_request,
            TransactionHash,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_account_transaction_sign_hash(
        self,
        pre_account_transaction: "PreAccountTransaction",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AccountTransactionSignHash":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetAccountTransactionSignHash",
            pre_account_transaction,
            AccountTransactionSignHash,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_block_chain_parameters(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ChainParameters":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetBlockChainParameters",
            block_hash_input,
            ChainParameters,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_block_finalization_summary(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BlockFinalizationSummary":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetBlockFinalizationSummary",
            block_hash_input,
            BlockFinalizationSummary,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_block_items(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["BlockItem"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetBlockItems",
            block_hash_input,
            BlockItem,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_bakers_reward_period(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["BakerRewardPeriodInfo"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetBakersRewardPeriod",
            block_hash_input,
            BakerRewardPeriodInfo,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_block_certificates(
        self,
        block_hash_input: "BlockHashInput",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BlockCertificates":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetBlockCertificates",
            block_hash_input,
            BlockCertificates,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_winning_bakers_epoch(
        self,
        epoch_request: "EpochRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["WinningBaker"]:
        async for response in self._unary_stream(
            "/concordium.v2.Queries/GetWinningBakersEpoch",
            epoch_request,
            WinningBaker,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response

    async def get_first_block_epoch(
        self,
        epoch_request: "EpochRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "BlockHash":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetFirstBlockEpoch",
            epoch_request,
            BlockHash,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_consensus_detailed_status(
        self,
        consensus_detailed_status_query: "ConsensusDetailedStatusQuery",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ConsensusDetailedStatus":
        return await self._unary_unary(
            "/concordium.v2.Queries/GetConsensusDetailedStatus",
            consensus_detailed_status_query,
            ConsensusDetailedStatus,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def dry_run(
        self,
        dry_run_request_iterator: Union[
            AsyncIterable["DryRunRequest"], Iterable["DryRunRequest"]
        ],
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator["DryRunResponse"]:
        async for response in self._stream_stream(
            "/concordium.v2.Queries/DryRun",
            dry_run_request_iterator,
            DryRunRequest,
            DryRunResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class QueriesBase(ServiceBase):

    async def get_blocks(self, empty: "Empty") -> AsyncIterator["ArrivedBlockInfo"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ArrivedBlockInfo()

    async def get_finalized_blocks(
        self, empty: "Empty"
    ) -> AsyncIterator["FinalizedBlockInfo"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield FinalizedBlockInfo()

    async def get_account_info(
        self, account_info_request: "AccountInfoRequest"
    ) -> "AccountInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_account_list(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["AccountAddress"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield AccountAddress()

    async def get_module_list(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["ModuleRef"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ModuleRef()

    async def get_ancestors(
        self, ancestors_request: "AncestorsRequest"
    ) -> AsyncIterator["BlockHash"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield BlockHash()

    async def get_module_source(
        self, module_source_request: "ModuleSourceRequest"
    ) -> "VersionedModuleSource":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_instance_list(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["ContractAddress"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ContractAddress()

    async def get_instance_info(
        self, instance_info_request: "InstanceInfoRequest"
    ) -> "InstanceInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_instance_state(
        self, instance_info_request: "InstanceInfoRequest"
    ) -> AsyncIterator["InstanceStateKvPair"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield InstanceStateKvPair()

    async def instance_state_lookup(
        self, instance_state_lookup_request: "InstanceStateLookupRequest"
    ) -> "InstanceStateValueAtKey":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_next_account_sequence_number(
        self, account_address: "AccountAddress"
    ) -> "NextAccountSequenceNumber":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_consensus_info(self, empty: "Empty") -> "ConsensusInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_block_item_status(
        self, transaction_hash: "TransactionHash"
    ) -> "BlockItemStatus":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_cryptographic_parameters(
        self, block_hash_input: "BlockHashInput"
    ) -> "CryptographicParameters":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_block_info(self, block_hash_input: "BlockHashInput") -> "BlockInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_baker_list(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["BakerId"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield BakerId()

    async def get_pool_info(
        self, pool_info_request: "PoolInfoRequest"
    ) -> "PoolInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_passive_delegation_info(
        self, block_hash_input: "BlockHashInput"
    ) -> "PassiveDelegationInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_blocks_at_height(
        self, blocks_at_height_request: "BlocksAtHeightRequest"
    ) -> "BlocksAtHeightResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_tokenomics_info(
        self, block_hash_input: "BlockHashInput"
    ) -> "TokenomicsInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def invoke_instance(
        self, invoke_instance_request: "InvokeInstanceRequest"
    ) -> "InvokeInstanceResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_pool_delegators(
        self, get_pool_delegators_request: "GetPoolDelegatorsRequest"
    ) -> AsyncIterator["DelegatorInfo"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DelegatorInfo()

    async def get_pool_delegators_reward_period(
        self, get_pool_delegators_request: "GetPoolDelegatorsRequest"
    ) -> AsyncIterator["DelegatorRewardPeriodInfo"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DelegatorRewardPeriodInfo()

    async def get_passive_delegators(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["DelegatorInfo"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DelegatorInfo()

    async def get_passive_delegators_reward_period(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["DelegatorRewardPeriodInfo"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DelegatorRewardPeriodInfo()

    async def get_branches(self, empty: "Empty") -> "Branch":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_election_info(
        self, block_hash_input: "BlockHashInput"
    ) -> "ElectionInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_identity_providers(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["IpInfo"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield IpInfo()

    async def get_anonymity_revokers(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["ArInfo"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ArInfo()

    async def get_account_non_finalized_transactions(
        self, account_address: "AccountAddress"
    ) -> AsyncIterator["TransactionHash"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield TransactionHash()

    async def get_block_transaction_events(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["BlockItemSummary"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield BlockItemSummary()

    async def get_block_special_events(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["BlockSpecialEvent"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield BlockSpecialEvent()

    async def get_block_pending_updates(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["PendingUpdate"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield PendingUpdate()

    async def get_next_update_sequence_numbers(
        self, block_hash_input: "BlockHashInput"
    ) -> "NextUpdateSequenceNumbers":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_scheduled_release_accounts(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["AccountPending"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield AccountPending()

    async def get_cooldown_accounts(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["AccountPending"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield AccountPending()

    async def get_pre_cooldown_accounts(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["AccountIndex"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield AccountIndex()

    async def get_pre_pre_cooldown_accounts(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["AccountIndex"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield AccountIndex()

    async def get_baker_earliest_win_time(self, baker_id: "BakerId") -> "Timestamp":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def shutdown(self, empty: "Empty") -> "Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def peer_connect(self, ip_socket_address: "IpSocketAddress") -> "Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def peer_disconnect(self, ip_socket_address: "IpSocketAddress") -> "Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_banned_peers(self, empty: "Empty") -> "BannedPeers":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def ban_peer(self, peer_to_ban: "PeerToBan") -> "Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def unban_peer(self, banned_peer: "BannedPeer") -> "Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def dump_start(self, dump_request: "DumpRequest") -> "Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def dump_stop(self, empty: "Empty") -> "Empty":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_peers_info(self, empty: "Empty") -> "PeersInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_node_info(self, empty: "Empty") -> "NodeInfo":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_block_item(
        self, send_block_item_request: "SendBlockItemRequest"
    ) -> "TransactionHash":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_account_transaction_sign_hash(
        self, pre_account_transaction: "PreAccountTransaction"
    ) -> "AccountTransactionSignHash":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_block_chain_parameters(
        self, block_hash_input: "BlockHashInput"
    ) -> "ChainParameters":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_block_finalization_summary(
        self, block_hash_input: "BlockHashInput"
    ) -> "BlockFinalizationSummary":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_block_items(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["BlockItem"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield BlockItem()

    async def get_bakers_reward_period(
        self, block_hash_input: "BlockHashInput"
    ) -> AsyncIterator["BakerRewardPeriodInfo"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield BakerRewardPeriodInfo()

    async def get_block_certificates(
        self, block_hash_input: "BlockHashInput"
    ) -> "BlockCertificates":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_winning_bakers_epoch(
        self, epoch_request: "EpochRequest"
    ) -> AsyncIterator["WinningBaker"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield WinningBaker()

    async def get_first_block_epoch(self, epoch_request: "EpochRequest") -> "BlockHash":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_consensus_detailed_status(
        self, consensus_detailed_status_query: "ConsensusDetailedStatusQuery"
    ) -> "ConsensusDetailedStatus":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def dry_run(
        self, dry_run_request_iterator: AsyncIterator["DryRunRequest"]
    ) -> AsyncIterator["DryRunResponse"]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield DryRunResponse()

    async def __rpc_get_blocks(
        self, stream: "grpclib.server.Stream[Empty, ArrivedBlockInfo]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_blocks,
            stream,
            request,
        )

    async def __rpc_get_finalized_blocks(
        self, stream: "grpclib.server.Stream[Empty, FinalizedBlockInfo]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_finalized_blocks,
            stream,
            request,
        )

    async def __rpc_get_account_info(
        self, stream: "grpclib.server.Stream[AccountInfoRequest, AccountInfo]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_account_info(request)
        await stream.send_message(response)

    async def __rpc_get_account_list(
        self, stream: "grpclib.server.Stream[BlockHashInput, AccountAddress]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_account_list,
            stream,
            request,
        )

    async def __rpc_get_module_list(
        self, stream: "grpclib.server.Stream[BlockHashInput, ModuleRef]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_module_list,
            stream,
            request,
        )

    async def __rpc_get_ancestors(
        self, stream: "grpclib.server.Stream[AncestorsRequest, BlockHash]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_ancestors,
            stream,
            request,
        )

    async def __rpc_get_module_source(
        self,
        stream: "grpclib.server.Stream[ModuleSourceRequest, VersionedModuleSource]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_module_source(request)
        await stream.send_message(response)

    async def __rpc_get_instance_list(
        self, stream: "grpclib.server.Stream[BlockHashInput, ContractAddress]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_instance_list,
            stream,
            request,
        )

    async def __rpc_get_instance_info(
        self, stream: "grpclib.server.Stream[InstanceInfoRequest, InstanceInfo]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_instance_info(request)
        await stream.send_message(response)

    async def __rpc_get_instance_state(
        self, stream: "grpclib.server.Stream[InstanceInfoRequest, InstanceStateKvPair]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_instance_state,
            stream,
            request,
        )

    async def __rpc_instance_state_lookup(
        self,
        stream: "grpclib.server.Stream[InstanceStateLookupRequest, InstanceStateValueAtKey]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.instance_state_lookup(request)
        await stream.send_message(response)

    async def __rpc_get_next_account_sequence_number(
        self, stream: "grpclib.server.Stream[AccountAddress, NextAccountSequenceNumber]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_next_account_sequence_number(request)
        await stream.send_message(response)

    async def __rpc_get_consensus_info(
        self, stream: "grpclib.server.Stream[Empty, ConsensusInfo]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_consensus_info(request)
        await stream.send_message(response)

    async def __rpc_get_block_item_status(
        self, stream: "grpclib.server.Stream[TransactionHash, BlockItemStatus]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_block_item_status(request)
        await stream.send_message(response)

    async def __rpc_get_cryptographic_parameters(
        self, stream: "grpclib.server.Stream[BlockHashInput, CryptographicParameters]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_cryptographic_parameters(request)
        await stream.send_message(response)

    async def __rpc_get_block_info(
        self, stream: "grpclib.server.Stream[BlockHashInput, BlockInfo]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_block_info(request)
        await stream.send_message(response)

    async def __rpc_get_baker_list(
        self, stream: "grpclib.server.Stream[BlockHashInput, BakerId]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_baker_list,
            stream,
            request,
        )

    async def __rpc_get_pool_info(
        self, stream: "grpclib.server.Stream[PoolInfoRequest, PoolInfoResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_pool_info(request)
        await stream.send_message(response)

    async def __rpc_get_passive_delegation_info(
        self, stream: "grpclib.server.Stream[BlockHashInput, PassiveDelegationInfo]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_passive_delegation_info(request)
        await stream.send_message(response)

    async def __rpc_get_blocks_at_height(
        self,
        stream: "grpclib.server.Stream[BlocksAtHeightRequest, BlocksAtHeightResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_blocks_at_height(request)
        await stream.send_message(response)

    async def __rpc_get_tokenomics_info(
        self, stream: "grpclib.server.Stream[BlockHashInput, TokenomicsInfo]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_tokenomics_info(request)
        await stream.send_message(response)

    async def __rpc_invoke_instance(
        self,
        stream: "grpclib.server.Stream[InvokeInstanceRequest, InvokeInstanceResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.invoke_instance(request)
        await stream.send_message(response)

    async def __rpc_get_pool_delegators(
        self, stream: "grpclib.server.Stream[GetPoolDelegatorsRequest, DelegatorInfo]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_pool_delegators,
            stream,
            request,
        )

    async def __rpc_get_pool_delegators_reward_period(
        self,
        stream: "grpclib.server.Stream[GetPoolDelegatorsRequest, DelegatorRewardPeriodInfo]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_pool_delegators_reward_period,
            stream,
            request,
        )

    async def __rpc_get_passive_delegators(
        self, stream: "grpclib.server.Stream[BlockHashInput, DelegatorInfo]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_passive_delegators,
            stream,
            request,
        )

    async def __rpc_get_passive_delegators_reward_period(
        self, stream: "grpclib.server.Stream[BlockHashInput, DelegatorRewardPeriodInfo]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_passive_delegators_reward_period,
            stream,
            request,
        )

    async def __rpc_get_branches(
        self, stream: "grpclib.server.Stream[Empty, Branch]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_branches(request)
        await stream.send_message(response)

    async def __rpc_get_election_info(
        self, stream: "grpclib.server.Stream[BlockHashInput, ElectionInfo]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_election_info(request)
        await stream.send_message(response)

    async def __rpc_get_identity_providers(
        self, stream: "grpclib.server.Stream[BlockHashInput, IpInfo]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_identity_providers,
            stream,
            request,
        )

    async def __rpc_get_anonymity_revokers(
        self, stream: "grpclib.server.Stream[BlockHashInput, ArInfo]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_anonymity_revokers,
            stream,
            request,
        )

    async def __rpc_get_account_non_finalized_transactions(
        self, stream: "grpclib.server.Stream[AccountAddress, TransactionHash]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_account_non_finalized_transactions,
            stream,
            request,
        )

    async def __rpc_get_block_transaction_events(
        self, stream: "grpclib.server.Stream[BlockHashInput, BlockItemSummary]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_block_transaction_events,
            stream,
            request,
        )

    async def __rpc_get_block_special_events(
        self, stream: "grpclib.server.Stream[BlockHashInput, BlockSpecialEvent]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_block_special_events,
            stream,
            request,
        )

    async def __rpc_get_block_pending_updates(
        self, stream: "grpclib.server.Stream[BlockHashInput, PendingUpdate]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_block_pending_updates,
            stream,
            request,
        )

    async def __rpc_get_next_update_sequence_numbers(
        self, stream: "grpclib.server.Stream[BlockHashInput, NextUpdateSequenceNumbers]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_next_update_sequence_numbers(request)
        await stream.send_message(response)

    async def __rpc_get_scheduled_release_accounts(
        self, stream: "grpclib.server.Stream[BlockHashInput, AccountPending]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_scheduled_release_accounts,
            stream,
            request,
        )

    async def __rpc_get_cooldown_accounts(
        self, stream: "grpclib.server.Stream[BlockHashInput, AccountPending]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_cooldown_accounts,
            stream,
            request,
        )

    async def __rpc_get_pre_cooldown_accounts(
        self, stream: "grpclib.server.Stream[BlockHashInput, AccountIndex]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_pre_cooldown_accounts,
            stream,
            request,
        )

    async def __rpc_get_pre_pre_cooldown_accounts(
        self, stream: "grpclib.server.Stream[BlockHashInput, AccountIndex]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_pre_pre_cooldown_accounts,
            stream,
            request,
        )

    async def __rpc_get_baker_earliest_win_time(
        self, stream: "grpclib.server.Stream[BakerId, Timestamp]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_baker_earliest_win_time(request)
        await stream.send_message(response)

    async def __rpc_shutdown(
        self, stream: "grpclib.server.Stream[Empty, Empty]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.shutdown(request)
        await stream.send_message(response)

    async def __rpc_peer_connect(
        self, stream: "grpclib.server.Stream[IpSocketAddress, Empty]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.peer_connect(request)
        await stream.send_message(response)

    async def __rpc_peer_disconnect(
        self, stream: "grpclib.server.Stream[IpSocketAddress, Empty]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.peer_disconnect(request)
        await stream.send_message(response)

    async def __rpc_get_banned_peers(
        self, stream: "grpclib.server.Stream[Empty, BannedPeers]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_banned_peers(request)
        await stream.send_message(response)

    async def __rpc_ban_peer(
        self, stream: "grpclib.server.Stream[PeerToBan, Empty]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.ban_peer(request)
        await stream.send_message(response)

    async def __rpc_unban_peer(
        self, stream: "grpclib.server.Stream[BannedPeer, Empty]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.unban_peer(request)
        await stream.send_message(response)

    async def __rpc_dump_start(
        self, stream: "grpclib.server.Stream[DumpRequest, Empty]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.dump_start(request)
        await stream.send_message(response)

    async def __rpc_dump_stop(
        self, stream: "grpclib.server.Stream[Empty, Empty]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.dump_stop(request)
        await stream.send_message(response)

    async def __rpc_get_peers_info(
        self, stream: "grpclib.server.Stream[Empty, PeersInfo]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_peers_info(request)
        await stream.send_message(response)

    async def __rpc_get_node_info(
        self, stream: "grpclib.server.Stream[Empty, NodeInfo]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_node_info(request)
        await stream.send_message(response)

    async def __rpc_send_block_item(
        self, stream: "grpclib.server.Stream[SendBlockItemRequest, TransactionHash]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.send_block_item(request)
        await stream.send_message(response)

    async def __rpc_get_account_transaction_sign_hash(
        self,
        stream: "grpclib.server.Stream[PreAccountTransaction, AccountTransactionSignHash]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_account_transaction_sign_hash(request)
        await stream.send_message(response)

    async def __rpc_get_block_chain_parameters(
        self, stream: "grpclib.server.Stream[BlockHashInput, ChainParameters]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_block_chain_parameters(request)
        await stream.send_message(response)

    async def __rpc_get_block_finalization_summary(
        self, stream: "grpclib.server.Stream[BlockHashInput, BlockFinalizationSummary]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_block_finalization_summary(request)
        await stream.send_message(response)

    async def __rpc_get_block_items(
        self, stream: "grpclib.server.Stream[BlockHashInput, BlockItem]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_block_items,
            stream,
            request,
        )

    async def __rpc_get_bakers_reward_period(
        self, stream: "grpclib.server.Stream[BlockHashInput, BakerRewardPeriodInfo]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_bakers_reward_period,
            stream,
            request,
        )

    async def __rpc_get_block_certificates(
        self, stream: "grpclib.server.Stream[BlockHashInput, BlockCertificates]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_block_certificates(request)
        await stream.send_message(response)

    async def __rpc_get_winning_bakers_epoch(
        self, stream: "grpclib.server.Stream[EpochRequest, WinningBaker]"
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.get_winning_bakers_epoch,
            stream,
            request,
        )

    async def __rpc_get_first_block_epoch(
        self, stream: "grpclib.server.Stream[EpochRequest, BlockHash]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_first_block_epoch(request)
        await stream.send_message(response)

    async def __rpc_get_consensus_detailed_status(
        self,
        stream: "grpclib.server.Stream[ConsensusDetailedStatusQuery, ConsensusDetailedStatus]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_consensus_detailed_status(request)
        await stream.send_message(response)

    async def __rpc_dry_run(
        self, stream: "grpclib.server.Stream[DryRunRequest, DryRunResponse]"
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.dry_run,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/concordium.v2.Queries/GetBlocks": grpclib.const.Handler(
                self.__rpc_get_blocks,
                grpclib.const.Cardinality.UNARY_STREAM,
                Empty,
                ArrivedBlockInfo,
            ),
            "/concordium.v2.Queries/GetFinalizedBlocks": grpclib.const.Handler(
                self.__rpc_get_finalized_blocks,
                grpclib.const.Cardinality.UNARY_STREAM,
                Empty,
                FinalizedBlockInfo,
            ),
            "/concordium.v2.Queries/GetAccountInfo": grpclib.const.Handler(
                self.__rpc_get_account_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                AccountInfoRequest,
                AccountInfo,
            ),
            "/concordium.v2.Queries/GetAccountList": grpclib.const.Handler(
                self.__rpc_get_account_list,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                AccountAddress,
            ),
            "/concordium.v2.Queries/GetModuleList": grpclib.const.Handler(
                self.__rpc_get_module_list,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                ModuleRef,
            ),
            "/concordium.v2.Queries/GetAncestors": grpclib.const.Handler(
                self.__rpc_get_ancestors,
                grpclib.const.Cardinality.UNARY_STREAM,
                AncestorsRequest,
                BlockHash,
            ),
            "/concordium.v2.Queries/GetModuleSource": grpclib.const.Handler(
                self.__rpc_get_module_source,
                grpclib.const.Cardinality.UNARY_UNARY,
                ModuleSourceRequest,
                VersionedModuleSource,
            ),
            "/concordium.v2.Queries/GetInstanceList": grpclib.const.Handler(
                self.__rpc_get_instance_list,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                ContractAddress,
            ),
            "/concordium.v2.Queries/GetInstanceInfo": grpclib.const.Handler(
                self.__rpc_get_instance_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                InstanceInfoRequest,
                InstanceInfo,
            ),
            "/concordium.v2.Queries/GetInstanceState": grpclib.const.Handler(
                self.__rpc_get_instance_state,
                grpclib.const.Cardinality.UNARY_STREAM,
                InstanceInfoRequest,
                InstanceStateKvPair,
            ),
            "/concordium.v2.Queries/InstanceStateLookup": grpclib.const.Handler(
                self.__rpc_instance_state_lookup,
                grpclib.const.Cardinality.UNARY_UNARY,
                InstanceStateLookupRequest,
                InstanceStateValueAtKey,
            ),
            "/concordium.v2.Queries/GetNextAccountSequenceNumber": grpclib.const.Handler(
                self.__rpc_get_next_account_sequence_number,
                grpclib.const.Cardinality.UNARY_UNARY,
                AccountAddress,
                NextAccountSequenceNumber,
            ),
            "/concordium.v2.Queries/GetConsensusInfo": grpclib.const.Handler(
                self.__rpc_get_consensus_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                Empty,
                ConsensusInfo,
            ),
            "/concordium.v2.Queries/GetBlockItemStatus": grpclib.const.Handler(
                self.__rpc_get_block_item_status,
                grpclib.const.Cardinality.UNARY_UNARY,
                TransactionHash,
                BlockItemStatus,
            ),
            "/concordium.v2.Queries/GetCryptographicParameters": grpclib.const.Handler(
                self.__rpc_get_cryptographic_parameters,
                grpclib.const.Cardinality.UNARY_UNARY,
                BlockHashInput,
                CryptographicParameters,
            ),
            "/concordium.v2.Queries/GetBlockInfo": grpclib.const.Handler(
                self.__rpc_get_block_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                BlockHashInput,
                BlockInfo,
            ),
            "/concordium.v2.Queries/GetBakerList": grpclib.const.Handler(
                self.__rpc_get_baker_list,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                BakerId,
            ),
            "/concordium.v2.Queries/GetPoolInfo": grpclib.const.Handler(
                self.__rpc_get_pool_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                PoolInfoRequest,
                PoolInfoResponse,
            ),
            "/concordium.v2.Queries/GetPassiveDelegationInfo": grpclib.const.Handler(
                self.__rpc_get_passive_delegation_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                BlockHashInput,
                PassiveDelegationInfo,
            ),
            "/concordium.v2.Queries/GetBlocksAtHeight": grpclib.const.Handler(
                self.__rpc_get_blocks_at_height,
                grpclib.const.Cardinality.UNARY_UNARY,
                BlocksAtHeightRequest,
                BlocksAtHeightResponse,
            ),
            "/concordium.v2.Queries/GetTokenomicsInfo": grpclib.const.Handler(
                self.__rpc_get_tokenomics_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                BlockHashInput,
                TokenomicsInfo,
            ),
            "/concordium.v2.Queries/InvokeInstance": grpclib.const.Handler(
                self.__rpc_invoke_instance,
                grpclib.const.Cardinality.UNARY_UNARY,
                InvokeInstanceRequest,
                InvokeInstanceResponse,
            ),
            "/concordium.v2.Queries/GetPoolDelegators": grpclib.const.Handler(
                self.__rpc_get_pool_delegators,
                grpclib.const.Cardinality.UNARY_STREAM,
                GetPoolDelegatorsRequest,
                DelegatorInfo,
            ),
            "/concordium.v2.Queries/GetPoolDelegatorsRewardPeriod": grpclib.const.Handler(
                self.__rpc_get_pool_delegators_reward_period,
                grpclib.const.Cardinality.UNARY_STREAM,
                GetPoolDelegatorsRequest,
                DelegatorRewardPeriodInfo,
            ),
            "/concordium.v2.Queries/GetPassiveDelegators": grpclib.const.Handler(
                self.__rpc_get_passive_delegators,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                DelegatorInfo,
            ),
            "/concordium.v2.Queries/GetPassiveDelegatorsRewardPeriod": grpclib.const.Handler(
                self.__rpc_get_passive_delegators_reward_period,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                DelegatorRewardPeriodInfo,
            ),
            "/concordium.v2.Queries/GetBranches": grpclib.const.Handler(
                self.__rpc_get_branches,
                grpclib.const.Cardinality.UNARY_UNARY,
                Empty,
                Branch,
            ),
            "/concordium.v2.Queries/GetElectionInfo": grpclib.const.Handler(
                self.__rpc_get_election_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                BlockHashInput,
                ElectionInfo,
            ),
            "/concordium.v2.Queries/GetIdentityProviders": grpclib.const.Handler(
                self.__rpc_get_identity_providers,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                IpInfo,
            ),
            "/concordium.v2.Queries/GetAnonymityRevokers": grpclib.const.Handler(
                self.__rpc_get_anonymity_revokers,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                ArInfo,
            ),
            "/concordium.v2.Queries/GetAccountNonFinalizedTransactions": grpclib.const.Handler(
                self.__rpc_get_account_non_finalized_transactions,
                grpclib.const.Cardinality.UNARY_STREAM,
                AccountAddress,
                TransactionHash,
            ),
            "/concordium.v2.Queries/GetBlockTransactionEvents": grpclib.const.Handler(
                self.__rpc_get_block_transaction_events,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                BlockItemSummary,
            ),
            "/concordium.v2.Queries/GetBlockSpecialEvents": grpclib.const.Handler(
                self.__rpc_get_block_special_events,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                BlockSpecialEvent,
            ),
            "/concordium.v2.Queries/GetBlockPendingUpdates": grpclib.const.Handler(
                self.__rpc_get_block_pending_updates,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                PendingUpdate,
            ),
            "/concordium.v2.Queries/GetNextUpdateSequenceNumbers": grpclib.const.Handler(
                self.__rpc_get_next_update_sequence_numbers,
                grpclib.const.Cardinality.UNARY_UNARY,
                BlockHashInput,
                NextUpdateSequenceNumbers,
            ),
            "/concordium.v2.Queries/GetScheduledReleaseAccounts": grpclib.const.Handler(
                self.__rpc_get_scheduled_release_accounts,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                AccountPending,
            ),
            "/concordium.v2.Queries/GetCooldownAccounts": grpclib.const.Handler(
                self.__rpc_get_cooldown_accounts,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                AccountPending,
            ),
            "/concordium.v2.Queries/GetPreCooldownAccounts": grpclib.const.Handler(
                self.__rpc_get_pre_cooldown_accounts,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                AccountIndex,
            ),
            "/concordium.v2.Queries/GetPrePreCooldownAccounts": grpclib.const.Handler(
                self.__rpc_get_pre_pre_cooldown_accounts,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                AccountIndex,
            ),
            "/concordium.v2.Queries/GetBakerEarliestWinTime": grpclib.const.Handler(
                self.__rpc_get_baker_earliest_win_time,
                grpclib.const.Cardinality.UNARY_UNARY,
                BakerId,
                Timestamp,
            ),
            "/concordium.v2.Queries/Shutdown": grpclib.const.Handler(
                self.__rpc_shutdown,
                grpclib.const.Cardinality.UNARY_UNARY,
                Empty,
                Empty,
            ),
            "/concordium.v2.Queries/PeerConnect": grpclib.const.Handler(
                self.__rpc_peer_connect,
                grpclib.const.Cardinality.UNARY_UNARY,
                IpSocketAddress,
                Empty,
            ),
            "/concordium.v2.Queries/PeerDisconnect": grpclib.const.Handler(
                self.__rpc_peer_disconnect,
                grpclib.const.Cardinality.UNARY_UNARY,
                IpSocketAddress,
                Empty,
            ),
            "/concordium.v2.Queries/GetBannedPeers": grpclib.const.Handler(
                self.__rpc_get_banned_peers,
                grpclib.const.Cardinality.UNARY_UNARY,
                Empty,
                BannedPeers,
            ),
            "/concordium.v2.Queries/BanPeer": grpclib.const.Handler(
                self.__rpc_ban_peer,
                grpclib.const.Cardinality.UNARY_UNARY,
                PeerToBan,
                Empty,
            ),
            "/concordium.v2.Queries/UnbanPeer": grpclib.const.Handler(
                self.__rpc_unban_peer,
                grpclib.const.Cardinality.UNARY_UNARY,
                BannedPeer,
                Empty,
            ),
            "/concordium.v2.Queries/DumpStart": grpclib.const.Handler(
                self.__rpc_dump_start,
                grpclib.const.Cardinality.UNARY_UNARY,
                DumpRequest,
                Empty,
            ),
            "/concordium.v2.Queries/DumpStop": grpclib.const.Handler(
                self.__rpc_dump_stop,
                grpclib.const.Cardinality.UNARY_UNARY,
                Empty,
                Empty,
            ),
            "/concordium.v2.Queries/GetPeersInfo": grpclib.const.Handler(
                self.__rpc_get_peers_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                Empty,
                PeersInfo,
            ),
            "/concordium.v2.Queries/GetNodeInfo": grpclib.const.Handler(
                self.__rpc_get_node_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                Empty,
                NodeInfo,
            ),
            "/concordium.v2.Queries/SendBlockItem": grpclib.const.Handler(
                self.__rpc_send_block_item,
                grpclib.const.Cardinality.UNARY_UNARY,
                SendBlockItemRequest,
                TransactionHash,
            ),
            "/concordium.v2.Queries/GetAccountTransactionSignHash": grpclib.const.Handler(
                self.__rpc_get_account_transaction_sign_hash,
                grpclib.const.Cardinality.UNARY_UNARY,
                PreAccountTransaction,
                AccountTransactionSignHash,
            ),
            "/concordium.v2.Queries/GetBlockChainParameters": grpclib.const.Handler(
                self.__rpc_get_block_chain_parameters,
                grpclib.const.Cardinality.UNARY_UNARY,
                BlockHashInput,
                ChainParameters,
            ),
            "/concordium.v2.Queries/GetBlockFinalizationSummary": grpclib.const.Handler(
                self.__rpc_get_block_finalization_summary,
                grpclib.const.Cardinality.UNARY_UNARY,
                BlockHashInput,
                BlockFinalizationSummary,
            ),
            "/concordium.v2.Queries/GetBlockItems": grpclib.const.Handler(
                self.__rpc_get_block_items,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                BlockItem,
            ),
            "/concordium.v2.Queries/GetBakersRewardPeriod": grpclib.const.Handler(
                self.__rpc_get_bakers_reward_period,
                grpclib.const.Cardinality.UNARY_STREAM,
                BlockHashInput,
                BakerRewardPeriodInfo,
            ),
            "/concordium.v2.Queries/GetBlockCertificates": grpclib.const.Handler(
                self.__rpc_get_block_certificates,
                grpclib.const.Cardinality.UNARY_UNARY,
                BlockHashInput,
                BlockCertificates,
            ),
            "/concordium.v2.Queries/GetWinningBakersEpoch": grpclib.const.Handler(
                self.__rpc_get_winning_bakers_epoch,
                grpclib.const.Cardinality.UNARY_STREAM,
                EpochRequest,
                WinningBaker,
            ),
            "/concordium.v2.Queries/GetFirstBlockEpoch": grpclib.const.Handler(
                self.__rpc_get_first_block_epoch,
                grpclib.const.Cardinality.UNARY_UNARY,
                EpochRequest,
                BlockHash,
            ),
            "/concordium.v2.Queries/GetConsensusDetailedStatus": grpclib.const.Handler(
                self.__rpc_get_consensus_detailed_status,
                grpclib.const.Cardinality.UNARY_UNARY,
                ConsensusDetailedStatusQuery,
                ConsensusDetailedStatus,
            ),
            "/concordium.v2.Queries/DryRun": grpclib.const.Handler(
                self.__rpc_dry_run,
                grpclib.const.Cardinality.STREAM_STREAM,
                DryRunRequest,
                DryRunResponse,
            ),
        }
