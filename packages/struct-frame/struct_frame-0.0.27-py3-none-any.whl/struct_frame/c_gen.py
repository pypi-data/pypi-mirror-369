#!/usr/bin/env python3
# kate: replace-tabs on; indent-width 4;

from struct_frame import version, NamingStyleC, CamelToSnakeCase, pascalCase
import time

StyleC = NamingStyleC()

c_types = {"uint8": "uint8_t",
           "int8": "int8_t",
           "uint16": "uint16_t",
           "int16": "int16_t",
           "uint32": "uint32_t",
           "int32": "int32_t",
           "bool": "bool",
           "float": "float",
           "double": "double",
           "uint64": 'uint64_t',
           "int64":  'int64_t',
           }


class EnumCGen():
    @staticmethod
    def generate(field):
        leading_comment = field.comments

        result = ''
        if leading_comment:
            for c in leading_comment:
                result = '%s\n' % c

        enumName = '%s%s' % (pascalCase(field.package), field.name)
        result += 'typedef enum %s' % (enumName)

        result += ' {\n'

        enum_length = len(field.data)
        enum_values = []
        for index, (d) in enumerate(field.data):
            leading_comment = field.data[d][1]

            if leading_comment:
                for c in leading_comment:
                    enum_values.append(c)

            comma = ","
            if index == enum_length - 1:
                # last enum member should not end with a comma
                comma = ""

            enum_value = "    %s_%s = %d%s" % (CamelToSnakeCase(
                field.name).upper(), StyleC.enum_entry(d), field.data[d][0], comma)

            enum_values.append(enum_value)

        result += '\n'.join(enum_values)
        result += '\n}'

        result += ' %s;\n' % (enumName)

        result += 'typedef uint8_t %s_t;' % (enumName)
        return result


class FieldCGen():
    @staticmethod
    def generate(field):
        result = ''

        var_name = field.name
        type_name = field.fieldType
        if type_name in c_types:
            type_name = c_types[type_name]
        else:
            type_name = '%s%s' % (pascalCase(field.package), type_name)
            if field.isEnum:
                type_name = '%s_t' % type_name

        result += '    %s %s%s;' % (type_name, var_name, "")

        leading_comment = field.comments
        if leading_comment:
            for c in leading_comment:
                result = c + "\n" + result

        return result


class MessageCGen():
    @staticmethod
    def generate(msg):
        leading_comment = msg.comments

        result = ''
        if leading_comment:
            for c in msg.comments:
                result = '%s\n' % c

        structName = '%s%s' % (pascalCase(msg.package), msg.name)
        result += 'typedef struct %s {' % structName

        result += '\n'

        size = 1
        if not msg.fields:
            # Empty structs are not allowed in C standard.
            # Therefore add a dummy field if an empty message occurs.
            result += '    char dummy_field;'
        else:
            size = msg.size

        result += '\n'.join([FieldCGen.generate(f)
                            for key, f in msg.fields.items()])
        result += '\n}'
        result += ' %s;\n\n' % structName

        defineName = '%s_%s' % (CamelToSnakeCase(
            msg.package).upper(), CamelToSnakeCase(msg.name).upper())
        result += '#define %s_MAX_SIZE %d\n' % (defineName, size)

        if msg.id:
            result += '#define %s_MSG_ID %d\n' % (defineName, msg.id)

        funcName = defineName.lower()
        if msg.id:
            result += 'MESSAGE_HELPER(%s, %s, %d, %d);\n\n' % (funcName, structName,
                                                               size, msg.id)

        return result + '\n'

    @staticmethod
    def get_initializer(msg, null_init):
        if not msg.fields:
            return '{0}'

        parts = []
        for field in msg.fields:
            parts.append(field.get_initializer(null_init))
        return '{' + ', '.join(parts) + '}'


class FileCGen():
    @staticmethod
    def generate(package):
        yield '/* Automatically generated struct frame header */\n'
        yield '/* Generated by %s at %s. */\n\n' % (version, time.asctime())

        yield '#pragma once\n'
        yield '#pragma pack(1)\n'

        yield '#include "struct_frame.h"\n'

        # include additional header files if available in the future

        if package.enums:
            yield '/* Enum definitions */\n'
            for key, enum in package.enums.items():
                yield EnumCGen.generate(enum) + '\n\n'

        if package.messages:
            yield '/* Struct definitions */\n'
            # Need to sort messages to make sure dependecies are properly met

            for key, msg in package.sortedMessages().items():
                yield MessageCGen.generate(msg) + '\n'
            yield '\n'

        # Add default initializers if needed
        # if package.messages:
        #    yield '/* Initializer values for message structs */\n'
        #    for key, msg in package.messages.items():
        #        identifier = '%s_%s_init_default' % (package.name, StyleC.struct_name(msg.name))
        #        yield '#define %-40s %s\n' % (identifier, MessageCGen.get_initializer(msg, False))
        #    for key, msg in package.messages.items():
        #        identifier = '%s_%s_init_zero' % (package.name, StyleC.struct_name(msg.name))
        #        yield '#define %-40s %s\n' % (identifier, msg.get_initializer(True))
        #    yield '\n'

        if package.messages:
            yield 'bool get_message_length(size_t msg_id, size_t* size){\n switch (msg_id)\n {\n'
            for key, msg in package.sortedMessages().items():
                name = '%s_%s' % (CamelToSnakeCase(
                    msg.package).upper(), CamelToSnakeCase(msg.name).upper())
                if msg.id:
                    yield '  case %s_MSG_ID: *size = %s_MAX_SIZE; return true;\n' % (name, name)

            yield '  default: break;\n } return false;\n}'
            yield '\n'
