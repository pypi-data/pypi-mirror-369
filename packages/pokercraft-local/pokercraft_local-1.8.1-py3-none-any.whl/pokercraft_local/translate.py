import typing
from enum import Enum

from .constants import POKERCRAFT_AHREF


class Language(Enum):
    ENGLISH = "en"
    KOREAN = "ko"

    def __lshift__(self, text: typing.Any) -> str:
        """
        Perform a translation on this text.
        """
        # lang << "text"
        if isinstance(text, str):
            if self is Language.ENGLISH:
                return text
            else:
                return TRANSLATION[self].get(text, text)
        else:
            raise TypeError("Only str is allowed for translation.")


def generate_summary_html(lang: Language, *kvs: tuple[str, typing.Any]) -> str:
    """
    Generate summary HTML.
    """
    head = f"| {lang << 'Category'} | {lang << 'Value'} |"
    hr = "| --- | --- |"
    rows = "\n".join(f"| {lang << k} | {v} |" for k, v in kvs)
    return "\n".join((head, hr, rows))


TITLE_FRAME: typing.Final[str] = "%s's realistic tournament performance on GGNetwork"
SOFTWARE_CREDITS_FRAME: typing.Final[str] = "Generated by %s provided by McDic"
RRE_PLOT_TITLE: typing.Final[str] = "Relative Prize Returns with Re-entries"
RRE_PLOT_SUBTITLE: typing.Final[str] = "(RRE = Prize / Buy-in / (1 + Re-entries))"
BANKROLL_PLOT_TITLE: typing.Final[str] = (
    "Bankroll Analysis with " "Monte-Carlo Simulation based on RRs"
)
BANKROLL_PLOT_SUBTITLE: typing.Final[str] = (
    "This plot is calculated only if your performance is winning. "
    "(RR = Prize / Buy-in, PERR = Percentile * RR)"
)
PRIZE_PIE_CHART_TITLE: typing.Final[str] = "Your Prizes"
PRIZE_PIE_CHART_SUBTITLE: typing.Final[str] = "Small prizes are grouped as 'Others'."
GUI_EXPORTED_SUCCESS: typing.Final[str] = (
    "Exported CSV and plot successfully; "
    "Please check {csv_path} and {plot_path} in {output_dir}."
)

RR_RANK_CHART_TITLE: typing.Final[str] = "RR by Rank Percentile"
RR_RANK_CHART_SUBTITLE: typing.Final[str] = (
    "Only non-zero profits are shown. " "(RR = Prize / BuyIn, PERR = RR * Percentile)"
)
RR_RANK_CHART_HOVERTEMPLATE: typing.Final[str] = (
    "Got %{customdata[3]:.2f}x profit at top %{x:.3%}; "
    "PERR = %{customdata[4]:.3f}<br>"
    "Exact rank: #%{customdata[2]} of %{customdata[1]} entries<br>"
    "..from <i>%{customdata[0]}</i>"
)

# fmt: off
TRANSLATION: typing.Final[dict[Language, dict[str, str]]] = {
    Language.KOREAN: {
        # Title and credits
        TITLE_FRAME: "%s님의 GGNetwork 토너먼트에서의 현실적인 성적",
        SOFTWARE_CREDITS_FRAME: "McDic이 만든 %s에 의해 생성됨",
        # GUI
        "Select Language": "언어 선택",
        "Data Directory: %s": "선택된 데이터 폴더: %s",
        "Choose Data Directory": "데이터 폴더 선택",
        "Output Directory: %s": "분석파일 내보낼 폴더: %s",
        "Choose Output Directory": "분석파일 내보낼 폴더 선택",
        "Your GG nickname": "당신의 GG 닉네임",
        GUI_EXPORTED_SUCCESS: (
            "CSV와 그래프 파일이 성공적으로 생성되었습니다. "
            "{output_dir} 안에 있는 {csv_path}와 {plot_path}를 확인해주세요."
        ),
        "Nickname is not given.": "GG 닉네임이 입력되지 않았습니다.",
        "Data directory is not selected or invalid.": "데이터 폴더가 선택되지 않았거나 올바르지 않습니다.",
        "Output directory is not selected or invalid.": \
        "분석파일 내보낼 폴더가 선택되지 않았거나 올바르지 않습니다.",
        "Include Freerolls": "프리롤 포함하기",
        "Fetch the latest forex rate (May fail)": "최신 환율 반영하기 (실패할 수 있음)",
        "Export plot and CSV data (Enter)": "CSV랑 분석 파일 생성하기 (Enter 키)",
        # Head summary
        "Category": "카테고리",
        "Value": "값",
        "Paid Rake": "지불한 레이크",
        "Highest Buy In": "가장 비싼 바이인",
        # Historical Performance
        "Historical Performance": "과거 성적",
        "Tournament Count": "토너먼트 참가 횟수",
        "Net Profit & Rake": "순수익 & 레이크",
        "Profitable Ratio": "수익 보는 비율",
        "Average Buy In": "평균 바이인 금액",
        "Profits & Rakes": "수익 & 레이크",
        "Net Profit": "순수익 (레이크 고려)",
        "Net Rake": "지불한 레이크",
        "Max Drawdown": "고점 대비 최대 하락폭",
        "Ideal Profit w.o. Rake": "레이크 없을 때 이상적인 수익",
        "Since 0": "전체 기준",
        "Recent %d": "최근 %d개 토너 기준",
        "Break-even": "멘징 지점",
        "Current Net Profit": "현재 수익 지점",
        "Micro / Low": "마이크로 / 로우",
        "Low / Mid": "로우 / 미들",
        "Mid / High": "미들 / 하이롤러",
        "Tourney #%d": "%d번째 토너먼트 참가",
        # Relative Prize Returns
        RRE_PLOT_TITLE: "바인 금액 대비 상대적 리턴(리엔트리 고려)",
        RRE_PLOT_SUBTITLE: "(RRE = 상금 / 바인금액 / (1 + 리엔트리횟수))",
        "By Buy In Amount": "바인 금액별 분포",
        "By Total Entries": "엔트리수별 분포",
        "By Time of Day": "시간대별 분포",
        "Marginal RRE Distribution": "누적 RRE 분포",
        "RRE": "RRE",
        "RRE by Buy In": "바인 금액별 RRE",
        "RRE by Entries": "엔트리수별 RRE",
        "RRE by Time of Day": "시간대별 RRE",
        "Got %sx profit in this region": "이 구간에서 %s배 수익을 냄",
        "Buy In": "바인금액",
        "Total Entries": "총 엔트리 수",
        "Marginal RRE": "누적 RRE",
        "Break-even: 1x Profit": "멘징 지점: 1배 수익",
        "Good run: 4x Profit": "좋은 성적: 4배 수익",
        "Deep run: 32x Profit": "딥런: 32배 수익",
        # Bankroll Analysis
        BANKROLL_PLOT_TITLE: "RRs 기반 몬테카를로 시뮬레이션을 통한 뱅크롤 분석",
        BANKROLL_PLOT_SUBTITLE: "이 그래프는 당신의 성적이 수익적인 경우에만 계산됩니다. (RR = 상금 / 바인금액)",
        "Metric": "메트릭",
        "Initial Capital": "초기 자본",
        "Bankruptcy Rate": "파산 확률",
        "Survival Rate": "생존 확률",
        "%.1f Buy-ins": "%.1f 바이인",
        # Prize Pie Chart
        PRIZE_PIE_CHART_TITLE: "당신의 상금 분포",
        PRIZE_PIE_CHART_SUBTITLE: "작은 상금은 '기타'로 분류됩니다.",
        "Individual Prizes": "개별 상금",
        "Prizes by Weekday": "요일별 상금",
        "Mon": "월요일",
        "Tue": "화요일",
        "Wed": "수요일",
        "Thu": "목요일",
        "Fri": "금요일",
        "Sat": "토요일",
        "Sun": "일요일",
        "Others": "기타",
        # RR by Rank Percentile
        RR_RANK_CHART_TITLE: "순위 백분위별 RR",
        RR_RANK_CHART_SUBTITLE: "수익이 0이 아닌 토너만 표시됩니다. "
        "(RR = 상금 / 바인금액, PERR = 백분위 * RR)",
        RR_RANK_CHART_HOVERTEMPLATE: (
            "상금 %{customdata[3]:.2f} BI를 상위 %{x:.3%}에서 받음; "
            "PERR = %{customdata[4]:.3f}<br>"
            "순위: %{customdata[2]}등 / %{customdata[1]} 엔트리<br>"
            "토너 출처: <i>%{customdata[0]}</i>"
        ),
        "RR by Percentile": "백분위별 RR",
        "PERR": "PERR",
        "Rank Percentile": "순위 백분위",
        "Rough ITM Cut (1/8)": "대략적인 ITM 컷 (8분의 1)",
        "RR Trendline": "RR 추세선",
    },
}
# fmt: on

PLOT_DOCUMENTATIONS: typing.Final[list[dict[Language, str]]] = [
    # Historical Performances
    {
        Language.ENGLISH: """
You can see 3 line graphs in this section;

1. Net profit, net rake, and ideal profit(when you do not pay the rake)
2. "Profitable ratio", including moving average;
    Downloaded data from the Pokercraft does not give you
    an information of ITM, instead it lets you know
    amount of your prizes(including bounties).
    Because of this, if you got enough bounty(more than buy-in)
    from some tournaments, then the system classifies that as "profitable".
    This value is slightly higher than actual ITM ratio.
3. Average buy in of your tournaments, including moving average.
    Note that buy-in is log-scaled.

*Creator's comment: This section is classic and probably the
most fundamental graph for all tournament grinders.
Note that the Pokercraft does not show the true PnL,
which means it does not correctly mirror the rake.*
""",
        Language.KOREAN: """
이 섹션에서는 3개의 선 그래프를 볼 수 있습니다;

1. 순수익, 지불한 레이크, 이상적인 수익(레이크를 지불하지 않았을 때)
2. "수익 보는 비율", 이동평균 포함;
    Pokercraft에서 다운받는 데이터는 ITM 정보를 제공하지 않고,
    대신에 당신의 상금(바운티 포함)만 알려줍니다.
    이 때문에, 어떤 토너에서 충분한 바운티(바이인 이상)를 받았다면,
    시스템은 해당 토너먼트를 "수익적"으로 분류합니다.
    그렇기 때문에 이 값은 실제 ITM 비율보다 약간 높습니다.
3. 당신의 토너먼트의 평균 바이인, 이동평균 포함.
    바이인 가격은 로그 스케일로 표시됩니다.

*제작자의 코멘트: 이 섹션은 아마도 토너먼트 그라인더들에게
가장 기본적인 그래프를 제공하는 섹션일 것입니다.
Pokercraft는 레이크를 제대로 반영하지 않음으로써
진짜 PnL을 그래프 상에서 보여주지 않습니다.*
""",
    },
    # Relative prize returns
    {
        Language.ENGLISH: """
RRE(Relative Returns with re-Entries) is a relative return of your investment
for individual tournament, considering re-entries.
For example, if you got $30 from a tournament with
$10 buy-in and you made 1 re-entry, then RRE = 30/20 = 1.5.

You can see 3 plots in this section;

1. RRE by buy-in amount (Heatmap)
2. RRE by total entries (Heatmap)
3. RRE by time of day (Heatmap, your local timezone is applied)
4. Marginal distribution for each RRE range (Horizontal bar chart)

Note that the Y axis and some plots's X axes are in log2 scale,
because these metrics have wide range of values so it makes
no sense to display in linear scale.

*Creator's comment: This section shows you are strong/weak in
which buy-in and which entry sizes, and also how much of
your profits are from in which RRE range.*
""",
        Language.KOREAN: """
RRE(리엔트리를 고려한 상대적인 상금 리턴)은 당신의 투자에 대한 상대적인 수익입니다.
예를 들어서, 10불짜리 토너를 2번 바인해서 30불을 얻었다면, RRE = 30/20 = 1.5입니다.

당신은 이 섹션에서 3개의 그래프를 볼 수 있습니다;

1. 바인 금액별 RRE (히트맵)
2. 총 엔트리수별 RRE (히트맵)
3. 시간대별 RRE (히트맵, 당신의 시간대가 적용됩니다)
4. 각 RRE 구간별 누적 분포 (수평 막대 그래프)

이 그래프들은 Y축과 몇몇 X축들이 log2(로그) 스케일로 표시됩니다.
왜냐하면 이 메트릭들은 값의 범위가 넓기 때문에
선형(linear) 스케일로 표시하는 것은 의미가 없기 때문입니다.

*제작자의 코멘트: 이 섹션은 당신이 어떤 바인 금액과 엔트리수에서 강하고 약한지,
그리고 당신의 수익이 어느 RRE 구간에서 얼마나 발생하는지를 보여줍니다.*
""",
    },
    # Bankroll Analysis
    {
        Language.ENGLISH: """
This section shows simplified result of the bankroll analysis simulations.
The exact procedure of the simulation is as follows;

- From your Pokercraft data, gather `RRs` of every tournament results.
    Unlike `RRE` plots, you get multiple values from single tournament
    if you did re-entries; For example, if you got $30 from a tournament
    with $10 buy-in and you made 1 re-entry, then `RRs = [-1.0, 2.0]`.
- Assuming you are continuously playing tournaments of 1 dollar buy-in,
    where each tournament yields one of all `RRs` as return,
    in uniform and independent manner.
- For single simulation, run `max(10 * YOUR_TOURNAMENT_COUNT, 4e4)` times
    and see if you are bankrupted or not.
- Run 25k parellel simulations.

Then each individual simulation yields one of two results;

- *"Survived"*; The final capital is non-zero
- *"Bankruptcy"*; It bankrupted before reaching maximum iteration

So the survival rate is basically likelihood of your survival when
you start playing tournaments with specific BI.

*Creator's comment: I use `RRs` instead of `RRE` because
`RRE` assumes you will end getting prize, but in reality
you may not be able to get prize even after multiple re-entries.
Also, I personally think 200 BI is the optimal bankroll
for tournament grinders, especially if you play massive tournaments
with thousands of participants.*
""",
        Language.KOREAN: """
이 섹션은 뱅크롤 분석 시뮬레이션의 결과를 간략하게 보여줍니다.
시뮬레이션의 정확한 절차는 다음과 같습니다;

- 당신의 Pokercraft 데이터로부터, 각 토너먼트 결과의 `RRs`를 모읍니다.
    `RRE` 그래프와는 다르게, `RRs`는 한 토너에서 여러 개의 값들을 반환할 수 있습니다;
    예를 들어 30달러 상금을 10달러짜리 토너에서 2번 바인해서 받았다면,
    `RRs = [-1.0, 2.0]` 입니다.
- 1달러 바인 금액의 토너먼트를 연속적으로 플레이한다고 가정하고,
    각 토너먼트의 상금은 과거 `RRs` 값들 중 하나를 랜덤하게 리턴합니다.
- 단일 시뮬레이션에서는 `max(10 * 당신의 토너먼트 수, 4e4)`번
    시뮬레이션을 돌리고, 파산했는지 안했는지를 확인합니다.
- 25,000개의 병렬 시뮬레이션을 돌립니다.

그러면 각각의 시뮬레이션은 두 가지 결과 중 하나를 보여줍니다;

- *"생존"*; 최종 잔고가 0이 아님
- *"파산"*; 시뮬레이션의 끝에 도달하기 전에 파산함

그러므로 생존 확률은 특정 바인 금액으로 토너먼트를 시작했을 때 당신이 생존할 확률을 의미합니다.

*제작자의 코멘트: `RRE` 값의 문제는 리바인을 계속하다보면 상금을 얻는다는
가정을 가지고 있는데, 실제로는 그렇지 않을 수 있으므로,
저는 뱅크롤 시뮬레이션에서 `RRs`를 대신 사용하기로 했습니다.
또한, 저는 개인적으로 200 BI가 대규모 토너먼트를
플레이하는 토너먼트 그라인더들에게 최적의 뱅크롤이라고 생각합니다.*
""",
    },
    # Prize Pie Chart
    {
        Language.ENGLISH: """
This section shows how much of your total prizes are from specific tournaments.

In main pie chart, since there might be too much number of slices,
only tournaments gave you more than 1% of your total prizes are shown,
and the rest are grouped as "Others", which is the biggest separated slice.

The second pie chart shows your prizes by weekday.
In most cases, weekend tournaments are usually more profitable than weekdays.

*Creator's comment: You can see if you ignore small prizes, then lots of portion
of your prizes are gone. In a long term, there is no such thing like "one hit wonder".*
""",
        Language.KOREAN: """
이 섹션은 당신의 총 상금 중에서 특정 토너먼트에서 얼마나 상금을 받았는지를 보여줍니다.

1번째 메인 차트에서는 너무 많은 조각이 있을 수 있기 때문에 총 상금의 1% 이상을 받은 토너만을 보여주고,
나머지는 "기타"로 묶어서 표시합니다. "기타"는 가장 큰 조각으로 분리됩니다.

두번째 파이 차트는 요일별 상금을 보여줍니다.
대부분의 경우, 주말 토너먼트가 평일보다 더 수익성이 높습니다.

*제작자의 코멘트: 작은 상금을 무시한다면, 당신의 상금의 상당 부분이 사라집니다.
장기적으로, "한방찍기"란 없다는 것을 이 섹션에서 알 수 있습니다.*
""",
    },
    # Rank Profit Chart
    {
        Language.ENGLISH: """
This section shows how RR grows over your rank percentile.
RR is calculated as prize divided by buy-in(re-entries are not considered),
and PERR is calculated as RR multiplied by rank percentile.

The RR trendline is a line for RR and rank percentile generated by
[linear regression](https://en.wikipedia.org/wiki/Linear_regression).
It does not trained on low ranked results(worse than 12.5%),
because there are way too many noises in such area.

*Creator's comment:
You can see RR and Rank Percentile are having roughly linear relationship.
You can check PERR of some important points to know
how much you should frequently achieve such deep runs,
and also how hard to make profits in tournaments in long term.
Some tournaments like `Flip & Go (Go Stage)` or Day1 tourneys
may make a noise due to how GGPoker gives an incomplete data.*
""",
        Language.KOREAN: """
이 섹션은 당신의 토너 순위 백분위에 따른 RR의 변화를 보여줍니다.
RR은 상금을 바인비로 나눈 값이고(리엔트리 고려 안함),
PERR은 RR을 순위 백분위로 곱한 값입니다.

RR 추세선은 [Linear Regression](https://en.wikipedia.org/wiki/Linear_regression)
을 통하여 만들어진 RR과 순위 백분위의 선형 회귀선입니다.
상위 12.5% 안에 들지 못한 결과들은 너무 많은 노이즈가 있기 때문에
해당 토너먼트들은 추세선 데이터로 트레이닝되지 않았습니다.

*제작자의 코멘트:
RR과 순위 백분위는 대략적으로 서로 비례함을 확인할 수 있습니다.
당신은 주요 딥런한 토너들의 PERR을 확인하여 얼마나 자주
그런 딥런을 만들어야 수익성이 생기는 지, 그리고 토너먼트에서
장기적으로 수익을 챙기는 것이 왜 어려운 지를 확인할 수 있습니다.
`플립앤고`나 Day1 같은 토너들이 데이터에 노이즈를 줄 수 있는데,
그것은 GGPoker가 데이터를 불완전하게 제공하기 때문입니다.*
""",
    },
]


def get_html_title(nickname: str, lang: Language) -> str:
    """
    Get HTML title in the given language.
    """
    return (lang << TITLE_FRAME) % (nickname,)


def get_software_credits(lang: Language) -> str:
    """
    Get software credits in the given language.
    """
    return (lang << SOFTWARE_CREDITS_FRAME) % (POKERCRAFT_AHREF,)


def get_translated_column_moving_average(lang: Language, window_size: int) -> str:
    """
    Get translated column name for moving average.
    """
    if window_size == 0:
        return lang << "Since 0"
    else:
        return (lang << "Recent %d") % (window_size,)


def format_dollar(value: float | int) -> str:
    """
    Format a dollar value to string with two decimal places.
    """
    if value >= 0:
        return "$%.2f" % value
    else:
        return "-$%.2f" % -value


def format_percent(value: float | int) -> str:
    """
    Format a percentage value to string with two decimal places.
    """
    return "%.2f%%" % (value * 100,)
