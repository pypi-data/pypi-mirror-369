"""
Auto-generated Optimas-DSPy pipeline for agent: {{ metadata.get('id', agent_name) }}

This pipeline builds an Optimas CompoundAISystem by wrapping DSPy Signatures
derived from your playbook tasks via the Optimas DSPy adapter.
"""

from __future__ import annotations

from typing import Dict, Any, List, ClassVar

import dspy
from optimas.arch.system import CompoundAISystem
from optimas.adapt.dspy import create_component_from_dspy


# -----------------------------
# Signature generation from spec
# -----------------------------
{% set tasks = spec.get('tasks', []) %}
{% if not tasks %}
# Fallback single-task signature when no tasks are defined
class DefaultTask(dspy.Signature):
	"""Default task generated by SuperOptiX."""
	instructions: ClassVar[str] = "You are a helpful assistant."
	query: str = dspy.InputField()
	response: str = dspy.OutputField()
{% else %}
{% for task in tasks %}
class {{ task.get('name', 'Task' ~ loop.index)|to_pascal_case }}(dspy.Signature):
	"""{{ (task.get('description') or task.get('instruction') or 'Task generated by SuperOptiX')|clean }}"""
	instructions: ClassVar[str] = "{{ (task.get('instruction') or metadata.get('description') or 'You are a helpful assistant.')|clean }}"
{% for f in task.get('inputs', []) %}
	{{ f.get('name')|to_snake_case }}: {{ f.get('type','str') }} = dspy.InputField()
{% endfor %}
{% for f in task.get('outputs', []) %}
	{{ f.get('name')|to_snake_case }}: {{ f.get('type','str') }} = dspy.OutputField()
{% endfor %}

{% endfor %}
{% endif %}


def build_optimas_system() -> CompoundAISystem:
	"""Construct a CompoundAISystem by wrapping DSPy signatures as components."""

	# Configure DSPy with LLM before building components
	# This fixes the "No LLM config found" error
	# Use the correct Ollama API endpoint (no /v1 prefix)
	llm = dspy.LM(
		model="ollama/llama3.2:1b",
		api_base="http://localhost:11434",
		api_key="ollama"
	)
	dspy.settings.configure(lm=llm)

	components: Dict[str, Any] = {}

{% if not tasks %}
	# Default single-component system
	DefaultTaskModule = create_component_from_dspy(DefaultTask)
	components["default_task"] = DefaultTaskModule
	final_outputs: List[str] = ["response"]
{% else %}
	# Create one component per task in order
{% for task in tasks %}
	{{ task.get('name', 'Task' ~ loop.index)|to_snake_case }}_cls = {{ task.get('name', 'Task' ~ loop.index)|to_pascal_case }}
	{{ task.get('name', 'Task' ~ loop.index)|to_snake_case }}_module = create_component_from_dspy({{ task.get('name', 'Task' ~ loop.index)|to_pascal_case }})
	components["{{ task.get('name', 'Task' ~ loop.index)|to_snake_case }}"] = {{ task.get('name', 'Task' ~ loop.index)|to_snake_case }}_module
{% endfor %}
	# Use last task outputs as system final outputs
{% set last_task = tasks[-1] %}
	final_outputs: List[str] = [{% for f in last_task.get('outputs', []) %}"{{ f.get('name')|to_snake_case }}"{% if not loop.last %}, {% endif %}{% endfor %}]
{% endif %}

	# Minimal evaluation function placeholder (non-strict)
	def eval_func(**kwargs) -> float:
		# Returns 1.0 if any final output is non-empty, else 0.0
		for k in final_outputs:
			val = kwargs.get(k)
			if isinstance(val, str) and val.strip():
				return 1.0
			if val not in (None, "", [], {}):
				return 1.0
		return 0.0

	return CompoundAISystem(
		components=components,
		final_output_fields=final_outputs,
		ground_fields=[],
		eval_func=eval_func,
	)


# Convenience entrypoint expected by some tooling
def system_engine() -> CompoundAISystem:
	return build_optimas_system()


