# BSD 3-Clause License

# Copyright (c) 2025, Miguel Dovale

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:

# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.

# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.

# 3. Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# This software may be subject to U.S. export control laws. By accepting this
# software, the user agrees to comply with all applicable U.S. export laws and
# regulations. User has the responsibility to obtain export licenses, or other
# export authority as may be required before exporting such information to
# foreign countries or providing access to foreign persons.
#
from deepfmkit.plotting import time_plot, dfm_axes, autoscale_y
from deepfmkit.fit import DEFAULT_GUESS, DEFAULT_NDATA

import numpy as np
import pandas as pd
from dataclasses import dataclass, field
from typing import Optional, Any, Tuple, TextIO
import gzip
import io
from pathlib import Path
import matplotlib.axes

import logging

logger = logging.getLogger(__name__)

def open_txt_maybe_gzip(path: str | Path, *, encoding: str = "utf-8") -> TextIO:
    """Open a text file for reading, optionally gzipped.
    """
    p = Path(path)
    if p.suffix == ".gz":
        # Return a text-mode stream
        return io.TextIOWrapper(gzip.open(p, "rb"), encoding=encoding)
    return p.open("r", encoding=encoding)

def _open_txt_for_write(filename: str | Path, *, compress: bool | None, encoding: str = "utf-8"):
    """Open a text file for writing, optionally gzipped.

    Rules:
      - If compress is True, write gzip regardless of filename; append '.gz' if missing.
      - If compress is False, write plain text.
      - If compress is None, infer from filename: endswith('.gz') => gzip, else plain.

    Returns:
      (fh, out_path_str)
    """
    p = Path(filename)
    if compress is None:
        use_gz = str(p).endswith(".gz")
    else:
        use_gz = bool(compress)

    # If user asked to compress but didn't give a .gz suffix, append it.
    if use_gz and not str(p).endswith(".gz"):
        p = p.with_name(p.name + ".gz")

    if use_gz:
        fh = gzip.open(p, mode="wt", encoding=encoding)
    else:
        fh = p.open(mode="w", encoding=encoding)
    return fh, str(p)

@dataclass
class RawData:
    """A container for raw, single-channel time-series data and metadata.

    This class encapsulates the raw voltage data from a single channel,
    along with essential metadata like sampling frequency. If the data was
    generated by the internal physics engine, it also stores the ground-truth
    signals for direct comparison and analysis.

    Attributes
    ----------
    data : pd.DataFrame
        A pandas DataFrame with a single column 'ch0' holding the raw voltage
        time-series.
    raw_file : str, optional
        The path to the source file if loaded from disk.
    label : str, optional
        A unique identifier for this data channel.
    t0 : float, optional
        The start time of the data acquisition (e.g., a Unix timestamp).
    f_samp : float, optional
        The sampling frequency of the data in Hz.
    fm : float, optional
        The laser's modulation frequency in Hz.
    sim : SimConfig, optional
        A link to the `SimConfig` object used to generate this data.
    phi : np.ndarray, optional
        Full DFMI phase from dynamic simulations, incl. all laser terms.
    phi_sim : np.ndarray, optional
        The ideal, noiseless phase signal from a dynamic simulation (noiseless ground truth).
    phi_sim_noisy : np.ndarray, optional
        The noisy phase signal from a dynamic simulation (noisy ground truth).
    phi_sim_downsamp : np.ndarray, optional
        The ground truth phase signal, downsampled to the fit rate.
    f_noise : np.ndarray, optional
        The laser frequency noise time-series from a simulation.
    l_noise : np.ndarray, optional
        The armlength noise time-series from a simulation.
    r_noise : np.ndarray, optional
        The time-series of laser relative intensity noise from a simulation.
    s_noise : np.ndarray, optional
        The time-series of detector noise from a simulation.
    df_noise : np.ndarray, optional
        The laser modulation amplitude noise time-series from a simulation.
    """

    data: pd.DataFrame = field(default_factory=pd.DataFrame)
    raw_file: Optional[str] = None  # The raw data file
    label: Optional[str] = None  # Label of the data
    t0: Optional[float] = None  # Start time
    f_samp: Optional[float] = None  # Sampling frequency
    fm: Optional[float] = None  # Modulation frequency
    data: Optional[pd.DataFrame] = None  # The raw data
    # Simulation outputs:
    sim: Optional[Any] = None  # Associated SimConfig
    phi: Optional[np.array] = (
        None  # Full DFMI phase from dynamic simulations, incl. all laser terms
    )
    phi_sim: Optional[np.array] = (
        None  # IFO phase from dynamic simulations, not incl. laser frequency noise
    )
    phi_sim_noisy: Optional[np.array] = (
        None  # IFO phase from dynamic simulations, incl. laser frequency noise
    )
    phi_sim_downsamp: Optional[np.array] = None  # phi_sim downsampled
    f_noise: Optional[np.array] = None  # Laser frequency noise
    l_noise: Optional[np.array] = None  # Armlength modulation noise
    r_noise: Optional[np.array] = None  # Relative intensity noise
    s_noise: Optional[np.array] = None  # Detector noise (e.g., shot noise, electronic noise)
    df_noise: Optional[np.array] = None  # Laser frequency modulation amplitude noise

    def info(self) -> None:
        """Prints a summary of the raw data's metadata."""
        logging.info(f"""
RawData Summary for: '{self.label}'
-----------------------------------
Source File:            {self.raw_file or "N/A (Generated)"}
Start Time (t0):        {self.t0}
Sampling Freq (f_samp): {self.f_samp} Hz
Modulation Freq (fm):   {self.fm} Hz
Number of Samples:      {len(self.data)}
Duration:               {len(self.data) / self.f_samp if self.f_samp else "N/A"} s
""")

    def to_txt(self, filename: str, *, compress: bool | None = None, encoding: str = "utf-8") -> str:
        """
        Save the raw data to DFMI text format.

        Parameters
        ----------
        filename : str
            Target path ('.gz' suffix implies gzip if compress is None).
        compress : bool | None
            True => gzip; False => plain; None => infer from filename.
        encoding : str
            Text encoding for header/body.

        Returns
        -------
        str
            The actual path written (may have '.gz' appended if compress=True).
        """
        lines = [
            "% fit_data",
            "% Message goes here",
            f"% Number of channels: {1}",
            f"% Start time: {self.t0}",
            f"% Sampling frequency: {self.f_samp}",
            f"% Modulation frequency: {self.fm}",
            f"% n: {0}",
            f"% Downsampling factor: {0}",
            f"% Fit data rate: {0}",
            f"% Initial amplitude: {0}",
            f"% Initial modulation depth: {0}",
            "%",
            "ch0 ",
        ]

        fh, out_path = _open_txt_for_write(filename, compress=compress, encoding=encoding)
        try:
            for line in lines:
                fh.write(line + "\n")

            # Write samples from the single 'ch0' column
            # Assumes self.data is a 1-column DataFrame (like your current format)
            col = self.data.columns[0]
            for i in range(len(self.data)):
                fh.write(f"{self.data.iloc[i][col]} \n")
        finally:
            fh.close()
        return out_path

    def parse_header(self) -> None:
        """Parses the header from the source `raw_file`.

        This internal helper reads metadata from the header of the file
        specified in `self.raw_file` and populates the object's attributes.

        Raises
        ------
        ValueError
            If `self.raw_file` is not specified.
        """
        lines = []
        values = []

        if self.raw_file is not None:
            with open_txt_maybe_gzip(self.raw_file) as f:
                for _ in range(11):
                    lines.append(f.readline())
        else:
            raise ValueError("Must specify a file to load.")

        for v in range(2, 11):
            values.append("".join([c for c in lines[v] if c in "1234567890."]))

        self.t0 = int(values[0])
        self.f_samp = float(values[1])
        self.fm = float(values[2])

    def plot(
        self,
        title: Optional[str] = None,
        label: Optional[str] = None,
        ax: Optional[matplotlib.axes.Axes] = None,
        xrange: Optional[Tuple[float, float]] = None,
        figsize: Tuple[float, float] = (12, 4),
        *args: Any,
        **kwargs: Any,
    ) -> matplotlib.axes.Axes:
        """Plots the raw voltage time-series data.

        Parameters
        ----------
        title : str, optional
            An optional title for the plot.
        ax : matplotlib.axes.Axes, optional
            An existing Axes object to plot on. If None, a new figure and
            axes are created.
        xrange : tuple, optional
            A tuple (xmin, xmax) specifying the time range to display.
        figsize : tuple, optional
            The size of the figure to create if `ax` is not provided.
        *args, **kwargs :
            Additional arguments passed directly to `matplotlib.pyplot.plot`.

        Returns
        -------
        matplotlib.axes.Axes
            The Axes object containing the plot.
        """
        t_list = [np.arange(len(self.data)) / self.f_samp]
        y_list = [self.data]

        return time_plot(
            t_list,
            y_list,
            label_list=[label],
            ax=ax,
            xrange=xrange,
            title=title,
            y_label="Voltage(t)",
            figsize=figsize,
            remove_y_offsets=False,
            remove_time_offsets=False,
            *args,
            **kwargs,
        )


@dataclass
class FitData:
    """A container for the results of a parameter estimation routine.

    This class encapsulates the time-series of fitted parameters from a single
    channel, along with the metadata describing the fitting process.

    Attributes
    ----------
    fit_file : str, optional
        The path to the source file if loaded from disk.
    label : str, optional
        A unique identifier for this fit result.
    n_cycles : int, optional
        The number of modulation cycles per fit buffer.
    t0 : int, optional
        The start time of the original data.
    R : int, optional
        The downsampling factor (buffer size in samples) of the fit.
    fs : float, optional
        The fit data rate in Hz.
    f_samp : float, optional
        The sampling frequency of the original raw data in Hz.
    fm : float, optional
        The laser modulation frequency in Hz.
    n_harmonics : int
        The number of harmonics used in the NLS fit.
    init_a, init_m, init_phi, init_psi : float
        The initial parameter guesses used for the fit.
    n_buf : int, optional
        The total number of buffers (fit points) in the result.
    time : np.ndarray, optional
        The time axis for the fitted parameters.
    ssq : np.ndarray, optional
        Time-series of the sum-of-squares error for each fit.
    amp : np.ndarray, optional
        Time-series of the fitted amplitude (`C`).
    m : np.ndarray, optional
        Time-series of the fitted modulation depth (`m`).
    tau : np.ndarray, optional
        Time-series of the fitted time delay (`tau`).
    phi : np.ndarray, optional
        Time-series of the fitted interferometric phase (`Phi`).
    psi : np.ndarray, optional
        Time-series of the fitted modulation phase (`psi`).
    dc : np.ndarray, optional
        Time-series of the fitted DC offset.
    """

    fit_file: Optional[str] = None  # The fit data file
    label: Optional[str] = None  # Label of the data
    n_cycles: Optional[int] = (
        None  # buffer_size = n_cycles*f_samp/fm; data_rate = f_samp/buffer_size = fm/n_cycles;
    )
    t0: Optional[int] = None  # Start time
    R: Optional[int] = None  # Downsampling factor
    fs: Optional[float] = None  # Fit data rate
    f_samp: Optional[float] = None  # Sampling frequency
    fm: Optional[float] = None  # Modulation frequency
    n_harmonics: int = DEFAULT_NDATA  # Number of harmonics to use in fit
    init_a: float = DEFAULT_GUESS["amp"]  # Initial value of the amplitude
    init_m: float = DEFAULT_GUESS["m"]  # Initial value of the effective modulation index
    init_phi: float = DEFAULT_GUESS["phi"]  # Initial value of the interferometric phase
    init_psi: float = DEFAULT_GUESS["psi"]  # Initial value of the modulation phase
    n_buf: Optional[int] = None  # Buffers contained in raw data
    time: Optional[np.ndarray] = None  # Fit time
    ssq: Optional[np.ndarray] = None  # Fit sum of squares
    amp: Optional[np.ndarray] = None  # Fit amplitude
    m: Optional[np.ndarray] = None  # Fit effective modulation index
    tau: Optional[np.ndarray] = None  # Fit time delay (L/c)
    phi: Optional[np.ndarray] = None  # Fit interferometric phase
    psi: Optional[np.ndarray] = None  # Fit modulation phase
    dc: Optional[np.ndarray] = None  # Fit dc level

    def info(self) -> None:
        """Prints useful info about the loaded fit data."""
        logging.info(f"""
FitData Summary for: '{self.label}'
-----------------------------------
Source File:                  {self.fit_file or "N/A (Generated)"}
Start Time (t0):              {self.t0}
Orig Samp Freq:               {self.f_samp:.3f} Hz
Modulation Freq (fm):         {self.fm:.3f} Hz
Cycles per Buffer (n_cycles): {self.n_cycles:d}
Downsampling (R):             {self.R:d}
Fit Data Rate (fs):           {self.fs:.3f} Hz
Number of Fit Points:         {self.n_buf:d}
""")

    def to_txt(self, filename: str, *, compress: bool | None = None, encoding: str = "utf-8") -> str:
        """
        Save the fit results to DFMSWPM 'fit_data' text format.

        Parameters
        ----------
        filename : str
            Target path ('.gz' suffix implies gzip if compress is None).
        compress : bool | None
            True => gzip; False => plain; None => infer from filename.
        encoding : str
            Text encoding for header/body.

        Returns
        -------
        str
            The actual path written (may have '.gz' appended if compress=True).
        """
        lines = [
            "% fit_data",
            "% Message goes here",
            f"% Number of channels: {1}",
            f"% Start time: {self.t0}",
            f"% Sampling frequency: {self.f_samp}",
            f"% Modulation frequency: {self.fm}",
            f"% Modulation cycles per fit buffer: {int(self.n_cycles)}",
            f"% Downsampling factor: {int(self.R)}",
            f"% Fit data rate: {self.fs}",
            "%",
            "ssq0 amp0 m0 phi0 psi0 dc0 ",
        ]

        fh, out_path = _open_txt_for_write(filename, compress=compress, encoding=encoding)
        try:
            for line in lines:
                fh.write(line + "\n")
            # Write each buffer row
            for i in range(len(self.ssq)):
                fh.write(
                    f"{self.ssq[i]} {self.amp[i]} {self.m[i]} {self.phi[i]} {self.psi[i]} {self.dc[i]} \n"
                )
        finally:
            fh.close()
        return out_path

    def parse_header(self) -> None:
        """Parse the header of a fit_data file.

        This function must be revised should the format of the header change.
        """

        lines = []
        values = []

        if self.fit_file is not None:
            with open_txt_maybe_gzip(self.fit_file) as f:
                for _ in range(11):
                    lines.append(f.readline())
        else:
            raise ValueError("Must specify a file to load.")

        for v in range(2, 9):
            values.append("".join([c for c in lines[v] if c in "1234567890."]))

        self.t0 = int(values[0])
        self.f_samp = float(values[1])
        self.fm = float(values[2])
        self.n_cycles = int(values[3])
        self.R = int(values[4])
        self.fs = float(values[5])

    def plot(
        self, xrange: Optional[Tuple[float, float]] = None, timeaxis: bool = True
    ) -> Tuple[matplotlib.axes.Axes, ...]:
        """Plots all available fit parameter time-series.

        This method creates a standard DFMI 6-panel plot showing the evolution
        of all fitted parameters over time or buffer count.

        Parameters
        ----------
        xrange : tuple, optional
            A tuple (xmin, xmax) specifying the range of the x-axis to display.
        timeaxis : bool, optional
            If True, the x-axis is time in seconds. If False, it is the
            buffer count (integer index). Defaults to True.

        Returns
        -------
        tuple[matplotlib.axes.Axes, ...]
            A tuple of the six matplotlib Axes objects created for the plot.
        """
        fig, (ax1, ax2, ax3, ax4, ax5, ax6) = dfm_axes()

        if timeaxis:
            ax6.set_xlabel("Time (s)")
            ax6.semilogy(self.time, self.ssq)
            ax5.plot(self.time, self.dc)
            ax4.plot(self.time, self.amp)
            ax3.plot(self.time, self.m)
            ax2.plot(self.time, self.phi)
            ax1.plot(self.time, self.psi, label=self.label)
        else:
            ax6.set_xlabel("Buffer count")
            ax6.semilogy(self.ssq)
            ax5.plot(self.dc)
            ax4.plot(self.amp)
            ax3.plot(self.m)
            ax2.plot(self.phi)
            ax1.plot(self.psi, label=self.label)

        if xrange is not None:
            ax1.set_xlim(xrange)
            ax2.set_xlim(xrange)
            ax3.set_xlim(xrange)
            ax4.set_xlim(xrange)
            ax5.set_xlim(xrange)
            ax6.set_xlim(xrange)
            autoscale_y(ax1)
            autoscale_y(ax2)
            autoscale_y(ax3)
            autoscale_y(ax4)
            autoscale_y(ax5)
            autoscale_y(ax6)

        fig.tight_layout()
        return (ax1, ax2, ax3, ax4, ax5, ax6)
