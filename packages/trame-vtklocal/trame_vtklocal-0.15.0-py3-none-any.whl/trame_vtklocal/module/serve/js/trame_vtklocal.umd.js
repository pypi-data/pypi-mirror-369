(function(p,b){typeof exports=="object"&&typeof module<"u"?b(exports,require("vue")):typeof define=="function"&&define.amd?define(["exports","vue"],b):(p=typeof globalThis<"u"?globalThis:p||self,b(p.trame_vtklocal={},p.Vue))})(this,function(p,b){"use strict";const L=[],j={};function A(){let t,e;return{promise:new Promise((s,n)=>{t=s,e=n}),resolve:t,reject:e}}function $(t){return t!=null&&t.Id?t:JSON.parse(t)}function G(t){return t!=null&&t.Id?JSON.stringify(t):t}function q(t,e){return t.rendering===e.rendering&&t.exec===e.exec}function E(t){return(t==null?void 0:t.rendering)==="webgpu"?(console.log("WASM use WebGPU"),{preRun:[function(e){e.ENV.VTK_GRAPHICS_BACKEND="WEBGPU"}]}):(console.log("WASM use WebGL2"),{})}function J(t){return j[t]||(j[t]=new Promise(function(e,s){if(L.indexOf(t)===-1){L.push(t);var n=document.createElement("script");n.type="module",n.src=t,n.onload=e,n.onerror=s,document.body.appendChild(n)}else e(!1)})),j[t]}class H{constructor(){this.loaded=!1,this.loadingPending=null,this.wasm=null,this.config={},this.runtimes=[]}async load(e,s={rendering:"webgl",exec:"sync"},n="vtk"){var r,o;if(this.config=s,!this.loaded)if(this.loadingPending)await this.loadingPending;else{const{promise:c,resolve:u}=A();if(this.loadingPending=c,((r=this.config)==null?void 0:r.rendering)==="webgpu"&&(this.config.exec="async"),!window.createVTKWASM){let i=null;document.querySelectorAll("script").forEach(f=>{if(f.src.includes(`${n}WebAssembly`)){const{promise:a,resolve:d}=A();f.onload=d,i=a}}),i&&await i}if(!window.createVTKWASM){let i=null,f=null;i=`${e}/${n}WebAssembly${((o=this.config)==null?void 0:o.exec)==="async"?"Async":""}.mjs`;const a=await fetch(i);if(a.ok&&(await a.text())[0]!=="<"&&(f=i),!f){i=`${e}/vtkWasmSceneManager.mjs`;const d=await fetch(i);d.ok&&(await d.text())[0]!=="<"&&(f=i)}if(!f)throw new Error(`Could not fetch wasm bundle from ${e}`);console.log("WASM use",f),await J(f)}window.createVTKWASM&&(this.wasm=await window.createVTKWASM(E(this.config))),this.loaded=!0,u()}}async createRemoteSession(e){var s;if(this.wasm)if((s=this.wasm)!=null&&s.isAsync&&this.wasm.isAsync()){if(!e||q(this.config,e))return console.log("(Main runtime in async)"),new this.wasm.vtkRemoteSession;{console.log("(New in async)");const r=await window.createVTKWASM(E(e||this.config));return new r.vtkRemoteSession}}else{console.log("(New in sync)");const r=await window.createVTKWASM(E(e||this.config));return new r.vtkRemoteSession}const n=await window.createVTKWasmSceneManager();return n.initialize(),n}createStandaloneSession(){if(!this.wasm)throw new Error("Current WASM version does not support standalone mode");return new this.wasm.vtkStandaloneSession}createStateDecorator(){return this.wasm?$:G}}function P(t){return`${t.charAt(0).toLowerCase()}${t.slice(1)}`}function B(t){return`${t.charAt(0).toUpperCase()}${t.slice(1)}`}function _(t){const e={};return Object.entries(t).forEach(([s,n])=>{e[B(s)]=n}),e}function F(t){const e={};return Object.entries(t).forEach(([s,n])=>{e[P(s)]=n}),e}function X(t,e,s){if(!t.get)return{};const n=t.get(s),r={};return Object.keys(n).forEach(o=>{r[P(o)]=()=>e.decorateResult(t.get(s)[o])}),r}function Q(t,e,s){if(!t.get)return{};const n=t.get(s),r={};return Object.keys(n).forEach(o=>{r[P(o)]=c=>t.set(s,e.decorateKwargs({[o]:c}))}),r}function W(t,e,s,n,r){if(s.has(r)&&s.get(r).deref())return s.get(r).deref();const o=[];function c(M){return t.set(r,n.decorateKwargs(_(M)))}function u(M,g){const v=t.observe(r,M,g);return o.push(v),v}function i(M){const g=o.indexOf(M);return g!==-1&&o.splice(g,1),t.unObserve(r,M)}function f(){for(;o.length;)i(o.pop())}const a=X(t,n,r),d=Q(t,n,r),y={id:r,obj:{Id:r},set:c,observe:u,unObserve:i,unObserveAll:f},S=new Proxy(y,{get(M,g,v){if(g==="then")return v;if(g==="state")return t.get?F(t.get(r)):(t.updateStateFromObject(r),F(t.getState(r)));if(g==="delete"){const k=t.destroy(r);if(k){const z=s.delete(r);e.delete(z)}return k}return a[g]?a[g]():(M[g]||(M[g]=async(...k)=>n.decorateResult(await t.invoke(r,B(g),n.decorateArgs(k)))),M[g])},set(M,g,v){return d[g]&&d[g](v),v}});return s.set(r,new WeakRef(S)),e.set(S,!0),S}function Y(t,e,s){function n(a){return e.has(a)}function r(a){const d={};return Object.entries(a).forEach(([y,S])=>{e.has(S)?d[y]=S.obj:d[y]=S}),d}function o(a){return a.map(d=>e.has(d)?d.obj:d)}const c={isVtkObject:n,decorateKwargs:r,decorateArgs:o};function u(a){return a==null?a:a!=null&&a.Id?W(t,e,s,c,a.Id):a}c.decorateResult=u;function i(a){return W(t,e,s,c,a.Id||a)}function f(a,d){const y=t.create(a);return d&&t.set(y,r(_(d))),W(t,e,s,c,y)}return new Proxy({getVtkObject:i},{get(a,d,y){return d==="then"?y:(a[d]||(a[d]=S=>f(d,S)),a[d])}})}async function Z(t,e={},s="vtk"){const n=new WeakMap,r=new Map,o=new H;await o.load(t,e,s);const c=o.createStandaloneSession();return Y(c,n,r)}const{promise:ee,resolve:te,reject:ne}=A(),R=document.querySelector("#vtk-wasm");if(R){const t=R.dataset.url||".",e=JSON.parse(R.dataset.config||"{}");window.vtkReady=ee,Z(t,e).then(s=>{window.vtk=s,te(s)})}else ne('No script with id="vtk-wasm"');const O={};class K{constructor(){this.sceneManager=null,this.loaded=!1,this.updateInProgress=0,this.currentMTime=1,this.stateMTimes={},this.hashesMTime={},this.pendingArrays={},this.networkFetchState=null,this.networkFetchHash=null,this.networkFetchStatus=null,this.cameraIds=new Set,this.stateCache={},this.renderWindowIds=new Set,this.renderWindowIdToInteractorId=new Map,this.renderWindowSizes={},this.vtkProxyCache=new WeakMap,this.idToRef=new Map,this.internalWrapMethods={},this.internalWrapMethods.isVtkObject=e=>this.vtkProxyCache.has(e),this.internalWrapMethods.decorateKwargs=e=>{const s={};return Object.entries(e).forEach(([n,r])=>{this.vtkProxyCache.has(r)?s[n]=r.obj:s[n]=r}),s},this.internalWrapMethods.decorateArgs=e=>e.map(s=>this.vtkProxyCache.has(s)?s.obj:s),this.internalWrapMethods.decorateResult=e=>e==null?e:e!=null&&e.Id?W(this.sceneManager,this.vtkProxyCache,this.idToRef,this.internalWrapMethods,e.Id):e,this.offlineCanvasContainer=document.createElement("div"),this.offlineCanvasContainer.setAttribute("class","unused-canvas"),document.body.appendChild(this.offlineCanvasContainer)}async load(e,s,n){O[e]||(O[e]=new H),await O[e].load(e,s,n),this.sceneManager=await O[e].createRemoteSession(s),this.stateDecorator=O[e].createStateDecorator(),this.loaded=!0,this.sceneManager.skipProperty&&(this.sceneManager.skipProperty("vtkRenderWindow","Size"),["vtkWin32OpenGLRenderWindow","vtkXOpenGLRenderWindow","vtkCocoaRenderWindow","vtkWebAssemblyOpenGLRenderWindow"].forEach(r=>this.sceneManager.skipProperty(r,"Size")))}bindNetwork(e,s,n){this.networkFetchState=e,this.networkFetchHash=s,this.networkFetchStatus=n}freeMemory(e=0){const s=this.sceneManager.getTotalBlobMemoryUsage(),n=Number(e);if(s>n){const r={};let o=this.currentMTime;for(Object.entries(this.hashesMTime).forEach(([c,u])=>{u<o&&(o=u);const i=u.toString();r[i]?r[i].push(c):r[i]=[c]});this.sceneManager.getTotalBlobMemoryUsage()>n;){const c=r[o];if(c)for(let u=0;u<c.length;u++)this.sceneManager.unRegisterBlob(c[u]),delete this.hashesMTime[c[u]];o++}}}async fetchState(e){const s=await this.networkFetchState(e);return this.patchState(s)}patchState(e){var s;if(e.length>0){const n=JSON.parse(e),{Id:r,MTime:o}=n;if(this.stateMTimes[r]=o,!this.sceneManager.skipProperty||!this.sceneManager.bindRenderWindow){if(this.renderWindowIds.has(r)&&(s=n==null?void 0:n.Interactor)!=null&&s.Id)return this.renderWindowIdToInteractorId.set(n.Interactor.Id,r),n.CanvasSelector=this.getCanvasSelector(r),delete n.Size,this.renderWindowSizes[r]&&(n.Size=this.renderWindowSizes[r]),n.ClassName="vtkCocoaRenderWindow",JSON.stringify(n);if(this.renderWindowIdToInteractorId.has(r))return n.CanvasSelector=this.getCanvasSelector(this.renderWindowIdToInteractorId.get(r)),JSON.stringify(n)}return e}}async fetchHash(e){if(this.pendingArrays[e]){await this.pendingArrays[e],this.hashesMTime[e]=this.currentMTime,delete this.pendingArrays[e];return}const s=await this.networkFetchHash(e);return this.sceneManager.registerBlob(e,s),this.hashesMTime[e]=this.currentMTime,s}pushHash(e,s){return this.pendingArrays[e]=new Promise(n=>{s.arrayBuffer?s.arrayBuffer().then(r=>{this.sceneManager.registerBlob(e,new Uint8Array(r)),this.hashesMTime[e]=this.currentMTime,n()}):(this.sceneManager.registerBlob(e,s),this.hashesMTime[e]=this.currentMTime,n())}),this.pendingArrays[e]}async update(e,s=!1){if(this.renderWindowIds.add(e),this.updateInProgress++,this.updateInProgress===1)try{const n=await this.networkFetchStatus(e),r=[],o=[],c=n.force_push||[];for(let i=0;i<c.length;i++)delete this.stateMTimes[c[i]];n.ids.forEach(([i,f])=>{(!this.stateMTimes[i]||this.stateMTimes[i]<f)&&o.push(this.fetchState(i))}),n.hashes.forEach(i=>{this.hashesMTime[i]||r.push(this.fetchHash(i)),this.hashesMTime[i]=this.currentMTime}),n.cameras.forEach(i=>this.cameraIds.add(Number(i))),n.ignore_ids.forEach(i=>this.sceneManager.unRegisterState(i)),await Promise.all(r),await Promise.all(Object.values(this.pendingArrays));const u=await Promise.all(o);for(this.currentMTime++;u.length;){const i=u.pop();i&&this.sceneManager.registerState(this.stateDecorator(i))}try{this.sceneManager.updateObjectsFromStates();const[i,f]=this.renderWindowSizes[e]||[10,10];this.sceneManager.setSize(e,i,f),s&&this.sceneManager.bindRenderWindow&&this.sceneManager.bindRenderWindow(e,this.getCanvasSelector(e)),await this.sceneManager.render(e)}catch(i){console.error("WASM update failed"),console.log(i)}}catch(n){console.error("Error in update",n)}finally{this.updateInProgress--,this.updateInProgress&&(this.updateInProgress=0,await this.update(e))}}getState(e,s=!1){const n=Number(e);return s&&this.stateCache[n]?this.stateCache[n]:this.sceneManager.get?this.sceneManager.get(n):(this.sceneManager.updateStateFromObject(n),this.sceneManager.getState(n))}clearStateCache(){this.stateCache={}}getStateValue(e,s=!1){const n=Array.isArray(e)?e:[e];let r=null;for(let o=0;o<n.length;o++){const c=n[o];o===0?r=this.getState(c,s):(r=r[c],r.Id&&(r=this.getState(r.Id,s)))}return r}getCanvasSelector(e){return`.vtk-wasm-${e}`}bindCanvasToDOM(e,s){const n=this.getCanvasSelector(e);let r=this.offlineCanvasContainer.querySelector(n);return r||(r=document.createElement("canvas"),r.setAttribute("class",n.substring(1)),r.setAttribute("tabindex","0")),s.appendChild(r),n}unbindCanvasToDOM(e){const s=this.getCanvasSelector(e),n=document.querySelector(s);n&&this.offlineCanvasContainer.appendChild(n)}async setSize(e,s,n){this.renderWindowSizes[e]=[s,n];const r=this.getCanvasSelector(e),o=document.querySelector(r);o&&(o.width=s,o.height=n,this.sceneManager.setSize(e,s,n),await this.sceneManager.render(e))}getVtkObject(e){return W(this.sceneManager,this.vtkProxyCache,this.idToRef,this.internalWrapMethods,e)}}const C={};function V(t,e,s){return function(){e.clearStateCache();for(const[n,r]of Object.entries(s)){const o={};for(const[c,u]of Object.entries(r))o[c]=e.getStateValue(u,!0);t.state.set(n,o)}e.clearStateCache()}}const D={VtkLocal:{emits:["updated","memory-vtk","memory-arrays","camera","invoke-response"],props:{useHandler:{type:String},renderWindow:{type:Number},eagerSync:{type:Boolean,default:!1},cacheSize:{type:Number,default:1e8},wsClient:{type:Object},verbosity:{type:Object,default:()=>({objectManager:null,invoker:null,deserializer:null,serializer:null})},config:{type:Object,default:()=>({rendering:"webgl",exec:"sync"})},listeners:{type:Object}},setup(t,{emit:e}){t.useHandler&&!C[t.useHandler]&&(C[t.useHandler]=new K);const s=b.inject("trame"),n=s.state.get("__trame_vtklocal_wasm_url"),r=s.state.get("__trame_vtklocal_wasm_base_name"),o=[],c=[],u=b.ref(null),i=t.wsClient||(s==null?void 0:s.client),f=b.toRef(t,"listeners"),a=t.useHandler?C[t.useHandler]:new K;let d=null;async function y(h){return await i.getConnection().getSession().call("vtklocal.get.state",[h])}async function S(h){const w=await i.getConnection().getSession().call("vtklocal.get.hash",[h]);return w.arrayBuffer?new Uint8Array(await w.arrayBuffer()):w}async function M(h){return await i.getConnection().getSession().call("vtklocal.get.status",[h])}function g([h]){h.type==="state"&&a.pushState(h.content),h.type==="blob"&&a.pushHash(h.hash,h.content)}async function v(){const h=i.getConnection().getSession();d=h.subscribe("vtklocal.subscriptions",g),await h.call("vtklocal.subscribe.update",[t.renderWindow,1])}async function k(){const h=i.getConnection().getSession();d&&(h.unsubscribe(d),d=null),await h.call("vtklocal.subscribe.update",[t.renderWindow,-1])}async function z(){const{width:h,height:l}=u.value.getBoundingClientRect(),w=Math.floor(h*window.devicePixelRatio+.5),m=Math.floor(l*window.devicePixelRatio+.5);await a.setSize(t.renderWindow,w,m)}let T=new ResizeObserver(z);function re(){a.freeMemory(t.cacheSize),e("memory-vtk",a.sceneManager.getTotalVTKDataObjectMemoryUsage()),e("memory-arrays",a.sceneManager.getTotalBlobMemoryUsage())}async function U(h=!1){a.loaded&&(await a.update(t.renderWindow,h),e("updated"),re())}function ae(h){a.sceneManager.resetCamera(h),a.sceneManager.render(t.renderWindow)}async function ie(h,l,w){const m=await a.sceneManager.invoke(h,l,w);return m.Id&&m.Success&&(m.Value=a.getState(m.Id)),e("invoke-response",m),m}function oe(){a.sceneManager.printSceneManagerInformation()}b.onMounted(async()=>{a.bindNetwork(y,S,M),a.loaded||await a.load(n,t.config,r);const h=a.bindCanvasToDOM(t.renderWindow,b.unref(u));b.unref(u).querySelector(h).setAttribute("style","position: absolute; left: 0; top: 0; width: 100%; height: 100%;"),t.eagerSync&&v(),T&&T.observe(b.unref(u)),b.watchEffect(()=>{const l=t.verbosity;l.objectManager&&a.sceneManager.setObjectManagerLogVerbosity&&a.sceneManager.setObjectManagerLogVerbosity(l.objectManager),l.invoker&&a.sceneManager.setInvokerLogVerbosity&&a.sceneManager.setInvokerLogVerbosity(l.invoker),l.deserializer&&a.sceneManager.setDeserializerLogVerbosity&&a.sceneManager.setDeserializerLogVerbosity(l.deserializer),l.serializer&&a.sceneManager.setSerializerLogVerbosity&&a.sceneManager.setSerializerLogVerbosity(l.serializer)}),await U(!0),a.sceneManager.addObserver?a.cameraIds.forEach(l=>{o.push([l,a.sceneManager.addObserver(l,"ModifiedEvent",()=>{e("camera",a.getState(l))})])}):a.cameraIds.forEach(l=>{o.push([l,a.sceneManager.observe(l,"ModifiedEvent",()=>{e("camera",a.getState(l))})])}),b.watchEffect(()=>{if(a.sceneManager.removeObserver){for(;c.length;){const[l,w]=c.pop();a.sceneManager.removeObserver(l,w)}for(const[l,w]of Object.entries(f.value||{})){const m=Number(l);for(const[x,N]of Object.entries(w||{})){const I=V(s,a,N);c.push([m,a.sceneManager.addObserver(m,x,I)]),I()}}}else{for(;c.length;){const[l,w]=c.pop();a.sceneManager.unObserve(l,w)}for(const[l,w]of Object.entries(f.value||{})){const m=Number(l);for(const[x,N]of Object.entries(w||{})){const I=V(s,a,N);c.push([m,a.sceneManager.observe(m,x,I)]),I()}}}}),a.sceneManager.startEventLoop(t.renderWindow)||console.error("Could not startEventLoop for",t.renderWindow)}),b.onBeforeUnmount(()=>{d&&k();const h=a.sceneManager.removeObserver?"removeObserver":"unObserve";for(;o.length;){const[l,w]=o.pop();a.sceneManager[h](l,w)}for(;c.length;){const[l,w]=c.pop();a.sceneManager[h](l,w)}a.sceneManager.stopEventLoop(t.renderWindow),T&&(T.disconnect(),T=null),a.unbindCanvasToDOM(t.renderWindow)});function ce(h){V(s,a,h)()}function le(h){return a.getVtkObject(h)}function he(){t.useHandler&&C[t.useHandler]&&delete C[t.useHandler]}return{container:u,update:U,resetCamera:ae,evalStateExtract:ce,invoke:ie,printSceneManagerInformation:oe,detachHandler:he,getVtkObject:le}},template:'<div ref="container" style="position: relative; width: 100%; height: 100%;"></div>'}};function se(t){Object.keys(D).forEach(e=>{t.component(e,D[e])})}p.install=se,Object.defineProperty(p,Symbol.toStringTag,{value:"Module"})});
