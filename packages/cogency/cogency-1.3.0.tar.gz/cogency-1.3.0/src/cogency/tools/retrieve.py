"""CANONICAL Retrieve tool - semantic search over static document corpus."""

from dataclasses import dataclass
from typing import Any, Optional

from resilient_result import Result

from cogency.semantic import semantic_search
from cogency.tools.base import Tool
from cogency.tools.registry import tool


@dataclass
class RetrieveArgs:
    query: str
    top_k: int = 5
    threshold: Optional[float] = None
    filters: Optional[dict[str, Any]] = None


@tool
class Retrieve(Tool):
    """Semantic document search over pre-computed embeddings.

    Searches static document corpus using vector similarity.
    Expects JSON file with embeddings generated by user or embedding utilities.
    """

    def __init__(
        self,
        embeddings_path: str = "./embeddings.json",
        top_k: int = 5,
        min_similarity: float = 0.0,
        embedder=None,
    ):
        super().__init__(
            name="retrieve",
            description="Search documents using semantic similarity",
            schema="retrieve(query: str, top_k: int = 5, threshold: float = None, filters: dict = None)",
            emoji="üìö",
            args=RetrieveArgs,
            examples=[
                "retrieve(query='user authentication methods')",
                "retrieve(query='API rate limiting', top_k=10)",
                "retrieve(query='deployment', threshold=0.7)",
            ],
            rules=[
                "Use specific queries for better semantic matching",
                "Requires pre-computed embeddings in JSON format",
                "Higher top_k returns more results but may include less relevant content",
                "Use threshold to filter low-similarity results",
                "Use filters to narrow results by metadata",
            ],
        )

        self.embeddings_path = embeddings_path
        self.default_top_k = top_k
        self.min_similarity = min_similarity

        # CANONICAL: Injected embedder from agent
        self._embedder = embedder

    async def run(
        self,
        query: str,
        top_k: int = None,
        threshold: float = None,
        filters: Optional[dict[str, Any]] = None,
        **kwargs,
    ) -> Result:
        """Search documents using semantic similarity."""
        if not query or not query.strip():
            return Result.fail("Search query cannot be empty")

        if not self._embedder:
            return Result.fail("No embedder configured - must be injected from agent")

        # Use defaults if not specified
        top_k = top_k or self.default_top_k
        threshold = threshold if threshold is not None else self.min_similarity

        # Validate parameters
        if top_k <= 0:
            return Result.fail("top_k must be positive")
        if top_k > 50:
            top_k = 50  # Cap at reasonable limit

        # CANONICAL semantic search
        search_result = await semantic_search(
            embedder=self._embedder,
            query=query.strip(),
            file_path=self.embeddings_path,
            top_k=top_k,
            threshold=threshold,
            filters=filters,
        )

        if search_result.failure:
            return Result.fail(f"Search failed: {search_result.error}")

        results = search_result.unwrap()

        if not results:
            return Result.ok(
                {
                    "results": [],
                    "query": query,
                    "total_results": 0,
                    "message": f"No relevant content found for '{query}'",
                    "results_summary": "No relevant content found",
                }
            )

        # Format results summary (top 3 for display)
        results_summary = []
        for i, result in enumerate(results[:3], 1):
            content = result["content"]
            similarity = result["similarity"]
            source = result["metadata"].get("source", f"Document {i}")

            preview = content[:150] + "..." if len(content) > 150 else content
            results_summary.append(f"{i}. {source} (sim: {similarity:.3f}): {preview}")

        return Result.ok(
            {
                "results": results,
                "query": query,
                "total_results": len(results),
                "message": f"Found {len(results)} relevant documents for '{query}'",
                "results_summary": "\n".join(results_summary),
            }
        )

    # Tool display formatting
    human_template = "üîç Searching: '{query}'"
    agent_template = "Found {total_results} relevant documents"
    arg_key = "query"
