// ****
// Auto-generated by cainome do not edit.
// ****

#![allow(clippy::all)]
#![allow(warnings)]

use serde::{Deserialize, Serialize};

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct ContractsSwapper<A: starknet::accounts::ConnectedAccount + Sync> {
    pub address: starknet::core::types::Felt,
    pub account: A,
    pub block_id: starknet::core::types::BlockId,
}
impl<A: starknet::accounts::ConnectedAccount + Sync> ContractsSwapper<A> {
    pub fn new(address: starknet::core::types::Felt, account: A) -> Self {
        Self {
            address,
            account,
            block_id: starknet::core::types::BlockId::Tag(starknet::core::types::BlockTag::Pending),
        }
    }
    pub fn set_contract_address(&mut self, address: starknet::core::types::Felt) {
        self.address = address;
    }
    pub fn provider(&self) -> &A::Provider {
        self.account.provider()
    }
    pub fn set_block(&mut self, block_id: starknet::core::types::BlockId) {
        self.block_id = block_id;
    }
    pub fn with_block(self, block_id: starknet::core::types::BlockId) -> Self {
        Self { block_id, ..self }
    }
}
#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct ContractsSwapperReader<P: starknet::providers::Provider + Sync> {
    pub address: starknet::core::types::Felt,
    pub provider: P,
    pub block_id: starknet::core::types::BlockId,
}
impl<P: starknet::providers::Provider + Sync> ContractsSwapperReader<P> {
    pub fn new(address: starknet::core::types::Felt, provider: P) -> Self {
        Self {
            address,
            provider,
            block_id: starknet::core::types::BlockId::Tag(starknet::core::types::BlockTag::Pending),
        }
    }
    pub fn set_contract_address(&mut self, address: starknet::core::types::Felt) {
        self.address = address;
    }
    pub fn provider(&self) -> &P {
        &self.provider
    }
    pub fn set_block(&mut self, block_id: starknet::core::types::BlockId) {
        self.block_id = block_id;
    }
    pub fn with_block(self, block_id: starknet::core::types::BlockId) -> Self {
        Self { block_id, ..self }
    }
}
#[derive(PartialEq)]
pub struct Delta {
    pub amount0: I129,
    pub amount1: I129,
}
impl cainome::cairo_serde::CairoSerde for Delta {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += I129::cairo_serialized_size(&__rust.amount0);
        __size += I129::cairo_serialized_size(&__rust.amount1);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(I129::cairo_serialize(&__rust.amount0));
        __out.extend(I129::cairo_serialize(&__rust.amount1));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let amount0 = I129::cairo_deserialize(__felts, __offset)?;
        __offset += I129::cairo_serialized_size(&amount0);
        let amount1 = I129::cairo_deserialize(__felts, __offset)?;
        __offset += I129::cairo_serialized_size(&amount1);
        Ok(Delta { amount0, amount1 })
    }
}
#[derive(PartialEq, Serialize, Deserialize)]
pub struct I129 {
    #[serde(
        serialize_with = "cainome::cairo_serde::serialize_as_hex",
        deserialize_with = "cainome::cairo_serde::deserialize_from_hex"
    )]
    pub mag: u128,
    pub sign: bool,
}
impl cainome::cairo_serde::CairoSerde for I129 {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += u128::cairo_serialized_size(&__rust.mag);
        __size += bool::cairo_serialized_size(&__rust.sign);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(u128::cairo_serialize(&__rust.mag));
        __out.extend(bool::cairo_serialize(&__rust.sign));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let mag = u128::cairo_deserialize(__felts, __offset)?;
        __offset += u128::cairo_serialized_size(&mag);
        let sign = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&sign);
        Ok(I129 { mag, sign })
    }
}
#[derive(PartialEq, Serialize, Deserialize)]
pub struct PoolKey {
    pub token0: cainome::cairo_serde::ContractAddress,
    pub token1: cainome::cairo_serde::ContractAddress,
    #[serde(
        serialize_with = "cainome::cairo_serde::serialize_as_hex",
        deserialize_with = "cainome::cairo_serde::deserialize_from_hex"
    )]
    pub fee: u128,
    #[serde(
        serialize_with = "cainome::cairo_serde::serialize_as_hex",
        deserialize_with = "cainome::cairo_serde::deserialize_from_hex"
    )]
    pub tick_spacing: u128,
    pub extension: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for PoolKey {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&__rust.token0);
        __size += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&__rust.token1);
        __size += u128::cairo_serialized_size(&__rust.fee);
        __size += u128::cairo_serialized_size(&__rust.tick_spacing);
        __size += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&__rust.extension);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(
            &__rust.token0,
        ));
        __out.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(
            &__rust.token1,
        ));
        __out.extend(u128::cairo_serialize(&__rust.fee));
        __out.extend(u128::cairo_serialize(&__rust.tick_spacing));
        __out.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(
            &__rust.extension,
        ));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let token0 = cainome::cairo_serde::ContractAddress::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&token0);
        let token1 = cainome::cairo_serde::ContractAddress::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&token1);
        let fee = u128::cairo_deserialize(__felts, __offset)?;
        __offset += u128::cairo_serialized_size(&fee);
        let tick_spacing = u128::cairo_deserialize(__felts, __offset)?;
        __offset += u128::cairo_serialized_size(&tick_spacing);
        let extension =
            cainome::cairo_serde::ContractAddress::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&extension);
        Ok(PoolKey {
            token0,
            token1,
            fee,
            tick_spacing,
            extension,
        })
    }
}
#[derive(PartialEq)]
pub struct SwapData {
    pub pool_key: PoolKey,
    pub amount: I129,
    pub sqrt_ratio_limit: cainome::cairo_serde::U256,
    pub token: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for SwapData {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += PoolKey::cairo_serialized_size(&__rust.pool_key);
        __size += I129::cairo_serialized_size(&__rust.amount);
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.sqrt_ratio_limit);
        __size += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&__rust.token);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(PoolKey::cairo_serialize(&__rust.pool_key));
        __out.extend(I129::cairo_serialize(&__rust.amount));
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(
            &__rust.sqrt_ratio_limit,
        ));
        __out.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(
            &__rust.token,
        ));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let pool_key = PoolKey::cairo_deserialize(__felts, __offset)?;
        __offset += PoolKey::cairo_serialized_size(&pool_key);
        let amount = I129::cairo_deserialize(__felts, __offset)?;
        __offset += I129::cairo_serialized_size(&amount);
        let sqrt_ratio_limit = cainome::cairo_serde::U256::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&sqrt_ratio_limit);
        let token = cainome::cairo_serde::ContractAddress::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&token);
        Ok(SwapData {
            pool_key,
            amount,
            sqrt_ratio_limit,
            token,
        })
    }
}
#[derive(PartialEq)]
pub struct SwapResult {
    pub delta: Delta,
}
impl cainome::cairo_serde::CairoSerde for SwapResult {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += Delta::cairo_serialized_size(&__rust.delta);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(Delta::cairo_serialize(&__rust.delta));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let delta = Delta::cairo_deserialize(__felts, __offset)?;
        __offset += Delta::cairo_serialized_size(&delta);
        Ok(SwapResult { delta })
    }
}
#[derive(PartialEq)]
pub enum Event {}
impl cainome::cairo_serde::CairoSerde for Event {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            _ => {
                return Err(cainome::cairo_serde::Error::Deserialize(format!(
                    "Index not handle for enum {}",
                    "Event"
                )));
            }
        }
    }
}
impl TryFrom<&starknet::core::types::EmittedEvent> for Event {
    type Error = String;
    fn try_from(event: &starknet::core::types::EmittedEvent) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        Err(format!(
            "Could not match any event from keys {:?}",
            event.keys
        ))
    }
}
impl TryFrom<&starknet::core::types::Event> for Event {
    type Error = String;
    fn try_from(event: &starknet::core::types::Event) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        Err(format!(
            "Could not match any event from keys {:?}",
            event.keys
        ))
    }
}
impl<A: starknet::accounts::ConnectedAccount + Sync> ContractsSwapper<A> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_withdraw_address(
        &self,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, cainome::cairo_serde::ContractAddress> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_withdraw_address"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn locked_getcall(
        &self,
        id: &u32,
        data: &Vec<starknet::core::types::Felt>,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(id));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(data));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("locked"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn locked(
        &self,
        id: &u32,
        data: &Vec<starknet::core::types::Felt>,
    ) -> starknet::accounts::ExecutionV3<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(u32::cairo_serialize(id));
        __calldata.extend(Vec::<starknet::core::types::Felt>::cairo_serialize(data));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("locked"),
            calldata: __calldata,
        };
        self.account.execute_v3(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn swap_getcall(&self, swap_data: &SwapData) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(SwapData::cairo_serialize(swap_data));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("swap"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn swap(&self, swap_data: &SwapData) -> starknet::accounts::ExecutionV3<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(SwapData::cairo_serialize(swap_data));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("swap"),
            calldata: __calldata,
        };
        self.account.execute_v3(vec![__call])
    }
}
impl<P: starknet::providers::Provider + Sync> ContractsSwapperReader<P> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_withdraw_address(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ContractAddress> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_withdraw_address"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
}
