import os
import re
import shutil
import hashlib
import tempfile
import subprocess
from pathlib import Path
from docutils import nodes
from docutils.parsers.rst import Directive
from sphinx.application import Sphinx
from sphinx.util import logging
from sphinx.util.fileutil import copy_asset_file

logger = logging.getLogger(__name__)

class ABCExtension:
    """Unified ABC extension that supports both RST and Markdown formats"""
    
    def __init__(self, app: Sphinx):
        self.app = app
        self.static_dir = Path(app.outdir) / "_static"
        
        # 为不同格式使用不同的输出目录，避免冲突
        self.abc_images_dir = self.static_dir / "_abc_images"
        self.abc_images_dir.mkdir(parents=True, exist_ok=True)
        
        # 检查abcm2ps是否可用
        self.abcm2ps_available = self._check_abcm2ps()
    
    def _check_abcm2ps(self) -> bool:
        """检查abcm2ps是否可用"""
        try:
            subprocess.run(["abcm2ps", "-V"], capture_output=True, text=True, check=True)
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            logger.error("abcm2ps not found. Please install it. Refer to: https://github.com/lewdlime/abcm2ps")
            return False
    
    @staticmethod
    def ensure_svg_background(svg_path: Path):
        """确保SVG文件有白色背景"""
        try:
            with open(svg_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # 如果已经有 background 样式，跳过
            if 'background' in content or 'rect' in content:
                return

            # 在 <svg> 标签内插入 style 属性
            if '<svg' in content:
                content = content.replace('<svg', '<svg style="background: white;"', 1)

            with open(svg_path, 'w', encoding='utf-8') as f:
                f.write(content)
        except Exception as e:
            logger.warning(f"Failed to add background to SVG: {e}")
    
    def _render_abc_to_svg(self, abc_content: str, options: dict = None, format_type: str = "rst") -> Path:
        """解析ABC代码并使用abcm2ps渲染为SVG文件, 并返回SVG文件路径

        :param str abc_content: ABC代码内容
        :param dict options: 选项字典, 包含staffwidth, scale, voicebreak, landscape
        :param str format_type: 解析文件的文件格式, defaults to "rst"
        :return Path: SVG文件路径
        """
        if not self.abcm2ps_available:
            raise RuntimeError("abcm2ps is not available")
        
        if not abc_content.strip():
            raise ValueError("ABC content is empty")
        
        # 选择适当的输出目录
        images_dir = self.abc_images_dir
        
        # 生成唯一文件名
        content_hash = hashlib.md5(abc_content.encode()).hexdigest()[:10]
        filename = f"abc_{content_hash}.svg"
        svg_path = images_dir / filename
        
        # 检查是否已存在渲染结果
        if svg_path.exists() and not self.app.config.abc_force_rebuild:
            return svg_path
        try:
            # 创建临时目录
            with tempfile.TemporaryDirectory() as tmpdir:
                tmp_path = Path(tmpdir)
                
                # 生成ABC文件
                abc_file = tmp_path / "input.abc"
                with abc_file.open('w') as f:
                    f.write(abc_content)
                
                # 构建abcm2ps命令
                output_file = tmp_path / "output"
                cmd = [
                    "abcm2ps",
                    "-g",  # 生成SVG格式
                    f"-O{output_file}",
                    str(abc_file)
                ]
                
                # 添加选项
                if options:
                    if 'staffwidth' in options and options['staffwidth']:
                        cmd.extend(["-w", str(options['staffwidth'])])
                    if 'scale' in options and options['scale']:
                        cmd.extend(["-s", str(options['scale'])])
                    if 'voicebreak' in options and options['voicebreak']:
                        cmd.extend(["-b", str(options['voicebreak'])])
                    if 'landscape' in options and options['landscape']:
                        cmd.extend(["-l"])
                
                # 执行渲染
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    cwd=tmpdir
                )
                
                if result.returncode != 0:
                    error_msg = f"abcm2ps failed: {result.stderr}"
                    logger.error(error_msg)
                    raise RuntimeError(error_msg)
                
                # 查找生成的SVG文件
                svg_files = list(tmp_path.glob("output*.svg"))
                if not svg_files:
                    error_msg = "No SVG file generated by abcm2ps"
                    logger.error(error_msg)
                    raise RuntimeError(error_msg)
                
                # 复制到最终位置
                shutil.copy(svg_files[0], svg_path)
                self.ensure_svg_background(svg_path)
        
        except Exception as e:
            logger.error(f"ABC rendering error: {str(e)}")
            raise
        
        return svg_path
    
    def _get_svg_url(self, svg_path: Path) -> str:
        """获取SVG文件的URL路径"""
        rel_path = svg_path.relative_to(self.static_dir)
        return f"/_static/{rel_path.as_posix()}"
    
    def render_rst(self, abc_content: str, options: dict = None, caption: str = None) -> list:
        """RST专用渲染方法"""
        try:
            svg_path = self._render_abc_to_svg(abc_content, options)
            svg_url = self._get_svg_url(svg_path)
            
            # 创建HTML
            raw_html = (
                f'<div class="abc-container">\n'
                f'  <img src="{svg_url}" '
                f'class="abc-rendered" alt="abc music - {svg_path.name}" />\n'
                f'</div>'
            )

            # 创建 raw 节点
            raw_node = nodes.raw('', raw_html, format='html')

            # 如果有标题，用 figure 包裹
            if caption:
                caption_node = nodes.caption(text=caption)
                figure_node = nodes.figure('', raw_node, caption_node)
                return [figure_node]

            return [raw_node]
            
        except Exception as e:
            error_msg = f"ABC rendering error: {str(e)}"
            logger.error(error_msg)
            return [nodes.error(text=error_msg)]
    
    def render_md(self, abc_content: str) -> str:
        """Markdown专用渲染方法"""
        try:
            svg_path = self._render_abc_to_svg(abc_content, None)
            svg_url = self._get_svg_url(svg_path)
            
            # 创建图像标签
            return f'<div class="abc-container"><img src="{svg_url}" alt=f"{svg_path.name} ABC Notation" class="abc-rendered"></div>'
        
        except Exception as e:
            logger.error(f"ABC processing error: {str(e)}")
            return f'<div class="abc-error">Error rendering ABC: {str(e)}</div>'


class ABCDirective(Directive):
    """Sphinx directive for rendering ABC music notation in RST files"""
    required_arguments = 0
    optional_arguments = 1
    final_argument_whitespace = True
    has_content = True
    
    option_spec = {
        'staffwidth': int,
        'scale': float,
        'voicebreak': int,
        'landscape': bool,
    }

    def run(self):
        # 获取ABC代码内容
        abc_content = '\n'.join(self.content)
        
        if not abc_content.strip():
            return [nodes.error(text="ABC directive has no content")]
        
        # 获取指令选项和标题
        options = dict(self.options)
        caption = self.arguments[0] if self.arguments else None
        
        # 通过app获取统一扩展
        app = self.state.document.settings.env.app
        if not hasattr(app, 'abc_extension'):
            app.abc_extension = ABCExtension(app)
        
        # 使用统一扩展渲染
        return app.abc_extension.render_rst(abc_content, options, caption)


def on_source_read(app: Sphinx, docname: str, source: list):
    """读取源文件时处理ABC代码块"""
    
    # 正确获取源文件路径并检查扩展名
    source_file = app.env.doc2path(docname)
    
    # 检查是否是Markdown文件
    if str(source_file).endswith('.md'):
        # 初始化扩展（如果尚未初始化）
        if not hasattr(app, 'abc_extension'):
            app.abc_extension = ABCExtension(app)
        
        # 改进的正则表达式，匹配各种代码块变体
        pattern = r'(?P<indent>[ \t]*)```(?P<lang>abc|ABC)[ \t]*([^\n]*\n)?(?P<content>(?:.|\n)*?)(?P=indent)```'
        
        def replace_abc_block(match):
            indent = match.group('indent')
            content = match.group('content').strip()
            return indent + app.abc_extension.render_md(content)
        
        # 处理Markdown中的ABC代码块
        source[0] = re.sub(
            pattern, 
            replace_abc_block, 
            source[0], 
            flags=re.IGNORECASE | re.MULTILINE
        )


def copy_abc_assets(app, exception):
    """复制ABC扩展的静态资源文件"""
    if exception:
        logger.warning("Exception occurred, skipping ABC assets copy")
        return
    
    # 获取源CSS文件路径
    src_dir = os.path.dirname(__file__)
    css_src = os.path.join(src_dir, "abc.css")
    
    # 目标目录
    static_dir = os.path.join(app.outdir, "_static")
    
    # 确保目标目录存在
    os.makedirs(static_dir, exist_ok=True)
    
    # 检查源文件是否存在
    if os.path.isfile(css_src):
        try:
            copy_asset_file(css_src, static_dir)
            logger.info(f"Copied ABC CSS to {static_dir}")
        except Exception as e:
            logger.warning(f"Failed to copy ABC CSS: {str(e)}")
    else:
        logger.warning(f"ABC CSS file not found: {css_src}")


def setup(app: Sphinx):
    """设置统一的ABC扩展"""
    
    # 设置RST处理
    app.add_directive("abc", ABCDirective)
    # 添加共享配置
    app.add_config_value("abc_force_rebuild", False, "env")
    # app.connect("builder-inited", lambda app: os.makedirs(
    #     os.path.join(app.outdir, "_static/_abc_images"), exist_ok=True))
    
    app.connect("source-read", on_source_read)  # 设置Markdown处理
    app.connect("build-finished", copy_abc_assets)  # 复制CSS资源
    app.add_css_file("abc.css")  # 添加CSS
    
    return {
        'version': '1.2',
        'parallel_read_safe': True,
        'parallel_write_safe': True
    }
