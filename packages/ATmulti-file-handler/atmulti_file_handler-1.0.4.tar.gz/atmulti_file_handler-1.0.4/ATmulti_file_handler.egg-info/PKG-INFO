Metadata-Version: 2.4
Name: ATmulti_file_handler
Version: 1.0.4
Summary: A flexible file handler supporting text, JSON, YAML, CSV, XML, dill, and binary formats.
Home-page: https://github.com/avitwil/ATmulti_file_handler
Author: Avi Twil
Author-email: avitwil@gmail.com
Classifier: Programming Language :: Python :: 3
Classifier: Operating System :: OS Independent
Classifier: License :: OSI Approved :: MIT License
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: pyyaml>=6.0
Requires-Dist: dill>=0.3.7
Requires-Dist: avi_tools>=1.0.9
Dynamic: author
Dynamic: author-email
Dynamic: classifier
Dynamic: description
Dynamic: description-content-type
Dynamic: home-page
Dynamic: license-file
Dynamic: requires-dist
Dynamic: summary


````markdown
# ATmulti_file_handler

**ATmulti_file_handler** is a Python package for seamless reading and writing of multiple file formats with a unified, object-oriented API.  
It supports text, JSON, YAML, CSV, XML, pickle-like (Dill), raw binary files, and database-backed variable storage using `VariableDB` â€” all under a common interface.

---

## âœ… Features

- Unified interface using a `File` protocol
- Automatic file creation (optional)
- Built-in support for:
  - Plain text (`.txt`)
  - JSON (`.json`)
  - YAML (`.yaml`, `.yml`)
  - CSV (`.csv`)
  - XML (`.xml`)
  - Serialized binary using `dill` (`.pkl`, `.dill`)
  - Raw binary (`.bin`, `.dat`, etc.)
  - Database-backed variable storage using `VariableDB`
- Easy extension for other formats
- Append support where applicable
- `open_file` function to auto-create appropriate file Class

---

## ðŸ“¦ Installation

Install via pip:

```bash
pip install ATmulti_file_handler
````

---

## ðŸ§ª Supported File Types and Usage

### VariableDBFile

```python
from ATmulti_file_handler import DBFile
from avi_tools import VariableDB

# Initialize VariableDB
scope = globals()  # You can also define a custom dict
data = {"version": "1.0.0"}

# Create VariableDBFile instance
db_file = DBFile("variables.db", scope=scope, data=data)

# Access and modify data
print(db_file.read())
db_file.add("new_var", 42)
print(db_file.read())
```

---

### TextFile

```python
from ATmulti_file_handler import TextFile

txt = TextFile("example.txt")
txt.write("Hello world")
print(txt.read())
txt.append("\nThis is appended.")
```

---

### JsonFile

```python
from ATmulti_file_handler import JsonFile

js = JsonFile("data.json")
js.write({"name": "Alice"})
print(js.read())
js.append(("age", 30))  # appends key-value
```

---

### YamlFile

```python
from ATmulti_file_handler import YamlFile

yml = YamlFile("config.yaml")
yml.write({"env": "dev"})
print(yml.read())
yml.append({"version": "1.0.0"})
```

---

### CsvFile

```python
from ATmulti_file_handler import CsvFile

csvf = CsvFile("people.csv")
csvf.write([
    {"name": "Alice", "age": 30},
    {"name": "Bob", "age": 25}
])
print(csvf.read())
csvf.append({"name": "Charlie", "age": 22})
```

---

### XmlFile

```python
from ATmulti_file_handler import XmlFile
import xml.etree.ElementTree as ET

xmlf = XmlFile("data.xml")
root = ET.Element("people")
person = ET.Element("person")
person.set("name", "Alice")
root.append(person)
xmlf.write(root)

# Append new element
new_person = ET.Element("person")
new_person.set("name", "Bob")
xmlf.append(new_person)

print(ET.tostring(xmlf.read()))
```

---

### DillFile

```python
from ATmulti_file_handler import DillFile

dillf = DillFile("model.dill")
dillf.write({"model": [1, 2, 3]})
print(dillf.read())
```

---

### ByteFile

```python
from ATmulti_file_handler import ByteFile

bf = ByteFile("raw.bin")
bf.write(b'\x00\x01\x02')
print(bf.read())
```

---

## ðŸ§  Design Philosophy

All file types inherit from a shared base class `BaseFile`, which handles:

* Path creation and validation
* Auto-creation of empty files
* Unified error handling
* Standard interface: `read()` and `write()`
  Some classes also provide `append()` methods.

You can work with any file using the shared `File` protocol:

```python
from ATmulti_file_handler import File

def process_file(f: File):
    print("File contents:", f.read())
```

---

## ðŸ”§ `open_file` Function

The `open_file` function automatically determines the appropriate file handler class based on the file extension and returns an instance of that class.

```python
from ATmulti_file_handler import open_file

file = open_file("data.json")
file.write({"name": "Alice"})
print(file.read())
```

---

## ðŸ“„ License

This project is licensed under the MIT License.

---

## ðŸ”— Project Links

* **PyPI**: [https://pypi.org/project/ATmulti\_file\_handler](https://pypi.org/project/ATmulti_file_handler)
* **GitHub**: [https://github.com/avitwil/ATmulti\_file\_handler](https://github.com/avitwil/ATmulti_file_handler)

---

## ðŸ‘¤ Author

**Avi Twil**

---

## ðŸ§© Future Features (Ideas)

* Support for Excel (.xlsx) via `openpyxl`
* Automatic schema inference for CSV
* Logging and error handling improvements
* GUI/CLI integration

```

---

### Explanation of Changes

- **DBFile**: A new class that integrates `VariableDB` for database-backed variable storage. It uses the `add` method to insert data, ensuring that existing data is not overwritten.
  
- **open_file Function**: A utility function that automatically selects the appropriate file handler class based on the file extension, simplifying file handling operations.

- **Updated Examples**: The usage examples now include `VariableDBFile` and demonstrate the new `open_file` function.

If you need further assistance or modifications, feel free to ask!
::contentReference[oaicite:0]{index=0}
 
```
