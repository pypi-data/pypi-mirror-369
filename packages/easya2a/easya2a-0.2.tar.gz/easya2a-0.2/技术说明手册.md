# EasyA2A 技术说明手册

> **版本**: 2.0.0 | **更新时间**: 2025-01-14 | **API版本**: 三步式设计

## 📋 目录

1. [架构设计](#架构设计)
2. [核心组件](#核心组件)
3. [三步式API设计](#三步式api设计)
4. [实现细节](#实现细节)
5. [配置系统](#配置系统)
6. [Agent适配器](#agent适配器)
7. [A2A协议集成](#a2a协议集成)
8. [扩展开发](#扩展开发)
9. [性能优化](#性能优化)
10. [监控与调试](#监控与调试)
11. [部署指南](#部署指南)
12. [故障排除](#故障排除)

## 🏗️ 架构设计

### 整体架构 (v2.0)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           EasyA2A 2.0 架构图                                │
├─────────────────────────────────────────────────────────────────────────────┤
│  🎯 用户接口层 (三步式API)                                                   │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │ A2AAgentWrapper.set_up(agent, "名称", "描述")                           │ │
│  │   .add_skill("weather", "天气查询", examples=["北京天气"])                │ │
│  │   .set_provider("Weather AI", "https://weather.ai")                    │ │
│  │   .enable_streaming().enable_history()                                 │ │
│  │   .run_a2a(port=10010, host="0.0.0.0")                                │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│  🔧 EasyA2A 核心层                                                          │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────┐ │
│  │ A2AAgentWrapper │ │  ConfigManager  │ │ ExecutorFactory │ │ AgentAdapter│ │
│  │  (API入口)       │ │  (配置构建)      │ │  (执行器工厂)    │ │ (Agent适配) │ │
│  │                 │ │                 │ │                 │ │             │ │
│  │ • 链式调用      │ │ • 延迟构建      │ │ • 类型检测      │ │ • LangChain │ │
│  │ • 状态管理      │ │ • 智能默认值    │ │ • 执行器选择    │ │ • OpenAI    │ │
│  │ • 生命周期      │ │ • 配置验证      │ │ • 异步支持      │ │ • Custom    │ │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘ └─────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│  📡 A2A 协议层                                                              │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────┐ │
│  │   AgentCard     │ │ RequestHandler  │ │   TaskStore     │ │ EventSystem │ │
│  │  (Agent元数据)   │ │  (请求路由)      │ │  (任务管理)      │ │ (事件处理)  │ │
│  │                 │ │                 │ │                 │ │             │ │
│  │ • 技能描述      │ │ • HTTP路由      │ │ • 内存存储      │ │ • 生命周期  │ │
│  │ • 能力声明      │ │ • 参数验证      │ │ • 状态跟踪      │ │ • 钩子函数  │ │
│  │ • 示例展示      │ │ • 错误处理      │ │ • 并发控制      │ │ • 插件系统  │ │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘ └─────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│  🌐 Web服务层                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                    A2AStarletteApplication                              │ │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐ │ │
│  │  │   ASGI      │ │  Middleware │ │   Routing   │ │    Health Check     │ │ │
│  │  │   Server    │ │   Stack     │ │   System    │ │      System         │ │ │
│  │  │             │ │             │ │             │ │                     │ │ │
│  │  │ • Uvicorn   │ │ • CORS      │ │ • /invoke   │ │ • /health           │ │ │
│  │  │ • 异步处理  │ │ • 日志记录  │ │ • /stream   │ │ • /.well-known/     │ │ │
│  │  │ • 连接池    │ │ • 限流控制  │ │ • /status   │ │   agent-card.json   │ │ │
│  │  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 核心设计理念

1. **🎯 用户体验优先** - 三步式API设计，降低认知负担
2. **🔧 组件化架构** - 松耦合设计，支持独立测试和扩展
3. **📡 协议标准化** - 完全符合A2A协议规范
4. **⚡ 性能优化** - 异步处理，连接池，延迟加载
5. **🛡️ 健壮性** - 完善的错误处理和恢复机制
6. **🔍 可观测性** - 内置监控、日志和调试支持

### 技术栈

| 层级 | 技术组件 | 版本要求 | 作用 |
|------|----------|----------|------|
| **用户接口** | A2AAgentWrapper | 2.0+ | 三步式API入口 |
| **核心框架** | Python | 3.8+ | 运行时环境 |
| **Web框架** | Starlette/FastAPI | 0.20+ | ASGI Web服务 |
| **服务器** | Uvicorn | 0.20+ | ASGI服务器 |
| **A2A协议** | a2a-sdk | 0.3+ | A2A协议实现 |
| **AI框架** | LangChain | 0.1+ | Agent框架支持 |
| **数据验证** | Pydantic | 2.0+ | 数据模型验证 |
| **异步处理** | asyncio | 内置 | 异步编程支持 |

### 架构特性

#### 🎯 **三步式API设计**
- **第一步**: `set_up()` - 必须参数初始化
- **第二步**: 链式配置 - 可选参数逐步添加
- **第三步**: `run_a2a()` - 服务启动和运行

#### 🔧 **模块化组件**
- **配置管理**: 延迟构建，智能默认值
- **执行器工厂**: 自动Agent类型检测和适配
- **协议适配**: 无缝A2A协议集成
- **服务管理**: 完整的生命周期管理

## 🔧 核心组件

### 1. A2AAgentWrapper (核心入口)

**文件位置**: `easya2a/core/agent_wrapper.py`

**职责**: 三步式API的核心实现，用户交互的主要入口

```python
class A2AAgentWrapper:
    def __init__(self, agent: Any, name: str, description: str):
        """内部初始化，存储Agent和基本信息"""
        self.agent = agent
        self.name = name
        self.description = description

        # 内部配置状态
        self._skills: List[AgentSkillConfig] = []
        self._provider_organization = "EasyA2A Agent Services"
        self._provider_url = ""
        self._version = "1.0.0"

        # 能力配置
        self._streaming = False
        self._push_notifications = True
        self._state_history = False
        self._multimodal = False

        # 输入输出模式
        self._input_modes = ["text", "text/plain", "application/json"]
        self._output_modes = ["text", "text/plain", "application/json"]

    @classmethod
    def set_up(cls, agent: Any, name: str, description: str) -> "A2AAgentWrapper":
        """第一步：初始化 - 工厂方法"""
        return cls(agent, name, description)

    def add_skill(self, skill_id: str, name: str, **kwargs) -> "A2AAgentWrapper":
        """第二步：链式配置 - 添加技能"""
        skill = AgentSkillConfig(
            id=skill_id,
            name=name,
            description=kwargs.get('description', f"{name}功能"),
            examples=kwargs.get('examples', []),
            tags=kwargs.get('tags', [])
        )
        self._skills.append(skill)
        return self  # 关键：返回self支持链式调用

    def run_a2a(self, port: int = 10010, host: str = "0.0.0.0") -> None:
        """第三步：启动服务 - 构建配置并启动A2A服务"""
        config = self._build_config(port, host)
        self._show_startup_info(config)
        self._create_executor(config)
        self._create_server_app(config)
        self._start_server(host, port)
```

**核心特性**:
- ✅ **状态管理**: 内部维护所有配置状态
- ✅ **链式调用**: 所有配置方法返回self
- ✅ **延迟构建**: 配置在run_a2a时才最终构建
- ✅ **类型安全**: 完整的类型注解支持
- ✅ **错误处理**: 配置验证和错误提示

### 2. 配置系统 (Configuration System)

**文件位置**: `easya2a/config/agent_config.py`

#### AgentConfig (主配置类)

```python
@dataclass
class AgentConfig:
    """Agent完整配置 - 所有配置的最终汇总"""

    # === 基本信息 ===
    name: str                                    # Agent名称 (必填)
    description: str = ""                        # Agent描述
    version: str = "1.0.0"                      # Agent版本

    # === 服务器配置 ===
    host: str = "0.0.0.0"                       # 服务器监听地址
    port: int = 10010                           # 服务器端口
    agent_url: Optional[str] = None              # Agent Card中的URL

    # === 提供商信息 ===
    provider_organization: str = "EasyA2A Agent Services"  # 提供商组织
    provider_url: Optional[str] = None           # 提供商网站

    # === 技能和能力 ===
    skills: List[AgentSkillConfig] = field(default_factory=list)
    capabilities: Optional[AgentCapabilityConfig] = None

    # === 输入输出模式 ===
    default_input_modes: List[str] = field(
        default_factory=lambda: ["text", "text/plain", "application/json"]
    )
    default_output_modes: List[str] = field(
        default_factory=lambda: ["text", "text/plain", "application/json"]
    )

    # === LangChain特定配置 ===
    langchain_config: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """初始化后处理 - 设置智能默认值"""
        if self.agent_url is None:
            self.agent_url = f"http://{self.host}:{self.port}/"

        if self.provider_url is None:
            self.provider_url = self.agent_url

        if self.capabilities is None:
            self.capabilities = AgentCapabilityConfig()
```

#### AgentSkillConfig (技能配置)

```python
@dataclass
class AgentSkillConfig:
    """Agent技能配置 - 定义Agent的具体能力"""

    id: str                           # 技能唯一标识 (必填)
    name: str                         # 技能名称 (必填)
    description: str                  # 技能描述 (必填)
    tags: List[str] = field(default_factory=list)      # 技能标签
    examples: List[str] = field(default_factory=list)  # 使用示例

    def to_dict(self) -> Dict[str, Any]:
        """转换为字典格式，用于Agent Card生成"""
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "tags": self.tags,
            "examples": self.examples
        }
```

#### AgentCapabilityConfig (能力配置)

```python
@dataclass
class AgentCapabilityConfig:
    """Agent能力配置 - 定义Agent支持的协议能力"""

    streaming: bool = False                    # 是否支持流式响应
    push_notifications: bool = True            # 是否支持推送通知
    state_transition_history: bool = False    # 是否记录状态转换历史
    multimodal: bool = False                   # 是否支持多模态输入

    def to_dict(self) -> Dict[str, Any]:
        """转换为A2A协议格式"""
        return {
            "streaming": self.streaming,
            "push_notifications": self.push_notifications,
            "state_transition_history": self.state_transition_history,
            "multimodal": self.multimodal
        }
```

### 3. 执行器系统 (Executor System)

**文件位置**: `easya2a/core/executor.py`

#### ExecutorFactory (执行器工厂)

```python
class ExecutorFactory:
    """执行器工厂 - 根据Agent类型自动选择合适的执行器"""

    @staticmethod
    def create_executor(agent: Any, name: str, description: str, **kwargs) -> BaseAgentExecutor:
        """智能Agent类型检测和执行器创建"""

        # LangChain Agent检测
        if hasattr(agent, 'invoke') and hasattr(agent, 'ainvoke'):
            logger.info("检测到LangChain Agent，使用LangChainAgentExecutor")
            return LangChainAgentExecutor(agent, name, description, **kwargs)

        # OpenAI Assistant检测
        elif hasattr(agent, 'create_thread') and hasattr(agent, 'run'):
            logger.info("检测到OpenAI Assistant，使用OpenAIAssistantExecutor")
            return OpenAIAssistantExecutor(agent, name, description, **kwargs)

        # 聊天接口检测
        elif hasattr(agent, 'chat') or hasattr(agent, 'process'):
            logger.info("检测到Chat接口，使用ChatAgentExecutor")
            return ChatAgentExecutor(agent, name, description, **kwargs)

        # 函数调用接口检测
        elif callable(agent):
            logger.info("检测到可调用对象，使用FunctionAgentExecutor")
            return FunctionAgentExecutor(agent, name, description, **kwargs)

        # 通用执行器
        else:
            logger.warning("未识别Agent类型，使用GenericAgentExecutor")
            return GenericAgentExecutor(agent, name, description, **kwargs)
```

#### BaseAgentExecutor (执行器基类)

```python
class BaseAgentExecutor:
    """Agent执行器基类 - 定义统一的执行接口"""

    def __init__(self, agent: Any, name: str, description: str):
        self.agent = agent
        self.name = name
        self.description = description
        self.logger = logging.getLogger(f"executor.{name}")

    async def execute(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """异步执行Agent请求 - 子类必须实现"""
        raise NotImplementedError("子类必须实现execute方法")

    def execute_sync(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """同步执行Agent请求 - 默认实现"""
        import asyncio
        return asyncio.run(self.execute(request))

    def get_capabilities(self) -> Dict[str, Any]:
        """获取执行器能力信息"""
        return {
            "name": self.name,
            "description": self.description,
            "agent_type": type(self.agent).__name__,
            "supports_async": True,
            "supports_streaming": False
        }
```

#### LangChainAgentExecutor (LangChain专用)

```python
class LangChainAgentExecutor(BaseAgentExecutor):
    """LangChain Agent执行器 - 支持invoke和ainvoke接口"""

    async def execute(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """执行LangChain Agent"""
        try:
            input_data = request.get("input", "")

            # 优先使用异步接口
            if hasattr(self.agent, 'ainvoke'):
                result = await self.agent.ainvoke({"input": input_data})
            else:
                # 同步接口在线程池中执行
                import asyncio
                loop = asyncio.get_event_loop()
                result = await loop.run_in_executor(
                    None,
                    lambda: self.agent.invoke({"input": input_data})
                )

            return {
                "output": result.get("output", str(result)),
                "status": "success",
                "agent": self.name
            }

        except Exception as e:
            self.logger.error(f"LangChain Agent执行失败: {e}")
            return {
                "output": f"执行失败: {str(e)}",
                "status": "error",
                "agent": self.name
            }

    def get_capabilities(self) -> Dict[str, Any]:
        """LangChain特定能力"""
        caps = super().get_capabilities()
        caps.update({
            "supports_tools": hasattr(self.agent, 'tools'),
            "supports_memory": hasattr(self.agent, 'memory'),
            "langchain_version": getattr(self.agent, '__version__', 'unknown')
        })
        return caps
```

## 🎨 三步式API设计

### 三步式设计模式详解

#### 🎯 第一步：初始化 (Initialization)

```python
wrapper = A2AAgentWrapper.set_up(agent, name, description)
```

**目的**: 创建包装器实例，设置必须参数
**参数**:
- `agent`: 要包装的Agent实例 (任何类型)
- `name`: Agent名称 (用于标识和显示)
- `description`: Agent描述 (用于Agent Card)

**设计理念**: 只要求最基本的信息，降低使用门槛

#### ⚙️ 第二步：链式配置 (Chain Configuration)

```python
wrapper.add_skill("chat", "聊天功能", examples=["你好"]) \
       .add_skill("search", "搜索功能", examples=["搜索信息"]) \
       .set_provider("AI Corp", "https://ai.corp.com") \
       .set_version("2.0.0") \
       .enable_streaming() \
       .enable_history() \
       .enable_multimodal()
```

**目的**: 渐进式配置，用户可以按需添加功能
**特点**:
- 所有方法返回`self`，支持链式调用
- 可选配置，不影响基本功能
- 智能默认值，减少配置工作

#### 🚀 第三步：启动服务 (Service Launch)

```python
wrapper.run_a2a(port=10010, host="0.0.0.0")
```

**目的**: 构建最终配置并启动A2A服务
**流程**:
1. 配置验证和构建
2. 创建执行器
3. 创建A2A服务器应用
4. 启动Web服务

### API设计优势

| 优势 | 传统方式 | 三步式API |
|------|----------|-----------|
| **学习成本** | 需要理解复杂配置对象 | 只需理解3个步骤 |
| **代码量** | 50+ 行配置代码 | 10-15 行 |
| **错误发现** | 运行时错误 | 配置时错误 |
| **可读性** | 嵌套配置难读 | 链式调用清晰 |
| **扩展性** | 修改配置类 | 添加链式方法 |

### 方法命名规范

| 前缀 | 含义 | 返回值 | 示例 |
|------|------|--------|------|
| `set_up()` | 类方法初始化 | 新实例 | `A2AAgentWrapper.set_up()` |
| `add_` | 添加配置项 | self | `add_skill()`, `add_plugin()` |
| `set_` | 设置单个值 | self | `set_provider()`, `set_version()` |
| `enable_` | 启用功能 | self | `enable_streaming()`, `enable_history()` |
| `run_` | 执行操作 | None/结果 | `run_a2a()` |

### 链式调用实现原理

```python
def add_skill(self, skill_id: str, name: str, **kwargs) -> "A2AAgentWrapper":
    """链式方法的标准实现模式"""

    # 1. 执行具体逻辑
    skill = AgentSkillConfig(id=skill_id, name=name, **kwargs)
    self._skills.append(skill)

    # 2. 记录日志
    logger.debug(f"添加技能: {name}")

    # 3. 返回self支持链式调用
    return self  # 关键！
```

**核心原则**:
- 每个配置方法都返回`self`
- 状态修改在内部完成
- 延迟验证，在`run_a2a()`时统一处理

## ⚙️ 实现细节

### 链式调用实现

```python
def add_skill(self, skill_id: str, name: str, **kwargs) -> "A2AAgentWrapper":
    """添加技能配置"""
    skill = AgentSkillConfig(
        id=skill_id,
        name=name,
        description=kwargs.get('description', f"{name}功能"),
        examples=kwargs.get('examples', []),
        tags=kwargs.get('tags', [])
    )
    self._skills.append(skill)
    return self  # 关键：返回self支持链式调用
```

### 配置构建策略

```python
def _build_config(self, port: int, host: str) -> AgentConfig:
    """延迟配置构建 - 在run_a2a时才构建完整配置"""
    
    # 设置默认值
    if not self._agent_url:
        self._agent_url = f"http://localhost:{port}/"
    
    # 构建能力配置
    capabilities = AgentCapabilityConfig(
        streaming=self._streaming,
        push_notifications=self._push_notifications,
        state_transition_history=self._state_history,
        multimodal=self._multimodal
    )
    
    # 构建完整配置
    return AgentConfig(
        name=self.name,
        description=self.description,
        # ... 其他配置
    )
```

### 服务启动流程

```python
def run_a2a(self, port: int = 10010, host: str = "0.0.0.0"):
    """服务启动的完整流程"""
    
    # 1. 构建配置
    config = self._build_config(port, host)
    
    # 2. 显示启动信息
    self._show_startup_info(config)
    
    # 3. 创建执行器
    self._create_executor(config)
    
    # 4. 创建服务器应用
    self._create_server_app(config)
    
    # 5. 启动服务
    self._start_server(host, port)
```

## 🔌 Agent适配器

### Agent类型检测

EasyA2A支持多种类型的Agent，通过智能检测自动选择合适的适配器：

#### 支持的Agent类型

| Agent类型 | 检测条件 | 执行器 | 特性 |
|-----------|----------|--------|------|
| **LangChain Agent** | `hasattr(agent, 'invoke')` | `LangChainAgentExecutor` | 完整LangChain生态支持 |
| **OpenAI Assistant** | `hasattr(agent, 'create_thread')` | `OpenAIAssistantExecutor` | OpenAI Assistant API |
| **Chat Interface** | `hasattr(agent, 'chat')` | `ChatAgentExecutor` | 简单聊天接口 |
| **Process Interface** | `hasattr(agent, 'process')` | `ProcessAgentExecutor` | 通用处理接口 |
| **Function** | `callable(agent)` | `FunctionAgentExecutor` | 函数式Agent |
| **Generic** | 其他情况 | `GenericAgentExecutor` | 通用适配器 |

#### LangChain Agent适配

```python
# 支持的LangChain Agent类型
from langchain.agents import AgentExecutor, create_tool_calling_agent
from langchain.schema import BaseAgent

# 自动检测和适配
if hasattr(agent, 'invoke') and hasattr(agent, 'ainvoke'):
    # 使用LangChain专用执行器
    executor = LangChainAgentExecutor(agent, name, description)

    # 支持的功能
    # ✅ 同步调用: agent.invoke({"input": "message"})
    # ✅ 异步调用: await agent.ainvoke({"input": "message"})
    # ✅ 工具调用: 自动检测agent.tools
    # ✅ 内存管理: 自动检测agent.memory
```

#### 自定义Agent适配

```python
class CustomAgent:
    """自定义Agent示例"""

    def __init__(self, model_name: str):
        self.model_name = model_name

    def process(self, message: str) -> str:
        """处理消息的标准接口"""
        return f"[{self.model_name}] 处理: {message}"

    def chat(self, message: str) -> str:
        """聊天接口"""
        return f"[{self.model_name}] 回复: {message}"

# 自动适配
custom_agent = CustomAgent("GPT-4")
wrapper = A2AAgentWrapper.set_up(custom_agent, "自定义助手", "自定义Agent示例")
# 会自动检测到chat方法，使用ChatAgentExecutor
```

## 📡 A2A协议集成

### Agent Card生成

EasyA2A自动生成符合A2A协议标准的Agent Card：

```json
{
  "name": "天气助手",
  "description": "智能天气查询服务",
  "version": "1.0.0",
  "url": "http://localhost:10010/",
  "provider": {
    "organization": "Weather AI Services",
    "url": "https://weather-ai.example.com"
  },
  "capabilities": {
    "streaming": false,
    "push_notifications": true,
    "state_transition_history": true,
    "multimodal": false
  },
  "default_input_modes": ["text", "text/plain", "application/json"],
  "default_output_modes": ["text", "text/plain", "application/json"],
  "skills": [
    {
      "id": "weather_query",
      "name": "天气查询",
      "description": "查询城市天气信息",
      "tags": ["weather", "query"],
      "examples": ["北京天气怎么样？", "上海会下雨吗？"]
    }
  ]
}
```

### A2A协议端点

EasyA2A自动创建标准的A2A协议端点：

| 端点 | 方法 | 功能 | 示例 |
|------|------|------|------|
| `/.well-known/agent-card.json` | GET | Agent Card | 获取Agent元数据 |
| `/invoke` | POST | 同步调用 | 发送消息并等待响应 |
| `/stream` | POST | 流式调用 | 流式响应 (如果支持) |
| `/status` | GET | 状态查询 | 获取Agent状态 |
| `/health` | GET | 健康检查 | 服务健康状态 |

### 协议兼容性

```python
# A2A协议标准请求格式
{
  "input": "用户消息",
  "context": {
    "session_id": "session_123",
    "user_id": "user_456"
  },
  "parameters": {
    "temperature": 0.7,
    "max_tokens": 1000
  }
}

# A2A协议标准响应格式
{
  "output": "Agent响应",
  "status": "success",
  "metadata": {
    "agent": "天气助手",
    "version": "1.0.0",
    "timestamp": "2025-01-14T10:30:00Z"
  }
}
```

## 🔧 配置系统

### 配置优先级

1. **用户显式配置** - 用户通过方法设置的值
2. **智能默认值** - 根据上下文推断的默认值
3. **系统默认值** - 硬编码的默认值

### 配置验证

```python
def _validate_config(self, config: AgentConfig):
    """配置验证"""
    if not config.name:
        raise ValueError("Agent名称不能为空")
    
    if not config.skills:
        logger.warning("未配置技能，将使用默认技能")
    
    if config.port < 1024:
        logger.warning(f"端口 {config.port} 可能需要管理员权限")
```

### 环境变量支持

```python
# 支持环境变量配置
EASYA2A_DEFAULT_PORT=10010
EASYA2A_DEFAULT_HOST=0.0.0.0
EASYA2A_PROVIDER_ORG="My AI Services"
```

## 🚀 扩展开发

### 自定义执行器

```python
class CustomAgentExecutor(BaseAgentExecutor):
    def __init__(self, agent, name, description):
        super().__init__(agent, name, description)
    
    async def execute(self, request):
        """自定义执行逻辑"""
        # 实现你的执行逻辑
        pass
```

### 自定义技能模板

```python
class CustomSkillTemplates:
    @staticmethod
    def database_skill() -> AgentSkillConfig:
        return AgentSkillConfig(
            id="database",
            name="数据库查询",
            description="执行数据库查询操作",
            tags=["database", "sql", "query"],
            examples=["查询用户数据", "统计订单数量"]
        )
```

### 插件系统

```python
class A2APlugin:
    def before_start(self, wrapper: A2AAgentWrapper):
        """服务启动前的钩子"""
        pass
    
    def after_start(self, wrapper: A2AAgentWrapper):
        """服务启动后的钩子"""
        pass

# 使用插件
wrapper.add_plugin(LoggingPlugin())
wrapper.add_plugin(MetricsPlugin())
```

## 📊 监控与调试

### 内置监控

EasyA2A提供完整的监控和调试支持：

#### 启动信息显示

```python
# run_a2a()会自动显示详细的启动信息
🎯 天气助手 启动完成
==================================================
📋 名称: 天气助手
📝 描述: 智能天气查询服务
🔢 版本: 1.0.0
🏢 提供商: Weather AI Services
🌐 提供商网站: https://weather-ai.example.com

🖥️ 服务地址: http://localhost:10010
📡 Agent Card: http://localhost:10010/.well-known/agent-card.json
🎯 技能数量: 2

⚡ 能力:
  • 流式响应: ❌
  • 推送通知: ✅
  • 状态历史: ✅
  • 多模态: ❌

🎯 支持技能:
  • 天气查询: 查询城市天气信息
    示例: 北京天气怎么样？
  • 天气建议: 提供穿衣建议
    示例: 今天穿什么？
==================================================
🚀 服务启动中...
```

#### 日志系统

```python
import logging

# 启用详细日志
logging.basicConfig(level=logging.DEBUG)

# EasyA2A使用结构化日志
logger = logging.getLogger("easya2a")
logger.info("🎁 A2AAgentWrapper初始化: 天气助手")
logger.debug("添加技能: 天气查询")
logger.info("⚙️ Agent执行器创建成功: LangChainAgentExecutor")
logger.info("🌐 A2A服务器应用创建成功")
```

#### 健康检查端点

```python
# GET /health
{
  "status": "healthy",
  "agent": {
    "name": "天气助手",
    "version": "1.0.0",
    "type": "LangChainAgent"
  },
  "server": {
    "uptime": "00:05:23",
    "requests_handled": 42,
    "last_request": "2025-01-14T10:30:00Z"
  },
  "capabilities": {
    "streaming": false,
    "multimodal": false
  }
}
```

### 调试模式

```python
# 启用调试模式
A2AAgentWrapper.set_up(agent, "调试助手", "调试模式测试") \
               .add_skill("debug", "调试功能") \
               .run_a2a(port=10010, debug=True)  # 启用调试

# 调试模式特性:
# ✅ 详细的请求/响应日志
# ✅ 错误堆栈跟踪
# ✅ 性能计时信息
# ✅ 配置验证详情
```

## 🚀 部署指南

### 本地开发部署

```python
# 开发环境配置
A2AAgentWrapper.set_up(agent, "开发助手", "开发环境") \
               .add_skill("test", "测试功能") \
               .run_a2a(
                   port=10010,
                   host="127.0.0.1",  # 仅本地访问
                   debug=True          # 启用调试
               )
```

### 生产环境部署

```python
# 生产环境配置
A2AAgentWrapper.set_up(agent, "生产助手", "生产环境") \
               .add_skill("production", "生产功能") \
               .set_provider("Production AI", "https://prod.ai.com") \
               .set_version("1.0.0") \
               .run_a2a(
                   port=8080,
                   host="0.0.0.0",    # 允许外部访问
                   debug=False        # 关闭调试
               )
```

### Docker部署

```dockerfile
# Dockerfile
FROM python:3.9-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .
EXPOSE 8080

CMD ["python", "my_agent.py"]
```

```python
# my_agent.py
A2AAgentWrapper.set_up(agent, "Docker助手", "Docker部署") \
               .run_a2a(port=8080, host="0.0.0.0")
```

### 环境变量配置

```bash
# .env 文件
EASYA2A_PORT=8080
EASYA2A_HOST=0.0.0.0
EASYA2A_DEBUG=false
EASYA2A_PROVIDER_ORG="My AI Company"
EASYA2A_PROVIDER_URL="https://myai.com"
```

```python
# 支持环境变量
import os

port = int(os.getenv("EASYA2A_PORT", 10010))
host = os.getenv("EASYA2A_HOST", "0.0.0.0")
debug = os.getenv("EASYA2A_DEBUG", "false").lower() == "true"

A2AAgentWrapper.set_up(agent, "环境配置助手", "支持环境变量") \
               .run_a2a(port=port, host=host, debug=debug)
```

## ⚡ 性能优化

### 1. 延迟初始化策略

```python
class A2AAgentWrapper:
    def __init__(self, agent, name, description):
        # 只存储基本信息，不立即构建复杂对象
        self.agent = agent
        self.name = name
        self.description = description
        self._skills = []  # 轻量级列表

        # 重量级对象延迟创建
        self._executor = None
        self._server_app = None
        self._config = None

    def run_a2a(self, port, host):
        # 在真正需要时才构建配置
        self._config = self._build_config(port, host)  # 延迟构建
        self._create_executor(self._config)            # 延迟创建
        self._create_server_app(self._config)          # 延迟创建
```

**优势**: 减少内存占用，提高初始化速度

### 2. 异步处理优化

```python
class LangChainAgentExecutor:
    async def execute(self, request):
        """优化的异步执行"""
        try:
            # 优先使用原生异步接口
            if hasattr(self.agent, 'ainvoke'):
                result = await self.agent.ainvoke(request)
            else:
                # 同步接口在线程池中执行，避免阻塞
                import asyncio
                loop = asyncio.get_event_loop()
                result = await loop.run_in_executor(
                    None,
                    lambda: self.agent.invoke(request)
                )
            return result
        except Exception as e:
            # 异步错误处理
            logger.error(f"异步执行失败: {e}")
            raise
```

### 3. 连接池和中间件

```python
# A2AStarletteApplication 内置优化
class A2AStarletteApplication:
    def __init__(self, agent_card, http_handler):
        self.app = Starlette()

        # 添加性能中间件
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_methods=["GET", "POST"],
            allow_headers=["*"]
        )

        # 请求限流中间件
        self.app.add_middleware(
            RateLimitMiddleware,
            calls=100,
            period=60
        )

        # 响应压缩中间件
        self.app.add_middleware(GZipMiddleware, minimum_size=1000)
```

### 4. 内存管理

```python
# 智能内存管理
class TaskStore:
    def __init__(self, max_tasks=1000):
        self.tasks = {}
        self.max_tasks = max_tasks

    def add_task(self, task_id, task_data):
        # 自动清理旧任务
        if len(self.tasks) >= self.max_tasks:
            oldest_task = min(self.tasks.keys())
            del self.tasks[oldest_task]

        self.tasks[task_id] = task_data
```

### 5. 配置缓存

```python
# 配置对象缓存
class ConfigCache:
    _cache = {}

    @classmethod
    def get_config(cls, cache_key, builder_func):
        if cache_key not in cls._cache:
            cls._cache[cache_key] = builder_func()
        return cls._cache[cache_key]
```

### 性能监控

```python
# 内置性能监控
import time
from functools import wraps

def monitor_performance(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = await func(*args, **kwargs)
            duration = time.time() - start_time
            logger.info(f"⏱️ {func.__name__} 执行时间: {duration:.3f}s")
            return result
        except Exception as e:
            duration = time.time() - start_time
            logger.error(f"❌ {func.__name__} 执行失败 ({duration:.3f}s): {e}")
            raise
    return wrapper

# 自动应用到关键方法
@monitor_performance
async def execute(self, request):
    # Agent执行逻辑
    pass
```

## 🔍 故障排除

### 常见问题

1. **端口被占用**
   ```
   解决方案：更换端口或停止占用进程
   wrapper.run_a2a(port=10011)
   ```

2. **Agent不兼容**
   ```
   解决方案：检查Agent是否有invoke或chat方法
   确保Agent符合LangChain接口规范
   ```

3. **配置验证失败**
   ```
   解决方案：检查必填字段是否为空
   确保URL格式正确
   ```

### 调试模式

```python
import logging
logging.basicConfig(level=logging.DEBUG)

# 启用详细日志
wrapper.run_a2a(port=10010, debug=True)
```

### 健康检查

```python
# 访问健康检查端点
GET http://localhost:10010/health

# 响应
{
    "status": "healthy",
    "agent": "天气助手",
    "version": "1.0.0",
    "uptime": "00:05:23"
}
```

## 📋 快速参考

### 完整API速查

```python
from easya2a import A2AAgentWrapper

# 完整配置示例
A2AAgentWrapper.set_up(agent, "名称", "描述") \
    .add_skill("id", "名称", description="描述", examples=["示例"], tags=["标签"]) \
    .set_provider("组织", "网站") \
    .set_version("1.0.0") \
    .enable_streaming() \
    .enable_history() \
    .enable_multimodal() \
    .set_input_modes(["text", "json"]) \
    .set_output_modes(["text", "json"]) \
    .run_a2a(port=10010, host="0.0.0.0")
```

### 常用配置模板

```python
# 聊天机器人
A2AAgentWrapper.set_up(agent, "聊天助手", "智能对话服务") \
    .add_skill("chat", "对话", examples=["你好", "聊天"]) \
    .run_a2a()

# 工具调用Agent
A2AAgentWrapper.set_up(agent, "工具助手", "工具调用服务") \
    .add_skill("search", "搜索", examples=["搜索信息"]) \
    .add_skill("calculate", "计算", examples=["计算结果"]) \
    .enable_streaming() \
    .run_a2a()

# 多模态Agent
A2AAgentWrapper.set_up(agent, "多模态助手", "多模态AI服务") \
    .add_skill("vision", "图像理解", examples=["分析图片"]) \
    .add_skill("audio", "语音处理", examples=["语音转文字"]) \
    .enable_multimodal() \
    .run_a2a()
```

---

**技术支持**: 如有问题，请提交Issue或查看FAQ文档。
