## A breve introduction to Bayesian philosophy

In a Bayesian inference problem, we gather all the a priori  knowledge we have about the problem by defining probability distributions for our parameters $\theta$, the so-called **prior distribution**. We then need to build a statistical model, which will allow us to estimate how likely a set of parameters would be, conditioned on a given observation $X$, the so-called **likelihood** of the problem. From this, by confronting our a priori knowledge with the observations we make of the system, we can determine the probability of a parameter set given the data we have.

The whole process of Bayesian inference can thus be seen as the updating of our a priori knowledge via the additional information provided by the observations of the system, driving additional constraints (when the observations are relevant).

![diagram-20220426 (1).svg](data:image/svg+xml;base64,77u/PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwIiB5PSIwIiB3aWR0aD0iNjYyIiBoZWlnaHQ9IjE3NiIgc3R5bGU9IgogICAgICAgIHdpZHRoOjY2MnB4OwogICAgICAgIGhlaWdodDoxNzZweDsKICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsKICAgICAgICBmaWxsOiBub25lOwoiPgogICAgICAgIAogICAgICAgIAogICAgICAgIDxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBjbGFzcz0icm9sZS1kaWFncmFtLWRyYXctYXJlYSI+PGcgY2xhc3M9InNoYXBlcy1yZWdpb24iIHN0eWxlPSJzdHJva2U6IGJsYWNrOyBmaWxsOiBub25lOyI+PGcgY2xhc3M9ImNvbXBvc2l0ZS1zaGFwZSI+PHBhdGggY2xhc3M9InJlYWwiIGQ9IiBNNTkuMiw3OS44NCBDNTkuMiw1OC44NCA3Ni4zNiw0MS44MSA5Ny41Myw0MS44MSBDMTE4LjcxLDQxLjgxIDEzNS44Nyw1OC44NCAxMzUuODcsNzkuODQgQzEzNS44NywxMDAuODUgMTE4LjcxLDExNy44NyA5Ny41MywxMTcuODcgQzc2LjM2LDExNy44NyA1OS4yLDEwMC44NSA1OS4yLDc5Ljg0IFoiIHN0eWxlPSJzdHJva2Utd2lkdGg6IDE7IHN0cm9rZTogcmdiKDAsIDAsIDApOyBmaWxsOiByZ2IoNzQsIDE0NCwgMjI2KTsgZmlsbC1vcGFjaXR5OiAxOyIvPjwvZz48ZyBjbGFzcz0iY29tcG9zaXRlLXNoYXBlIj48cGF0aCBjbGFzcz0icmVhbCIgZD0iIE02OC40OSw3OS44NCBDNjguNDksNjMuOTMgODEuNDksNTEuMDMgOTcuNTMsNTEuMDMgQzExMy41Nyw1MS4wMyAxMjYuNTgsNjMuOTMgMTI2LjU4LDc5Ljg0IEMxMjYuNTgsOTUuNzYgMTEzLjU3LDEwOC42NSA5Ny41MywxMDguNjUgQzgxLjQ5LDEwOC42NSA2OC40OSw5NS43NiA2OC40OSw3OS44NCBaIiBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2U6IHJnYigwLCAwLCAwKTsgc3Ryb2tlLW9wYWNpdHk6IDE7IGZpbGw6IHJnYigxMjYsIDIxMSwgMzMpOyBmaWxsLW9wYWNpdHk6IDE7Ii8+PC9nPjxnIGNsYXNzPSJjb21wb3NpdGUtc2hhcGUiPjxwYXRoIGNsYXNzPSJyZWFsIiBkPSIgTTE5LjcsMjcuOTggQzE5LjcsMTkuNzEgMjYuNDEsMTMgMzQuNjgsMTMgTDE5Ny41NiwxMyBDMjA1LjgzLDEzIDIxMi41NCwxOS43MSAyMTIuNTQsMjcuOTggTDIxMi41NCwxNDQuMzggQzIxMi41NCwxNTIuNjYgMjA1LjgzLDE1OS4zNiAxOTcuNTYsMTU5LjM2IEwzNC42OCwxNTkuMzYgQzI2LjQxLDE1OS4zNiAxOS43LDE1Mi42NiAxOS43LDE0NC4zOCBaIiBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2U6IHJnYigyNTUsIDI1NSwgMjU1KTsgZmlsbDogbm9uZTsgZmlsbC1vcGFjaXR5OiAxOyBzdHJva2Utb3BhY2l0eTogMTsiLz48L2c+PGcgY2xhc3M9ImNvbXBvc2l0ZS1zaGFwZSI+PHBhdGggY2xhc3M9InJlYWwiIGQ9IiBNNzkuNTMsNzkuODQgQzc5LjUzLDY5Ljk4IDg3LjU5LDYxLjk4IDk3LjUzLDYxLjk4IEMxMDcuNDgsNjEuOTggMTE1LjU0LDY5Ljk4IDExNS41NCw3OS44NCBDMTE1LjU0LDg5LjcxIDEwNy40OCw5Ny43MSA5Ny41Myw5Ny43MSBDODcuNTksOTcuNzEgNzkuNTMsODkuNzEgNzkuNTMsNzkuODQgWiIgc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlOiByZ2IoMCwgMCwgMCk7IGZpbGw6IHJnYigyNDgsIDIzMSwgMjgpOyBmaWxsLW9wYWNpdHk6IDE7Ii8+PC9nPjxnIGNsYXNzPSJjb21wb3NpdGUtc2hhcGUiPjxwYXRoIGNsYXNzPSJyZWFsIiBkPSIgTTY4LjQ5LDc5Ljg0IEM2OC40OSw2My45MyA4MS40OSw1MS4wMyA5Ny41Myw1MS4wMyBDMTEzLjU3LDUxLjAzIDEyNi41OCw2My45MyAxMjYuNTgsNzkuODQgQzEyNi41OCw5NS43NiAxMTMuNTcsMTA4LjY1IDk3LjUzLDEwOC42NSBDODEuNDksMTA4LjY1IDY4LjQ5LDk1Ljc2IDY4LjQ5LDc5Ljg0IFoiIHN0eWxlPSJzdHJva2Utd2lkdGg6IDE7IHN0cm9rZTogcmdiKDAsIDAsIDApOyBmaWxsOiBub25lOyBmaWxsLW9wYWNpdHk6IDE7Ii8+PC9nPjxnIGNsYXNzPSJhcnJvdy1saW5lIj48cGF0aCBjbGFzcz0iY29ubmVjdGlvbiByZWFsIiBzdHJva2UtZGFzaGFycmF5PSIiIGQ9IiAgTTQyLjk0LDEzMS43IEwxMzAuMzgsMTMxLjciIHN0eWxlPSJzdHJva2U6IHJnYigyNTUsIDI1NSwgMjU1KTsgc3Ryb2tlLXdpZHRoOiAxOyBmaWxsOiBub25lOyBmaWxsLW9wYWNpdHk6IDE7IHN0cm9rZS1vcGFjaXR5OiAxOyIvPjxnIHN0cm9rZT0icmdiKDI1NSwyNTUsMjU1KSIgdHJhbnNmb3JtPSJtYXRyaXgoLTEsMS4yMjQ2NDY3OTkxNDczNTMyZS0xNiwtMS4yMjQ2NDY3OTkxNDczNTMyZS0xNiwtMSwxMzIuMzgzODg0MzE1MDQ1NTIsMTMxLjcwNDM0OTAxOTU1NTk2KSIgc3R5bGU9InN0cm9rZTogcmdiKDI1NSwgMjU1LCAyNTUpOyBzdHJva2Utd2lkdGg6IDE7IiBzdHJva2Utb3BhY2l0eT0iMSI+PHBhdGggZD0iIE0xMC45MywtMy4yOSBRNC45NiwtMC40NSAwLDAgUTQuOTYsMC40NSAxMC45MywzLjI5Ii8+PC9nPjwvZz48ZyBjbGFzcz0iYXJyb3ctbGluZSI+PHBhdGggY2xhc3M9ImNvbm5lY3Rpb24gcmVhbCIgc3Ryb2tlLWRhc2hhcnJheT0iIiBkPSIgIE00Mi45NCwxMzEuNyBMNDMuNjgsNDIuNjYiIHN0eWxlPSJzdHJva2U6IHJnYigyNTUsIDI1NSwgMjU1KTsgc3Ryb2tlLXdpZHRoOiAxOyBmaWxsOiBub25lOyBmaWxsLW9wYWNpdHk6IDE7IHN0cm9rZS1vcGFjaXR5OiAxOyIvPjxnIHN0cm9rZT0icmdiKDI1NSwyNTUsMjU1KSIgdHJhbnNmb3JtPSJtYXRyaXgoLTAuMDA4Mzc3NDgyNDE0NzcwNjc1LDAuOTk5OTY0OTA4Mjc4NDgwNiwtMC45OTk5NjQ5MDgyNzg0ODA2LC0wLjAwODM3NzQ4MjQxNDc3MDY3NSw0My43MDA0NDg4MTcwMjI3OSw0MC42NTkyNjU3OTA5NjQ1KSIgc3R5bGU9InN0cm9rZTogcmdiKDI1NSwgMjU1LCAyNTUpOyBzdHJva2Utd2lkdGg6IDE7IiBzdHJva2Utb3BhY2l0eT0iMSI+PHBhdGggZD0iIE0xMC45MywtMy4yOSBRNC45NiwtMC40NSAwLDAgUTQuOTYsMC40NSAxMC45MywzLjI5Ii8+PC9nPjwvZz48ZyBjbGFzcz0iY29tcG9zaXRlLXNoYXBlIj48cGF0aCBjbGFzcz0icmVhbCIgZD0iIE0xNTIuMTMsOTEuMzcgTDE2Ny4yMyw5MS4zNyBMMTY3LjIzLDEwNy41IEwxNTIuMTMsMTA3LjUgWiIgc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlOiByZ2IoMCwgMCwgMCk7IGZpbGw6IHJnYig3NCwgMTQ0LCAyMjYpOyBmaWxsLW9wYWNpdHk6IDE7Ii8+PC9nPjxnIGNsYXNzPSJjb21wb3NpdGUtc2hhcGUiPjxwYXRoIGNsYXNzPSJyZWFsIiBkPSIgTTE1Mi4xMyw3NS4yMyBMMTY3LjIzLDc1LjIzIEwxNjcuMjMsOTEuMzcgTDE1Mi4xMyw5MS4zNyBaIiBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2U6IHJnYigwLCAwLCAwKTsgZmlsbDogcmdiKDEyNiwgMjExLCAzMyk7IGZpbGwtb3BhY2l0eTogMTsiLz48L2c+PGcgY2xhc3M9ImNvbXBvc2l0ZS1zaGFwZSI+PHBhdGggY2xhc3M9InJlYWwiIGQ9IiBNMTUyLjEzLDU5LjEgTDE2Ny4yMyw1OS4xIEwxNjcuMjMsNzUuMjMgTDE1Mi4xMyw3NS4yMyBaIiBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2U6IHJnYigwLCAwLCAwKTsgZmlsbDogcmdiKDI0OCwgMjMxLCAyOCk7IGZpbGwtb3BhY2l0eTogMTsiLz48L2c+PGcgY2xhc3M9ImFycm93LWxpbmUiPjxwYXRoIGNsYXNzPSJjb25uZWN0aW9uIHJlYWwiIHN0cm9rZS1kYXNoYXJyYXk9IiIgZD0iICBNMTc1LjM3LDEwNy41IEwxNzUuMzcsNjEuMSIgc3R5bGU9InN0cm9rZTogcmdiKDI1NSwgMjU1LCAyNTUpOyBzdHJva2Utd2lkdGg6IDE7IGZpbGw6IG5vbmU7IGZpbGwtb3BhY2l0eTogMTsgc3Ryb2tlLW9wYWNpdHk6IDE7Ii8+PGcgc3Ryb2tlPSJyZ2IoMjU1LDI1NSwyNTUpIiB0cmFuc2Zvcm09Im1hdHJpeCgzLjA2MTYxNjk5Nzg2ODM4M2UtMTYsMSwtMSwzLjA2MTYxNjk5Nzg2ODM4M2UtMTYsMTc1LjM2NTM2NTc2MDUxNTc0LDU5LjA5ODc3NjMxODI3NDE2KSIgc3R5bGU9InN0cm9rZTogcmdiKDI1NSwgMjU1LCAyNTUpOyBzdHJva2Utd2lkdGg6IDE7IiBzdHJva2Utb3BhY2l0eT0iMSI+PHBhdGggZD0iIE0xMC45MywtMy4yOSBRNC45NiwtMC40NSAwLDAgUTQuOTYsMC40NSAxMC45MywzLjI5Ii8+PC9nPjwvZz48ZyBjbGFzcz0iY29tcG9zaXRlLXNoYXBlIj48cGF0aCBjbGFzcz0icmVhbCIgZD0iIE00OTQuNzQsMTA2LjM1IEM0ODQuOSw5Ni4xNyA0ODUuNyw4Ny45MSA0OTYuNTIsODcuOTEgQzUwNy4zNSw4Ny45MSA1MjQuMSw5Ni4xNyA1MzMuOTQsMTA2LjM1IEM1NDMuNzgsMTE2LjUzIDU0Mi45OCwxMjQuNzkgNTMyLjE1LDEyNC43OSBDNTIxLjMzLDEyNC43OSA1MDQuNTgsMTE2LjUzIDQ5NC43NCwxMDYuMzUgWiIgc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlOiByZ2IoMCwgMCwgMCk7IGZpbGw6IHJnYig3NCwgMTQ0LCAyMjYpOyBmaWxsLW9wYWNpdHk6IDE7Ii8+PC9nPjxnIGNsYXNzPSJjb21wb3NpdGUtc2hhcGUiPjxwYXRoIGNsYXNzPSJyZWFsIiBkPSIgTTQ5OS40OSwxMDYuMzUgQzQ5Mi42LDk4LjYzIDQ5My42Nyw5Mi4zOCA1MDEuODYsOTIuMzggQzUxMC4wNiw5Mi4zOCA1MjIuMjksOTguNjMgNTI5LjE4LDEwNi4zNSBDNTM2LjA3LDExNC4wNyA1MzUuMDEsMTIwLjMyIDUyNi44MSwxMjAuMzIgQzUxOC42MSwxMjAuMzIgNTA2LjM4LDExNC4wNyA0OTkuNDksMTA2LjM1IFoiIHN0eWxlPSJzdHJva2Utd2lkdGg6IDE7IHN0cm9rZTogcmdiKDAsIDAsIDApOyBzdHJva2Utb3BhY2l0eTogMTsgZmlsbDogcmdiKDEyNiwgMjExLCAzMyk7IGZpbGwtb3BhY2l0eTogMTsiLz48L2c+PGcgY2xhc3M9ImNvbXBvc2l0ZS1zaGFwZSI+PHBhdGggY2xhc3M9InJlYWwiIGQ9IiBNNDU0LjE2LDI3Ljk4IEM0NTQuMTYsMTkuNzEgNDYwLjg3LDEzIDQ2OS4xNSwxMyBMNjMyLjAyLDEzIEM2NDAuMjksMTMgNjQ3LDE5LjcxIDY0NywyNy45OCBMNjQ3LDE0NC4zOCBDNjQ3LDE1Mi42NiA2NDAuMjksMTU5LjM2IDYzMi4wMiwxNTkuMzYgTDQ2OS4xNSwxNTkuMzYgQzQ2MC44NywxNTkuMzYgNDU0LjE2LDE1Mi42NiA0NTQuMTYsMTQ0LjM4IFoiIHN0eWxlPSJzdHJva2Utd2lkdGg6IDE7IHN0cm9rZTogcmdiKDI1NSwgMjU1LCAyNTUpOyBmaWxsOiBub25lOyBmaWxsLW9wYWNpdHk6IDE7IHN0cm9rZS1vcGFjaXR5OiAxOyIvPjwvZz48ZyBjbGFzcz0iY29tcG9zaXRlLXNoYXBlIj48cGF0aCBjbGFzcz0icmVhbCIgZD0iIE01MDUuMTQsMTA2LjIxIEM1MDAsMTAxLjM0IDQ5OS45Niw5Ny40NiA1MDUuMDQsOTcuNTQgQzUxMC4xMiw5Ny42MiA1MTguNCwxMDEuNjMgNTIzLjU0LDEwNi40OSBDNTI4LjY3LDExMS4zNiA1MjguNzIsMTE1LjI0IDUyMy42NCwxMTUuMTYgQzUxOC41NiwxMTUuMDggNTEwLjI3LDExMS4wNyA1MDUuMTQsMTA2LjIxIFoiIHN0eWxlPSJzdHJva2Utd2lkdGg6IDE7IHN0cm9rZTogcmdiKDAsIDAsIDApOyBmaWxsOiByZ2IoMjQ4LCAyMzEsIDI4KTsgZmlsbC1vcGFjaXR5OiAxOyIvPjwvZz48ZyBjbGFzcz0iYXJyb3ctbGluZSI+PHBhdGggY2xhc3M9ImNvbm5lY3Rpb24gcmVhbCIgc3Ryb2tlLWRhc2hhcnJheT0iIiBkPSIgIE00NzcuNCwxMzEuNyBMNTY0Ljg1LDEzMS43IiBzdHlsZT0ic3Ryb2tlOiByZ2IoMjU1LCAyNTUsIDI1NSk7IHN0cm9rZS13aWR0aDogMTsgZmlsbDogbm9uZTsgZmlsbC1vcGFjaXR5OiAxOyBzdHJva2Utb3BhY2l0eTogMTsiLz48ZyBzdHJva2U9InJnYigyNTUsMjU1LDI1NSkiIHRyYW5zZm9ybT0ibWF0cml4KC0xLDEuMjI0NjQ2Nzk5MTQ3MzUzMmUtMTYsLTEuMjI0NjQ2Nzk5MTQ3MzUzMmUtMTYsLTEsNTY2Ljg0NTM0NTQxMjUwMTQsMTMxLjcwNDM0OTAxOTU1NTkzKSIgc3R5bGU9InN0cm9rZTogcmdiKDI1NSwgMjU1LCAyNTUpOyBzdHJva2Utd2lkdGg6IDE7IiBzdHJva2Utb3BhY2l0eT0iMSI+PHBhdGggZD0iIE0xMC45MywtMy4yOSBRNC45NiwtMC40NSAwLDAgUTQuOTYsMC40NSAxMC45MywzLjI5Ii8+PC9nPjwvZz48ZyBjbGFzcz0iYXJyb3ctbGluZSI+PHBhdGggY2xhc3M9ImNvbm5lY3Rpb24gcmVhbCIgc3Ryb2tlLWRhc2hhcnJheT0iIiBkPSIgIE00NzcuNCwxMzEuNyBMNDc4LjE1LDQyLjY2IiBzdHlsZT0ic3Ryb2tlOiByZ2IoMjU1LCAyNTUsIDI1NSk7IHN0cm9rZS13aWR0aDogMTsgZmlsbDogbm9uZTsgZmlsbC1vcGFjaXR5OiAxOyBzdHJva2Utb3BhY2l0eTogMTsiLz48ZyBzdHJva2U9InJnYigyNTUsMjU1LDI1NSkiIHRyYW5zZm9ybT0ibWF0cml4KC0wLjAwODM3NzQ4MjQxNDc3MDY3NSwwLjk5OTk2NDkwODI3ODQ4MDYsLTAuOTk5OTY0OTA4Mjc4NDgwNiwtMC4wMDgzNzc0ODI0MTQ3NzA2NzUsNDc4LjE2MTkwOTkxNDQ3ODY2LDQwLjY1OTI2NTc5MDk2NDUyNSkiIHN0eWxlPSJzdHJva2U6IHJnYigyNTUsIDI1NSwgMjU1KTsgc3Ryb2tlLXdpZHRoOiAxOyIgc3Ryb2tlLW9wYWNpdHk9IjEiPjxwYXRoIGQ9IiBNMTAuOTMsLTMuMjkgUTQuOTYsLTAuNDUgMCwwIFE0Ljk2LDAuNDUgMTAuOTMsMy4yOSIvPjwvZz48L2c+PGcgY2xhc3M9ImNvbXBvc2l0ZS1zaGFwZSI+PHBhdGggY2xhc3M9InJlYWwiIGQ9IiBNNTg2LjU5LDkxLjM3IEw2MDEuNyw5MS4zNyBMNjAxLjcsMTA3LjUgTDU4Ni41OSwxMDcuNSBaIiBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2U6IHJnYigwLCAwLCAwKTsgZmlsbDogcmdiKDc0LCAxNDQsIDIyNik7IGZpbGwtb3BhY2l0eTogMTsiLz48L2c+PGcgY2xhc3M9ImNvbXBvc2l0ZS1zaGFwZSI+PHBhdGggY2xhc3M9InJlYWwiIGQ9IiBNNTg2LjU5LDc1LjIzIEw2MDEuNyw3NS4yMyBMNjAxLjcsOTEuMzcgTDU4Ni41OSw5MS4zNyBaIiBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2U6IHJnYigwLCAwLCAwKTsgZmlsbDogcmdiKDEyNiwgMjExLCAzMyk7IGZpbGwtb3BhY2l0eTogMTsiLz48L2c+PGcgY2xhc3M9ImNvbXBvc2l0ZS1zaGFwZSI+PHBhdGggY2xhc3M9InJlYWwiIGQ9IiBNNTg2LjU5LDU5LjEgTDYwMS43LDU5LjEgTDYwMS43LDc1LjIzIEw1ODYuNTksNzUuMjMgWiIgc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlOiByZ2IoMCwgMCwgMCk7IGZpbGw6IHJnYigyNDgsIDIzMSwgMjgpOyBmaWxsLW9wYWNpdHk6IDE7Ii8+PC9nPjxnIGNsYXNzPSJhcnJvdy1saW5lIj48cGF0aCBjbGFzcz0iY29ubmVjdGlvbiByZWFsIiBzdHJva2UtZGFzaGFycmF5PSIiIGQ9IiAgTTYwOS44MywxMDcuNSBMNjA5LjgzLDYxLjEiIHN0eWxlPSJzdHJva2U6IHJnYigyNTUsIDI1NSwgMjU1KTsgc3Ryb2tlLXdpZHRoOiAxOyBmaWxsOiBub25lOyBmaWxsLW9wYWNpdHk6IDE7IHN0cm9rZS1vcGFjaXR5OiAxOyIvPjxnIHN0cm9rZT0icmdiKDI1NSwyNTUsMjU1KSIgdHJhbnNmb3JtPSJtYXRyaXgoMy4wNjE2MTY5OTc4NjgzODNlLTE2LDEsLTEsMy4wNjE2MTY5OTc4NjgzODNlLTE2LDYwOS44MjY4MjY4NTc5NzE2LDU5LjA5ODc3NjMxODI3NDE5KSIgc3R5bGU9InN0cm9rZTogcmdiKDI1NSwgMjU1LCAyNTUpOyBzdHJva2Utd2lkdGg6IDE7IiBzdHJva2Utb3BhY2l0eT0iMSI+PHBhdGggZD0iIE0xMC45MywtMy4yOSBRNC45NiwtMC40NSAwLDAgUTQuOTYsMC40NSAxMC45MywzLjI5Ii8+PC9nPjwvZz48ZyBjbGFzcz0iY29tcG9zaXRlLXNoYXBlIj48cGF0aCBjbGFzcz0icmVhbCIgZD0iIE0yMzcuMjIsMjguNDIgQzIzNy4yMiwyMC4xNiAyNDMuOTIsMTMuNDYgMjUyLjE4LDEzLjQ2IEw0MTUuMSwxMy40NiBDNDIzLjM2LDEzLjQ2IDQzMC4wNiwyMC4xNiA0MzAuMDYsMjguNDIgTDQzMC4wNiwxNDQuNjQgQzQzMC4wNiwxNTIuOSA0MjMuMzYsMTU5LjYgNDE1LjEsMTU5LjYgTDI1Mi4xOCwxNTkuNiBDMjQzLjkyLDE1OS42IDIzNy4yMiwxNTIuOSAyMzcuMjIsMTQ0LjY0IFoiIHN0eWxlPSJzdHJva2Utd2lkdGg6IDE7IHN0cm9rZTogcmdiKDI1NSwgMjU1LCAyNTUpOyBmaWxsOiBub25lOyBmaWxsLW9wYWNpdHk6IDE7IHN0cm9rZS1vcGFjaXR5OiAxOyIvPjwvZz48ZyBjbGFzcz0iYXJyb3ctbGluZSI+PHBhdGggY2xhc3M9ImNvbm5lY3Rpb24gcmVhbCIgc3Ryb2tlLWRhc2hhcnJheT0iIiBkPSIgIE0yNTguMTMsMTQxLjE5IEw0MTguNzcsMTQxLjE5IiBzdHlsZT0ic3Ryb2tlOiByZ2IoMjU1LCAyNTUsIDI1NSk7IHN0cm9rZS13aWR0aDogMTsgZmlsbDogbm9uZTsgZmlsbC1vcGFjaXR5OiAxOyBzdHJva2Utb3BhY2l0eTogMTsiLz48ZyBzdHJva2U9InJnYigyNTUsMjU1LDI1NSkiIHRyYW5zZm9ybT0ibWF0cml4KC0xLDEuMjI0NjQ2Nzk5MTQ3MzUzMmUtMTYsLTEuMjI0NjQ2Nzk5MTQ3MzUzMmUtMTYsLTEsNDIwLjc2NjM5MTU4MDkzNywxNDEuMTg4Nzc4MDc5NjIyMykiIHN0eWxlPSJzdHJva2U6IHJnYigyNTUsIDI1NSwgMjU1KTsgc3Ryb2tlLXdpZHRoOiAxOyIgc3Ryb2tlLW9wYWNpdHk9IjEiPjxwYXRoIGQ9IiBNMTAuOTMsLTMuMjkgUTQuOTYsLTAuNDUgMCwwIFE0Ljk2LDAuNDUgMTAuOTMsMy4yOSIvPjwvZz48L2c+PGcgY2xhc3M9ImFycm93LWxpbmUiPjxwYXRoIGNsYXNzPSJjb25uZWN0aW9uIHJlYWwiIHN0cm9rZS1kYXNoYXJyYXk9IiIgZD0iICBNMjU4LjEzLDE0MS4xOSBMMjU4Ljg4LDUyLjI4IiBzdHlsZT0ic3Ryb2tlOiByZ2IoMjU1LCAyNTUsIDI1NSk7IHN0cm9rZS13aWR0aDogMTsgZmlsbDogbm9uZTsgZmlsbC1vcGFjaXR5OiAxOyBzdHJva2Utb3BhY2l0eTogMTsiLz48ZyBzdHJva2U9InJnYigyNTUsMjU1LDI1NSkiIHRyYW5zZm9ybT0ibWF0cml4KC0wLjAwODM3NzQ4MjQxNDc3MDY3NSwwLjk5OTk2NDkwODI3ODQ4MDYsLTAuOTk5OTY0OTA4Mjc4NDgwNiwtMC4wMDgzNzc0ODI0MTQ3NzA2NzUsMjU4Ljg5ODI3MTQ1OTU0NjEsNTAuMjgzNDE1MDUxOTIwMDMpIiBzdHlsZT0ic3Ryb2tlOiByZ2IoMjU1LCAyNTUsIDI1NSk7IHN0cm9rZS13aWR0aDogMTsiIHN0cm9rZS1vcGFjaXR5PSIxIj48cGF0aCBkPSIgTTEwLjkzLC0zLjI5IFE0Ljk2LC0wLjQ1IDAsMCBRNC45NiwwLjQ1IDEwLjkzLDMuMjkiLz48L2c+PC9nPjxnIGNsYXNzPSJhcnJvdy1saW5lIj48cGF0aCBjbGFzcz0iY29ubmVjdGlvbiByZWFsIiBzdHJva2UtZGFzaGFycmF5PSIiIGQ9IiAgTTI1OC41Miw5NS43NCBDMzA0Ljk4LDYxLjIyIDM1MS4wNywxNTMuODUgMzk3LjUzLDExOS4zMyIgc3R5bGU9InN0cm9rZTogcmdiKDIwOCwgMiwgMjcpOyBzdHJva2Utb3BhY2l0eTogMTsgc3Ryb2tlLXdpZHRoOiAxOyBmaWxsOiBub25lOyBmaWxsLW9wYWNpdHk6IDE7Ii8+PC9nPjxnIGNsYXNzPSJhcnJvdy1saW5lIj48cGF0aCBjbGFzcz0iY29ubmVjdGlvbiByZWFsIiBzdHJva2UtZGFzaGFycmF5PSIiIGQ9IiAgTTI1OC41MiwxMTkuOSBDMzA0Ljk4LDg1LjM4IDI4Mi41Myw3MSAzMjAuODYsMTExLjI3IEMzNTkuMiwxNTEuNTUgMzYzLjg0LDEwNS41MiAzOTIuODksNzYuNzUiIHN0eWxlPSJzdHJva2U6IHJnYigyNDgsIDIzMSwgMjgpOyBzdHJva2Utb3BhY2l0eTogMTsgc3Ryb2tlLXdpZHRoOiAxOyBmaWxsOiBub25lOyBmaWxsLW9wYWNpdHk6IDE7Ii8+PC9nPjxnIGNsYXNzPSJhcnJvdy1saW5lIj48cGF0aCBjbGFzcz0iY29ubmVjdGlvbiByZWFsIiBzdHJva2UtZGFzaGFycmF5PSIiIGQ9IiAgTTI1OC41MiwxMDYuMDkgQzMwNi45MiwxNDYuOTQgMzQ4Ljc0LDczLjMgMzk3LjUzLDEyOS42OCIgc3R5bGU9InN0cm9rZTogcmdiKDI0NSwgMTY2LCAzNSk7IHN0cm9rZS1vcGFjaXR5OiAxOyBzdHJva2Utd2lkdGg6IDE7IGZpbGw6IG5vbmU7IGZpbGwtb3BhY2l0eTogMTsiLz48L2c+PGcvPjwvZz48Zy8+PGcvPjxnLz48L3N2Zz4KICAgICAgICA8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI2NjAiIGhlaWdodD0iMTc0IiBzdHlsZT0id2lkdGg6NjYwcHg7aGVpZ2h0OjE3NHB4O2ZvbnQtZmFtaWx5OkFzYW5hLU1hdGgsIEFzYW5hO2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7Ij48Zz48Zz48Zz48dGV4dCB4PSI1MS4xMDYyNjIyMDcwMzEyNSIgeT0iMTQwLjQ1NjI1MzA1MTc1NzgiIHN0eWxlPSJ3aGl0ZS1zcGFjZTpwcmU7c3Ryb2tlOm5vbmU7ZmlsbDpyZ2IoMjU1LDI1NSwyNTUpO2ZpbGwtb3BhY2l0eToxO2ZvbnQtc2l6ZToxMC41cHg7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtmb250LXdlaWdodDo0MDA7Zm9udC1zdHlsZTpub3JtYWw7ZG9taW5hbnQtYmFzZWxpbmU6dGV4dC1iZWZvcmUtZWRnZTt0ZXh0LWRlY29yYXRpb246bm9uZSBzb2xpZCByZ2IoMjU1LCAyNTUsIDI1NSk7Ij5QYXJhbWV0ZXIgMTwvdGV4dD48L2c+PC9nPjwvZz48ZyB0cmFuc2Zvcm09Im1hdHJpeCgtMS44MzY5NzAxOTg3MjEwMjk3ZS0xNiwtMSwxLC0xLjgzNjk3MDE5ODcyMTAyOTdlLTE2LC02Ni4zNDk5OTA4NDQ3MjY1NiwxMjYuNjYyNDkwODQ0NzI2NTgpIj48Zz48Zz48dGV4dCB4PSIxLjI2NTYyNSIgeT0iOTIuMDA2MjQwODQ0NzI2NTYiIHN0eWxlPSJ3aGl0ZS1zcGFjZTpwcmU7c3Ryb2tlOm5vbmU7ZmlsbDpyZ2IoMjU1LDI1NSwyNTUpO2ZpbGwtb3BhY2l0eToxO2ZvbnQtc2l6ZToxMC41cHg7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtmb250LXdlaWdodDo0MDA7Zm9udC1zdHlsZTpub3JtYWw7ZG9taW5hbnQtYmFzZWxpbmU6dGV4dC1iZWZvcmUtZWRnZTt0ZXh0LWRlY29yYXRpb246bm9uZSBzb2xpZCByZ2IoMjU1LCAyNTUsIDI1NSk7Ij5QYXJhbWV0ZXIgMjwvdGV4dD48L2c+PC9nPjwvZz48ZyB0cmFuc2Zvcm09Im1hdHJpeCgtMS44MzY5NzAxOTg3MjEwMjk3ZS0xNiwtMSwxLC0xLjgzNjk3MDE5ODcyMTAyOTdlLTE2LDEwNS44ODEyNTk5MTgyMTI5MiwyNjcuODQzNzUzODE0Njk3MjcpIj48Zz48Zz48dGV4dCB4PSIxNjIuMzUwMDA2MTAzNTE1NjIiIHk9Ijc2LjQ4MTI0Njk0ODI0MjE5IiBzdHlsZT0id2hpdGUtc3BhY2U6cHJlO3N0cm9rZTpub25lO2ZpbGw6cmdiKDI1NSwyNTUsMjU1KTtmaWxsLW9wYWNpdHk6MTtmb250LXNpemU6MTAuNXB4O2ZvbnQtZmFtaWx5OkFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsO2RvbWluYW50LWJhc2VsaW5lOnRleHQtYmVmb3JlLWVkZ2U7dGV4dC1kZWNvcmF0aW9uOm5vbmUgc29saWQgcmdiKDI1NSwgMjU1LCAyNTUpOyI+UHJvYmFiaWxpdHk8L3RleHQ+PC9nPjwvZz48L2c+PGc+PGc+PGc+PHRleHQgeD0iODkuNTM3NTA2MTAzNTE1NjIiIHk9IjE3LjE3NDk4Nzc5Mjk2ODc1IiBzdHlsZT0id2hpdGUtc3BhY2U6cHJlO3N0cm9rZTpub25lO2ZpbGw6cmdiKDI1NSwyNTUsMjU1KTtmaWxsLW9wYWNpdHk6MTtmb250LXNpemU6MTVweDtmb250LWZhbWlseTpBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjcwMDtmb250LXN0eWxlOm5vcm1hbDtkb21pbmFudC1iYXNlbGluZTp0ZXh0LWJlZm9yZS1lZGdlO3RleHQtZGVjb3JhdGlvbjpub25lIHNvbGlkIHJnYigyNTUsIDI1NSwgMjU1KTsiPjEpIFByaW9yPC90ZXh0PjwvZz48L2c+PC9nPjxnPjxnPjxnPjx0ZXh0IHg9IjI3OC4yOTk5ODc3OTI5Njg3NSIgeT0iMTcuNjEyNDg3NzkyOTY4NzUiIHN0eWxlPSJ3aGl0ZS1zcGFjZTpwcmU7c3Ryb2tlOm5vbmU7ZmlsbDpyZ2IoMjU1LDI1NSwyNTUpO2ZpbGwtb3BhY2l0eToxO2ZvbnQtc2l6ZToxNXB4O2ZvbnQtZmFtaWx5OkFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NzAwO2ZvbnQtc3R5bGU6bm9ybWFsO2RvbWluYW50LWJhc2VsaW5lOnRleHQtYmVmb3JlLWVkZ2U7dGV4dC1kZWNvcmF0aW9uOm5vbmUgc29saWQgcmdiKDI1NSwgMjU1LCAyNTUpOyI+MikgT2JzZXJ2YXRpb25zPC90ZXh0PjwvZz48L2c+PC9nPjxnPjxnPjxnPjx0ZXh0IHg9IjMyMi43MTg3NSIgeT0iMTQ1LjMxODc0MDg0NDcyNjU2IiBzdHlsZT0id2hpdGUtc3BhY2U6cHJlO3N0cm9rZTpub25lO2ZpbGw6cmdiKDI1NSwyNTUsMjU1KTtmaWxsLW9wYWNpdHk6MTtmb250LXNpemU6MTAuNXB4O2ZvbnQtZmFtaWx5OkFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsO2RvbWluYW50LWJhc2VsaW5lOnRleHQtYmVmb3JlLWVkZ2U7dGV4dC1kZWNvcmF0aW9uOm5vbmUgc29saWQgcmdiKDI1NSwgMjU1LCAyNTUpOyI+VGltZTwvdGV4dD48L2c+PC9nPjwvZz48ZyB0cmFuc2Zvcm09Im1hdHJpeCgtMS44MzY5NzAxOTg3MjEwMjk3ZS0xNiwtMSwxLC0xLjgzNjk3MDE5ODcyMTAyOTdlLTE2LDE1MS42NDk5OTc3MTExODE3LDM0Mi41Mzc0Nzk0MDA2MzQ3NykiPjxnPjxnPjx0ZXh0IHg9IjIzMC40NTYyMzc3OTI5Njg3NSIgeT0iOTAuOTQzNzQwODQ0NzI2NTYiIHN0eWxlPSJ3aGl0ZS1zcGFjZTpwcmU7c3Ryb2tlOm5vbmU7ZmlsbDpyZ2IoMjU1LDI1NSwyNTUpO2ZpbGwtb3BhY2l0eToxO2ZvbnQtc2l6ZToxMC41cHg7Zm9udC1mYW1pbHk6QXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtmb250LXdlaWdodDo0MDA7Zm9udC1zdHlsZTpub3JtYWw7ZG9taW5hbnQtYmFzZWxpbmU6dGV4dC1iZWZvcmUtZWRnZTt0ZXh0LWRlY29yYXRpb246bm9uZSBzb2xpZCByZ2IoMjU1LCAyNTUsIDI1NSk7Ij5Db3VudHM8L3RleHQ+PC9nPjwvZz48L2c+PGc+PGc+PGc+PHRleHQgeD0iNDg1LjU2ODc4NjYyMTA5Mzc1IiB5PSIxNDAuNDU2MjUzMDUxNzU3OCIgc3R5bGU9IndoaXRlLXNwYWNlOnByZTtzdHJva2U6bm9uZTtmaWxsOnJnYigyNTUsMjU1LDI1NSk7ZmlsbC1vcGFjaXR5OjE7Zm9udC1zaXplOjEwLjVweDtmb250LWZhbWlseTpBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbDtkb21pbmFudC1iYXNlbGluZTp0ZXh0LWJlZm9yZS1lZGdlO3RleHQtZGVjb3JhdGlvbjpub25lIHNvbGlkIHJnYigyNTUsIDI1NSwgMjU1KTsiPlBhcmFtZXRlciAxPC90ZXh0PjwvZz48L2c+PC9nPjxnIHRyYW5zZm9ybT0ibWF0cml4KC0xLjgzNjk3MDE5ODcyMTAyOTdlLTE2LC0xLDEsLTEuODM2OTcwMTk4NzIxMDI5N2UtMTYsMzY4LjExMjUzMzU2OTMzNjA1LDU2MS4xMjUwMTUyNTg3ODkxKSI+PGc+PGc+PHRleHQgeD0iNDM1LjcyODE0OTQxNDA2MjUiIHk9IjkyLjAwNjI0MDg0NDcyNjU2IiBzdHlsZT0id2hpdGUtc3BhY2U6cHJlO3N0cm9rZTpub25lO2ZpbGw6cmdiKDI1NSwyNTUsMjU1KTtmaWxsLW9wYWNpdHk6MTtmb250LXNpemU6MTAuNXB4O2ZvbnQtZmFtaWx5OkFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsO2RvbWluYW50LWJhc2VsaW5lOnRleHQtYmVmb3JlLWVkZ2U7dGV4dC1kZWNvcmF0aW9uOm5vbmUgc29saWQgcmdiKDI1NSwgMjU1LCAyNTUpOyI+UGFyYW1ldGVyIDI8L3RleHQ+PC9nPjwvZz48L2c+PGcgdHJhbnNmb3JtPSJtYXRyaXgoLTEuODM2OTcwMTk4NzIxMDI5N2UtMTYsLTEsMSwtMS44MzY5NzAxOTg3MjEwMjk3ZS0xNiw1MzQuODM3NTI4MjI4NzU5OSw3MDMuMzk5OTk3NzExMTgxNikiPjxnPjxnPjx0ZXh0IHg9IjU5NC42MDYyNjIyMDcwMzEyIiB5PSI3OS43ODEyMzQ3NDEyMTA5NCIgc3R5bGU9IndoaXRlLXNwYWNlOnByZTtzdHJva2U6bm9uZTtmaWxsOnJnYigyNTUsMjU1LDI1NSk7ZmlsbC1vcGFjaXR5OjE7Zm9udC1zaXplOjEwLjVweDtmb250LWZhbWlseTpBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbDtkb21pbmFudC1iYXNlbGluZTp0ZXh0LWJlZm9yZS1lZGdlO3RleHQtZGVjb3JhdGlvbjpub25lIHNvbGlkIHJnYigyNTUsIDI1NSwgMjU1KTsiPlByb2JhYmlsaXR5PC90ZXh0PjwvZz48L2c+PC9nPjxnPjxnPjxnPjx0ZXh0IHg9IjUwOS4wODEyMzc3OTI5Njg3NSIgeT0iMTcuMTc0OTg3NzkyOTY4NzUiIHN0eWxlPSJ3aGl0ZS1zcGFjZTpwcmU7c3Ryb2tlOm5vbmU7ZmlsbDpyZ2IoMjU1LDI1NSwyNTUpO2ZpbGwtb3BhY2l0eToxO2ZvbnQtc2l6ZToxNXB4O2ZvbnQtZmFtaWx5OkFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NzAwO2ZvbnQtc3R5bGU6bm9ybWFsO2RvbWluYW50LWJhc2VsaW5lOnRleHQtYmVmb3JlLWVkZ2U7dGV4dC1kZWNvcmF0aW9uOm5vbmUgc29saWQgcmdiKDI1NSwgMjU1LCAyNTUpOyI+MykgUG9zdGVyaW9yPC90ZXh0PjwvZz48L2c+PC9nPjwvc3ZnPgo8L3N2Zz4K)

## Some maths (very little)

The main goal of a Bayesian inference problem is to compute the posterior distribution of a given parameter $\theta$, conditioned on an observation $X$, i.e. the probability $P(\theta \vert X)$. To do so, we rely on the Bayes formula :

$$ P(\theta \vert X) = \frac{P(X \vert \theta)P(\theta)}{P(X)} $$


*   $P(X)$ is called the evidence, this quantity is of little use as it remains constant for a given problem and simply consist in a normalization factor that exists to ensure the integrability of $P(\theta \vert X)$
*   $P(\theta)$ is the prior distribution of our parameters
*   $P(X \vert \theta)$ is the likelihood of our problem, which translate how likely is an observation given a set of parameters

Evaluating the posterior distribution can seem easy at first sight, but it is not, as those probabilities hide high dimension integrals. But as we have almost neat computational power in 2022 (1 iPhone X $\sim$ 100,000 times the processing power of the computer that landed man), we developed solutions to compute approximations for the posterior distribution.

## Fantastic Samplers ...

A **sampler** is a Markov-Chain/Monte-Carlo (MCMC) method to estimate the posterior distribution of a given problem. It launches Markov-Chains that will wander in the parameter space, and after a given time, the samples in the chain will be distributed according to the posterior distribution. There is a huge number of samplers used in the state of the art. Most of them rely on {proposal + random acceptance} of new states, some of them require computing the gradient of the likelihood as a function of parameters. You can find a [nice illustration](https://chi-feng.github.io/mcmc-demo/app.html?algorithm=EfficientNUTS&target=donut) of various sampling algorithm, to get a visual idea of how they work.

In theory, the posterior distribution is independent of the sampler used to approximate it. However, some performs better with fancy posterior, some are slower, some are faster. A good sampler ensures that the final samples are lowly correlated, and it converges fast to the stationary distribution.

A brief list of the most used ones :

*    [Metropolis-Hastings](https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm) is the most basic sampling algorithm you can imagine. At each step, it proposes a new state for the chain. If the new state improves the likelihood, then it is accepted. Otherwise, it is rejected or accepted with a probability function of the likelihood difference between the two states. This enables the chain to possibly spend time in every possible location of the parameter space, while spending most of his time around the maxima of likelihood.
*   [Hamiltonian Monte Carlo](https://en.wikipedia.org/wiki/Hamiltonian_Monte_Carlo) (HMC) is a sampling algorithm where the new states are proposed using Hamiltonian dynamic propagation. The new possible states are often "far away" to the previous step (when compared to Metropolis-Hastings) which reduce the correlation between successive states while keeping a good acceptance rate because of the energy conserving propagation.
*   [No U-Turn Sampler](https://en.wikipedia.org/wiki/Hamiltonian_Monte_Carlo#No_U-Turn_Sampler) (NUTS) is an improvement of HMC, which includes an adaptive step which is correlated to the curvature of the posterior distribution around the state of the chain. It also contains several fancy features such as a doubling scheme until the achievement of a U-turn to ensure quality in the next states.
* [Nested Sampling Algoritm](https://en.wikipedia.org/wiki/Nested_sampling_algorithm) proposes a MCMC-free approach, relying on evolutionary strategies where the posterior distribution will be learned through redistribution of successive generations of parameters

**Never code your sampler by yourself : it already exists and yours will be BAD.**

## and where to find them !

There are a LOT of packages proposing Bayesian computing in Python. I will list some of them here :

*   [emcee](https://emcee.readthedocs.io/en/stable/) is probably the lightest weight and the most used library for MCMC sampling. However, you have to define the prior and likelihood by yourself, which can be pretty tedious. It relies on a Metropolis-like algorithm to perform the posterior computation
*   [ultranest](https://johannesbuchner.github.io/UltraNest/index.html) is the reference for Pythonic nested sampling. Still a bit tedious as you have to define the prior as transformations of a N-dimensional unitary uniform random variable
*   [PyMC](https://docs.pymc.io/en/v3/) which is my favorite, as it is both user-friendly and very sophisticated regarding the features it proposes, and implements NUTS-sampler without having to explicitly knowing the gradient of your likelihood thanks to autodifferentiation libraries (theanos for v3 and aesara for v4). **This is the library you should try first**.
*  [pyro](https://docs.pyro.ai/en/stable/) which strongly embeds machine learning through pytorch, and implements low-level variational inference methods.
*  [numpyro](https://num.pyro.ai/en/stable/) which is the one I am using for my thesis, proposes super fast computation and autodifferentiation with JAX

## Variational inference

